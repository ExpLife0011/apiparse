#include <cppdumputils.h>
class TableInit {
public:
  TableInit() {
    CLASS_BEGIN("IUnknown");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppvObject", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    CLASS_END("IUnknown");
    CLASS_BEGIN("IDXGIObject");
    METHOD_BEGIN("HRESULT", "SetPrivateData");
    PARAM("const GUID &", "GUID", "Name", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "DataSize");
    METHOD_END("HRESULT", "SetPrivateData");
    METHOD_BEGIN("HRESULT", "SetPrivateDataInterface");
    PARAM("const GUID &", "GUID", "Name", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("const struct IUnknown *", "IUnknown", "pUnknown", ParamAnnot::_IN_, 1, true, sizeof(const struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    METHOD_END("HRESULT", "SetPrivateDataInterface");
    METHOD_BEGIN("HRESULT", "GetPrivateData");
    PARAM("const GUID &", "GUID", "Name", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT *", "UINT", "pDataSize", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "pDataSize");
    METHOD_END("HRESULT", "GetPrivateData");
    METHOD_BEGIN("HRESULT", "GetParent");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppParent", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "GetParent");
    CLASS_END("IDXGIObject");
    CLASS_BEGIN("IDXGIDeviceSubObject");
    METHOD_BEGIN("HRESULT", "GetDevice");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppDevice", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "GetDevice");
    CLASS_END("IDXGIDeviceSubObject");
    CLASS_BEGIN("IDXGIResource");
    METHOD_BEGIN("HRESULT", "GetSharedHandle");
    PARAM("HANDLE *", "HANDLE", "pSharedHandle", ParamAnnot::_OUT_, 1, false, sizeof(HANDLE *), sizeof(HANDLE), "NOT_SET");
    METHOD_END("HRESULT", "GetSharedHandle");
    METHOD_BEGIN("HRESULT", "GetUsage");
    PARAM("DXGI_USAGE *", "DXGI_USAGE", "pUsage", ParamAnnot::_IN_, 1, false, sizeof(DXGI_USAGE *), sizeof(DXGI_USAGE), "NOT_SET");
    METHOD_END("HRESULT", "GetUsage");
    METHOD_BEGIN("HRESULT", "SetEvictionPriority");
    PARAM("UINT", "UINT", "EvictionPriority", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetEvictionPriority");
    METHOD_BEGIN("HRESULT", "GetEvictionPriority");
    PARAM("UINT *", "UINT", "pEvictionPriority", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetEvictionPriority");
    CLASS_END("IDXGIResource");
    CLASS_BEGIN("IDXGIKeyedMutex");
    METHOD_BEGIN("HRESULT", "AcquireSync");
    PARAM("UINT64", "UINT64", "Key", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    PARAM("DWORD", "DWORD", "dwMilliseconds", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "AcquireSync");
    METHOD_BEGIN("HRESULT", "ReleaseSync");
    PARAM("UINT64", "UINT64", "Key", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "ReleaseSync");
    CLASS_END("IDXGIKeyedMutex");
    CLASS_BEGIN("IDXGISurface");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("DXGI_SURFACE_DESC *", "DXGI_SURFACE_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_SURFACE_DESC *), sizeof(DXGI_SURFACE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("HRESULT", "Map");
    PARAM("DXGI_MAPPED_RECT *", "DXGI_MAPPED_RECT", "pLockedRect", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_MAPPED_RECT *), sizeof(DXGI_MAPPED_RECT), "NOT_SET");
    PARAM("UINT", "UINT", "MapFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "Map");
    METHOD_BEGIN("HRESULT", "Unmap");
    METHOD_END("HRESULT", "Unmap");
    CLASS_END("IDXGISurface");
    CLASS_BEGIN("IDXGISurface1");
    METHOD_BEGIN("HRESULT", "GetDC");
    PARAM("BOOL", "BOOL", "Discard", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("HDC *", "HDC", "phdc", ParamAnnot::_OUT_, 1, false, sizeof(HDC *), sizeof(HDC), "NOT_SET");
    METHOD_END("HRESULT", "GetDC");
    METHOD_BEGIN("HRESULT", "ReleaseDC");
    PARAM("RECT *", "RECT", "pDirtyRect", ParamAnnot::_IN_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("HRESULT", "ReleaseDC");
    CLASS_END("IDXGISurface1");
    CLASS_BEGIN("IDXGIAdapter");
    METHOD_BEGIN("HRESULT", "EnumOutputs");
    PARAM("UINT", "UINT", "Output", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIOutput **", "IDXGIOutput", "ppOutput", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIOutput **), sizeof(IDXGIOutput), "NOT_SET");
    METHOD_END("HRESULT", "EnumOutputs");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("DXGI_ADAPTER_DESC *", "DXGI_ADAPTER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_ADAPTER_DESC *), sizeof(DXGI_ADAPTER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("HRESULT", "CheckInterfaceSupport");
    PARAM("const GUID &", "GUID", "InterfaceName", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("LARGE_INTEGER *", "LARGE_INTEGER", "pUMDVersion", ParamAnnot::_OUT_, 1, false, sizeof(LARGE_INTEGER *), sizeof(LARGE_INTEGER), "NOT_SET");
    METHOD_END("HRESULT", "CheckInterfaceSupport");
    CLASS_END("IDXGIAdapter");
    CLASS_BEGIN("IDXGIOutput");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("DXGI_OUTPUT_DESC *", "DXGI_OUTPUT_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_OUTPUT_DESC *), sizeof(DXGI_OUTPUT_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("HRESULT", "GetDisplayModeList");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "EnumFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pNumModes", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_MODE_DESC *", "DXGI_MODE_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(DXGI_MODE_DESC *), sizeof(DXGI_MODE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDisplayModeList");
    METHOD_BEGIN("HRESULT", "FindClosestMatchingMode");
    PARAM("const DXGI_MODE_DESC *", "DXGI_MODE_DESC", "pModeToMatch", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_MODE_DESC *), sizeof(DXGI_MODE_DESC), "NOT_SET");
    PARAM("DXGI_MODE_DESC *", "DXGI_MODE_DESC", "pClosestMatch", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_MODE_DESC *), sizeof(DXGI_MODE_DESC), "NOT_SET");
    PARAM("struct IUnknown *", "IUnknown", "pConcernedDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    METHOD_END("HRESULT", "FindClosestMatchingMode");
    METHOD_BEGIN("HRESULT", "WaitForVBlank");
    METHOD_END("HRESULT", "WaitForVBlank");
    METHOD_BEGIN("HRESULT", "TakeOwnership");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("BOOL", "BOOL", "Exclusive", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "TakeOwnership");
    METHOD_BEGIN("void", "ReleaseOwnership");
    METHOD_END("void", "ReleaseOwnership");
    METHOD_BEGIN("HRESULT", "GetGammaControlCapabilities");
    PARAM("DXGI_GAMMA_CONTROL_CAPABILITIES *", "DXGI_GAMMA_CONTROL_CAPABILITIES", "pGammaCaps", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_GAMMA_CONTROL_CAPABILITIES *), sizeof(DXGI_GAMMA_CONTROL_CAPABILITIES), "NOT_SET");
    METHOD_END("HRESULT", "GetGammaControlCapabilities");
    METHOD_BEGIN("HRESULT", "SetGammaControl");
    PARAM("const DXGI_GAMMA_CONTROL *", "DXGI_GAMMA_CONTROL", "pArray", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_GAMMA_CONTROL *), sizeof(DXGI_GAMMA_CONTROL), "NOT_SET");
    METHOD_END("HRESULT", "SetGammaControl");
    METHOD_BEGIN("HRESULT", "GetGammaControl");
    PARAM("DXGI_GAMMA_CONTROL *", "DXGI_GAMMA_CONTROL", "pArray", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_GAMMA_CONTROL *), sizeof(DXGI_GAMMA_CONTROL), "NOT_SET");
    METHOD_END("HRESULT", "GetGammaControl");
    METHOD_BEGIN("HRESULT", "SetDisplaySurface");
    PARAM("IDXGISurface *", "IDXGISurface", "pScanoutSurface", ParamAnnot::_IN_, 1, true, sizeof(IDXGISurface *), sizeof(IDXGISurface), "NOT_SET");
    METHOD_END("HRESULT", "SetDisplaySurface");
    METHOD_BEGIN("HRESULT", "GetDisplaySurfaceData");
    PARAM("IDXGISurface *", "IDXGISurface", "pDestination", ParamAnnot::_IN_, 1, true, sizeof(IDXGISurface *), sizeof(IDXGISurface), "NOT_SET");
    METHOD_END("HRESULT", "GetDisplaySurfaceData");
    METHOD_BEGIN("HRESULT", "GetFrameStatistics");
    PARAM("DXGI_FRAME_STATISTICS *", "DXGI_FRAME_STATISTICS", "pStats", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_FRAME_STATISTICS *), sizeof(DXGI_FRAME_STATISTICS), "NOT_SET");
    METHOD_END("HRESULT", "GetFrameStatistics");
    CLASS_END("IDXGIOutput");
    CLASS_BEGIN("IDXGISwapChain");
    METHOD_BEGIN("HRESULT", "Present");
    PARAM("UINT", "UINT", "SyncInterval", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "Present");
    METHOD_BEGIN("HRESULT", "GetBuffer");
    PARAM("UINT", "UINT", "Buffer", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppSurface", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "GetBuffer");
    METHOD_BEGIN("HRESULT", "SetFullscreenState");
    PARAM("BOOL", "BOOL", "Fullscreen", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("IDXGIOutput *", "IDXGIOutput", "pTarget", ParamAnnot::_IN_, 1, true, sizeof(IDXGIOutput *), sizeof(IDXGIOutput), "NOT_SET");
    METHOD_END("HRESULT", "SetFullscreenState");
    METHOD_BEGIN("HRESULT", "GetFullscreenState");
    PARAM("BOOL *", "BOOL", "pFullscreen", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("IDXGIOutput **", "IDXGIOutput", "ppTarget", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIOutput **), sizeof(IDXGIOutput), "NOT_SET");
    METHOD_END("HRESULT", "GetFullscreenState");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("DXGI_SWAP_CHAIN_DESC *", "DXGI_SWAP_CHAIN_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_SWAP_CHAIN_DESC *), sizeof(DXGI_SWAP_CHAIN_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("HRESULT", "ResizeBuffers");
    PARAM("UINT", "UINT", "BufferCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Width", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Height", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "NewFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "SwapChainFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "ResizeBuffers");
    METHOD_BEGIN("HRESULT", "ResizeTarget");
    PARAM("const DXGI_MODE_DESC *", "DXGI_MODE_DESC", "pNewTargetParameters", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_MODE_DESC *), sizeof(DXGI_MODE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "ResizeTarget");
    METHOD_BEGIN("HRESULT", "GetContainingOutput");
    PARAM("IDXGIOutput **", "IDXGIOutput", "ppOutput", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIOutput **), sizeof(IDXGIOutput), "NOT_SET");
    METHOD_END("HRESULT", "GetContainingOutput");
    METHOD_BEGIN("HRESULT", "GetFrameStatistics");
    PARAM("DXGI_FRAME_STATISTICS *", "DXGI_FRAME_STATISTICS", "pStats", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_FRAME_STATISTICS *), sizeof(DXGI_FRAME_STATISTICS), "NOT_SET");
    METHOD_END("HRESULT", "GetFrameStatistics");
    METHOD_BEGIN("HRESULT", "GetLastPresentCount");
    PARAM("UINT *", "UINT", "pLastPresentCount", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetLastPresentCount");
    CLASS_END("IDXGISwapChain");
    CLASS_BEGIN("IDXGIFactory");
    METHOD_BEGIN("HRESULT", "EnumAdapters");
    PARAM("UINT", "UINT", "Adapter", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIAdapter **", "IDXGIAdapter", "ppAdapter", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIAdapter **), sizeof(IDXGIAdapter), "NOT_SET");
    METHOD_END("HRESULT", "EnumAdapters");
    METHOD_BEGIN("HRESULT", "MakeWindowAssociation");
    PARAM("HWND", "HWND", "WindowHandle", ParamAnnot::_IN_, 0, false, sizeof(HWND), sizeof(HWND), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "MakeWindowAssociation");
    METHOD_BEGIN("HRESULT", "GetWindowAssociation");
    PARAM("HWND *", "HWND", "pWindowHandle", ParamAnnot::_OUT_, 1, false, sizeof(HWND *), sizeof(HWND), "NOT_SET");
    METHOD_END("HRESULT", "GetWindowAssociation");
    METHOD_BEGIN("HRESULT", "CreateSwapChain");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("DXGI_SWAP_CHAIN_DESC *", "DXGI_SWAP_CHAIN_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(DXGI_SWAP_CHAIN_DESC *), sizeof(DXGI_SWAP_CHAIN_DESC), "NOT_SET");
    PARAM("IDXGISwapChain **", "IDXGISwapChain", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain **), sizeof(IDXGISwapChain), "NOT_SET");
    METHOD_END("HRESULT", "CreateSwapChain");
    METHOD_BEGIN("HRESULT", "CreateSoftwareAdapter");
    PARAM("HMODULE", "HMODULE", "Module", ParamAnnot::_IN_, 0, false, sizeof(HMODULE), sizeof(HMODULE), "NOT_SET");
    PARAM("IDXGIAdapter **", "IDXGIAdapter", "ppAdapter", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIAdapter **), sizeof(IDXGIAdapter), "NOT_SET");
    METHOD_END("HRESULT", "CreateSoftwareAdapter");
    CLASS_END("IDXGIFactory");
    CLASS_BEGIN("IDXGIDevice");
    METHOD_BEGIN("HRESULT", "GetAdapter");
    PARAM("IDXGIAdapter **", "IDXGIAdapter", "pAdapter", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIAdapter **), sizeof(IDXGIAdapter), "NOT_SET");
    METHOD_END("HRESULT", "GetAdapter");
    METHOD_BEGIN("HRESULT", "CreateSurface");
    PARAM("const DXGI_SURFACE_DESC *", "DXGI_SURFACE_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SURFACE_DESC *), sizeof(DXGI_SURFACE_DESC), "NOT_SET");
    PARAM("UINT", "UINT", "NumSurfaces", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_USAGE", "DXGI_USAGE", "Usage", ParamAnnot::_IN_, 0, false, sizeof(DXGI_USAGE), sizeof(DXGI_USAGE), "NOT_SET");
    PARAM("const DXGI_SHARED_RESOURCE *", "DXGI_SHARED_RESOURCE", "pSharedResource", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SHARED_RESOURCE *), sizeof(DXGI_SHARED_RESOURCE), "NOT_SET");
    PARAM("IDXGISurface **", "IDXGISurface", "ppSurface", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISurface **), sizeof(IDXGISurface), "NOT_SET");
    METHOD_END("HRESULT", "CreateSurface");
    METHOD_BEGIN("HRESULT", "QueryResourceResidency");
    PARAM("struct IUnknown *const *", "IUnknown", "ppResources", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(struct IUnknown *const *), sizeof(IUnknown), "NumResources");
    PARAM("DXGI_RESIDENCY *", "DXGI_RESIDENCY", "pResidencyStatus", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(DXGI_RESIDENCY *), sizeof(DXGI_RESIDENCY), "NumResources");
    PARAM("UINT", "UINT", "NumResources", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "QueryResourceResidency");
    METHOD_BEGIN("HRESULT", "SetGPUThreadPriority");
    PARAM("INT", "INT", "Priority", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("HRESULT", "SetGPUThreadPriority");
    METHOD_BEGIN("HRESULT", "GetGPUThreadPriority");
    PARAM("INT *", "INT", "pPriority", ParamAnnot::_OUT_, 1, false, sizeof(INT *), sizeof(INT), "NOT_SET");
    METHOD_END("HRESULT", "GetGPUThreadPriority");
    CLASS_END("IDXGIDevice");
    CLASS_BEGIN("IDXGIFactory1");
    METHOD_BEGIN("HRESULT", "EnumAdapters1");
    PARAM("UINT", "UINT", "Adapter", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIAdapter1 **", "IDXGIAdapter1", "ppAdapter", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIAdapter1 **), sizeof(IDXGIAdapter1), "NOT_SET");
    METHOD_END("HRESULT", "EnumAdapters1");
    METHOD_BEGIN("BOOL", "IsCurrent");
    METHOD_END("BOOL", "IsCurrent");
    CLASS_END("IDXGIFactory1");
    CLASS_BEGIN("IDXGIAdapter1");
    METHOD_BEGIN("HRESULT", "GetDesc1");
    PARAM("DXGI_ADAPTER_DESC1 *", "DXGI_ADAPTER_DESC1", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_ADAPTER_DESC1 *), sizeof(DXGI_ADAPTER_DESC1), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc1");
    CLASS_END("IDXGIAdapter1");
    CLASS_BEGIN("IDXGIDevice1");
    METHOD_BEGIN("HRESULT", "SetMaximumFrameLatency");
    PARAM("UINT", "UINT", "MaxLatency", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetMaximumFrameLatency");
    METHOD_BEGIN("HRESULT", "GetMaximumFrameLatency");
    PARAM("UINT *", "UINT", "pMaxLatency", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetMaximumFrameLatency");
    CLASS_END("IDXGIDevice1");
    CLASS_BEGIN("ID3D10Blob");
    METHOD_BEGIN("LPVOID", "GetBufferPointer");
    METHOD_END("LPVOID", "GetBufferPointer");
    METHOD_BEGIN("SIZE_T", "GetBufferSize");
    METHOD_END("SIZE_T", "GetBufferSize");
    CLASS_END("ID3D10Blob");
    CLASS_BEGIN("ID3DDestructionNotifier");
    METHOD_BEGIN("HRESULT", "RegisterDestructionCallback");
    PARAM("PFN_DESTRUCTION_CALLBACK", "PFN_DESTRUCTION_CALLBACK", "callbackFn", ParamAnnot::_IN_, 0, false, sizeof(PFN_DESTRUCTION_CALLBACK), sizeof(PFN_DESTRUCTION_CALLBACK), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_IN_, 1, false, sizeof(void *), 0, "NOT_SET");
    PARAM("UINT *", "UINT", "pCallbackID", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "RegisterDestructionCallback");
    METHOD_BEGIN("HRESULT", "UnregisterDestructionCallback");
    PARAM("UINT", "UINT", "callbackID", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "UnregisterDestructionCallback");
    CLASS_END("ID3DDestructionNotifier");
    CLASS_BEGIN("ID3DInclude");
    METHOD_BEGIN("HRESULT", "Open");
    PARAM("D3D_INCLUDE_TYPE", "D3D_INCLUDE_TYPE", "IncludeType", ParamAnnot::_IN_, 0, false, sizeof(D3D_INCLUDE_TYPE), sizeof(D3D_INCLUDE_TYPE), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pFileName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("LPCVOID", "LPCVOID", "pParentData", ParamAnnot::_IN_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "NOT_SET");
    PARAM("LPCVOID *", "LPCVOID", "ppData", ParamAnnot::_IN_, 1, false, sizeof(LPCVOID *), sizeof(LPCVOID), "NOT_SET");
    PARAM("UINT *", "UINT", "pBytes", ParamAnnot::_IN_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "Open");
    METHOD_BEGIN("HRESULT", "Close");
    PARAM("LPCVOID", "LPCVOID", "pData", ParamAnnot::_IN_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "NOT_SET");
    METHOD_END("HRESULT", "Close");
    CLASS_END("ID3DInclude");
    CLASS_BEGIN("ID3D11DeviceChild");
    METHOD_BEGIN("void", "GetDevice");
    PARAM("ID3D11Device **", "ID3D11Device", "ppDevice", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Device **), sizeof(ID3D11Device), "NOT_SET");
    METHOD_END("void", "GetDevice");
    METHOD_BEGIN("HRESULT", "GetPrivateData");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT *", "UINT", "pDataSize", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "pDataSize");
    METHOD_END("HRESULT", "GetPrivateData");
    METHOD_BEGIN("HRESULT", "SetPrivateData");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "DataSize");
    METHOD_END("HRESULT", "SetPrivateData");
    METHOD_BEGIN("HRESULT", "SetPrivateDataInterface");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("const struct IUnknown *", "IUnknown", "pData", ParamAnnot::_IN_, 1, true, sizeof(const struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    METHOD_END("HRESULT", "SetPrivateDataInterface");
    CLASS_END("ID3D11DeviceChild");
    CLASS_BEGIN("ID3D11DepthStencilState");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_DEPTH_STENCIL_DESC *", "D3D11_DEPTH_STENCIL_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_DEPTH_STENCIL_DESC *), sizeof(D3D11_DEPTH_STENCIL_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11DepthStencilState");
    CLASS_BEGIN("ID3D11BlendState");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_BLEND_DESC *", "D3D11_BLEND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_BLEND_DESC *), sizeof(D3D11_BLEND_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11BlendState");
    CLASS_BEGIN("ID3D11RasterizerState");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_RASTERIZER_DESC *", "D3D11_RASTERIZER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_RASTERIZER_DESC *), sizeof(D3D11_RASTERIZER_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11RasterizerState");
    CLASS_BEGIN("ID3D11Resource");
    METHOD_BEGIN("void", "GetType");
    PARAM("D3D11_RESOURCE_DIMENSION *", "D3D11_RESOURCE_DIMENSION", "pResourceDimension", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_RESOURCE_DIMENSION *), sizeof(D3D11_RESOURCE_DIMENSION), "NOT_SET");
    METHOD_END("void", "GetType");
    METHOD_BEGIN("void", "SetEvictionPriority");
    PARAM("UINT", "UINT", "EvictionPriority", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "SetEvictionPriority");
    METHOD_BEGIN("UINT", "GetEvictionPriority");
    METHOD_END("UINT", "GetEvictionPriority");
    CLASS_END("ID3D11Resource");
    CLASS_BEGIN("ID3D11Buffer");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_BUFFER_DESC *", "D3D11_BUFFER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_BUFFER_DESC *), sizeof(D3D11_BUFFER_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11Buffer");
    CLASS_BEGIN("ID3D11Texture1D");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_TEXTURE1D_DESC *", "D3D11_TEXTURE1D_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_TEXTURE1D_DESC *), sizeof(D3D11_TEXTURE1D_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11Texture1D");
    CLASS_BEGIN("ID3D11Texture2D");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_TEXTURE2D_DESC *", "D3D11_TEXTURE2D_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_TEXTURE2D_DESC *), sizeof(D3D11_TEXTURE2D_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11Texture2D");
    CLASS_BEGIN("ID3D11Texture3D");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_TEXTURE3D_DESC *", "D3D11_TEXTURE3D_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_TEXTURE3D_DESC *), sizeof(D3D11_TEXTURE3D_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11Texture3D");
    CLASS_BEGIN("ID3D11View");
    METHOD_BEGIN("void", "GetResource");
    PARAM("ID3D11Resource **", "ID3D11Resource", "ppResource", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Resource **), sizeof(ID3D11Resource), "NOT_SET");
    METHOD_END("void", "GetResource");
    CLASS_END("ID3D11View");
    CLASS_BEGIN("ID3D11ShaderResourceView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_SHADER_RESOURCE_VIEW_DESC *", "D3D11_SHADER_RESOURCE_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC *), sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11ShaderResourceView");
    CLASS_BEGIN("ID3D11RenderTargetView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_RENDER_TARGET_VIEW_DESC *", "D3D11_RENDER_TARGET_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_RENDER_TARGET_VIEW_DESC *), sizeof(D3D11_RENDER_TARGET_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11RenderTargetView");
    CLASS_BEGIN("ID3D11DepthStencilView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_DEPTH_STENCIL_VIEW_DESC *", "D3D11_DEPTH_STENCIL_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC *), sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11DepthStencilView");
    CLASS_BEGIN("ID3D11UnorderedAccessView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_UNORDERED_ACCESS_VIEW_DESC *", "D3D11_UNORDERED_ACCESS_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC *), sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11UnorderedAccessView");
    CLASS_BEGIN("ID3D11VertexShader");
    CLASS_END("ID3D11VertexShader");
    CLASS_BEGIN("ID3D11HullShader");
    CLASS_END("ID3D11HullShader");
    CLASS_BEGIN("ID3D11DomainShader");
    CLASS_END("ID3D11DomainShader");
    CLASS_BEGIN("ID3D11GeometryShader");
    CLASS_END("ID3D11GeometryShader");
    CLASS_BEGIN("ID3D11PixelShader");
    CLASS_END("ID3D11PixelShader");
    CLASS_BEGIN("ID3D11ComputeShader");
    CLASS_END("ID3D11ComputeShader");
    CLASS_BEGIN("ID3D11InputLayout");
    CLASS_END("ID3D11InputLayout");
    CLASS_BEGIN("ID3D11SamplerState");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_SAMPLER_DESC *", "D3D11_SAMPLER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SAMPLER_DESC *), sizeof(D3D11_SAMPLER_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11SamplerState");
    CLASS_BEGIN("ID3D11Asynchronous");
    METHOD_BEGIN("UINT", "GetDataSize");
    METHOD_END("UINT", "GetDataSize");
    CLASS_END("ID3D11Asynchronous");
    CLASS_BEGIN("ID3D11Query");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_QUERY_DESC *", "D3D11_QUERY_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_QUERY_DESC *), sizeof(D3D11_QUERY_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11Query");
    CLASS_BEGIN("ID3D11Predicate");
    CLASS_END("ID3D11Predicate");
    CLASS_BEGIN("ID3D11Counter");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_COUNTER_DESC *", "D3D11_COUNTER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_COUNTER_DESC *), sizeof(D3D11_COUNTER_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11Counter");
    CLASS_BEGIN("ID3D11ClassInstance");
    METHOD_BEGIN("void", "GetClassLinkage");
    PARAM("ID3D11ClassLinkage **", "ID3D11ClassLinkage", "ppLinkage", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ClassLinkage **), sizeof(ID3D11ClassLinkage), "NOT_SET");
    METHOD_END("void", "GetClassLinkage");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_CLASS_INSTANCE_DESC *", "D3D11_CLASS_INSTANCE_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_CLASS_INSTANCE_DESC *), sizeof(D3D11_CLASS_INSTANCE_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    METHOD_BEGIN("void", "GetInstanceName");
    PARAM("LPSTR", "LPSTR", "pInstanceName", ParamAnnot::_OUT_ARRAY_, 0, false, sizeof(LPSTR), sizeof(LPSTR), "pBufferLength");
    PARAM("SIZE_T *", "SIZE_T", "pBufferLength", ParamAnnot::_INOUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    METHOD_END("void", "GetInstanceName");
    METHOD_BEGIN("void", "GetTypeName");
    PARAM("LPSTR", "LPSTR", "pTypeName", ParamAnnot::_OUT_ARRAY_, 0, false, sizeof(LPSTR), sizeof(LPSTR), "pBufferLength");
    PARAM("SIZE_T *", "SIZE_T", "pBufferLength", ParamAnnot::_INOUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    METHOD_END("void", "GetTypeName");
    CLASS_END("ID3D11ClassInstance");
    CLASS_BEGIN("ID3D11ClassLinkage");
    METHOD_BEGIN("HRESULT", "GetClassInstance");
    PARAM("LPCSTR", "LPCSTR", "pClassInstanceName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "InstanceIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppInstance", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "NOT_SET");
    METHOD_END("HRESULT", "GetClassInstance");
    METHOD_BEGIN("HRESULT", "CreateClassInstance");
    PARAM("LPCSTR", "LPCSTR", "pClassTypeName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "ConstantBufferOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "ConstantVectorOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "TextureOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SamplerOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppInstance", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "NOT_SET");
    METHOD_END("HRESULT", "CreateClassInstance");
    CLASS_END("ID3D11ClassLinkage");
    CLASS_BEGIN("ID3D11CommandList");
    METHOD_BEGIN("UINT", "GetContextFlags");
    METHOD_END("UINT", "GetContextFlags");
    CLASS_END("ID3D11CommandList");
    CLASS_BEGIN("ID3D11DeviceContext");
    METHOD_BEGIN("void", "VSSetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "VSSetConstantBuffers");
    METHOD_BEGIN("void", "PSSetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView *const *", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView *const *), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "PSSetShaderResources");
    METHOD_BEGIN("void", "PSSetShader");
    PARAM("ID3D11PixelShader *", "ID3D11PixelShader", "pPixelShader", ParamAnnot::_IN_, 1, true, sizeof(ID3D11PixelShader *), sizeof(ID3D11PixelShader), "NOT_SET");
    PARAM("ID3D11ClassInstance *const *", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ClassInstance *const *), sizeof(ID3D11ClassInstance), "NumClassInstances");
    PARAM("UINT", "UINT", "NumClassInstances", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "PSSetShader");
    METHOD_BEGIN("void", "PSSetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState *const *", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11SamplerState *const *), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "PSSetSamplers");
    METHOD_BEGIN("void", "VSSetShader");
    PARAM("ID3D11VertexShader *", "ID3D11VertexShader", "pVertexShader", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VertexShader *), sizeof(ID3D11VertexShader), "NOT_SET");
    PARAM("ID3D11ClassInstance *const *", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ClassInstance *const *), sizeof(ID3D11ClassInstance), "NumClassInstances");
    PARAM("UINT", "UINT", "NumClassInstances", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "VSSetShader");
    METHOD_BEGIN("void", "DrawIndexed");
    PARAM("UINT", "UINT", "IndexCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "StartIndexLocation", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("INT", "INT", "BaseVertexLocation", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("void", "DrawIndexed");
    METHOD_BEGIN("void", "Draw");
    PARAM("UINT", "UINT", "VertexCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "StartVertexLocation", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "Draw");
    METHOD_BEGIN("HRESULT", "Map");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "Subresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_MAP", "D3D11_MAP", "MapType", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MAP), sizeof(D3D11_MAP), "NOT_SET");
    PARAM("UINT", "UINT", "MapFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_MAPPED_SUBRESOURCE *", "D3D11_MAPPED_SUBRESOURCE", "pMappedResource", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_MAPPED_SUBRESOURCE *), sizeof(D3D11_MAPPED_SUBRESOURCE), "NOT_SET");
    METHOD_END("HRESULT", "Map");
    METHOD_BEGIN("void", "Unmap");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "Subresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "Unmap");
    METHOD_BEGIN("void", "PSSetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "PSSetConstantBuffers");
    METHOD_BEGIN("void", "IASetInputLayout");
    PARAM("ID3D11InputLayout *", "ID3D11InputLayout", "pInputLayout", ParamAnnot::_IN_, 1, true, sizeof(ID3D11InputLayout *), sizeof(ID3D11InputLayout), "NOT_SET");
    METHOD_END("void", "IASetInputLayout");
    METHOD_BEGIN("void", "IASetVertexBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppVertexBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pStrides", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pOffsets", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "IASetVertexBuffers");
    METHOD_BEGIN("void", "IASetIndexBuffer");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pIndexBuffer", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "Offset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "IASetIndexBuffer");
    METHOD_BEGIN("void", "DrawIndexedInstanced");
    PARAM("UINT", "UINT", "IndexCountPerInstance", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "InstanceCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "StartIndexLocation", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("INT", "INT", "BaseVertexLocation", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    PARAM("UINT", "UINT", "StartInstanceLocation", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DrawIndexedInstanced");
    METHOD_BEGIN("void", "DrawInstanced");
    PARAM("UINT", "UINT", "VertexCountPerInstance", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "InstanceCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "StartVertexLocation", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "StartInstanceLocation", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DrawInstanced");
    METHOD_BEGIN("void", "GSSetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "GSSetConstantBuffers");
    METHOD_BEGIN("void", "GSSetShader");
    PARAM("ID3D11GeometryShader *", "ID3D11GeometryShader", "pShader", ParamAnnot::_IN_, 1, true, sizeof(ID3D11GeometryShader *), sizeof(ID3D11GeometryShader), "NOT_SET");
    PARAM("ID3D11ClassInstance *const *", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ClassInstance *const *), sizeof(ID3D11ClassInstance), "NumClassInstances");
    PARAM("UINT", "UINT", "NumClassInstances", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "GSSetShader");
    METHOD_BEGIN("void", "IASetPrimitiveTopology");
    PARAM("D3D11_PRIMITIVE_TOPOLOGY", "D3D11_PRIMITIVE_TOPOLOGY", "Topology", ParamAnnot::_IN_, 0, false, sizeof(D3D11_PRIMITIVE_TOPOLOGY), sizeof(D3D11_PRIMITIVE_TOPOLOGY), "NOT_SET");
    METHOD_END("void", "IASetPrimitiveTopology");
    METHOD_BEGIN("void", "VSSetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView *const *", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView *const *), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "VSSetShaderResources");
    METHOD_BEGIN("void", "VSSetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState *const *", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11SamplerState *const *), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "VSSetSamplers");
    METHOD_BEGIN("void", "Begin");
    PARAM("ID3D11Asynchronous *", "ID3D11Asynchronous", "pAsync", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Asynchronous *), sizeof(ID3D11Asynchronous), "NOT_SET");
    METHOD_END("void", "Begin");
    METHOD_BEGIN("void", "End");
    PARAM("ID3D11Asynchronous *", "ID3D11Asynchronous", "pAsync", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Asynchronous *), sizeof(ID3D11Asynchronous), "NOT_SET");
    METHOD_END("void", "End");
    METHOD_BEGIN("HRESULT", "GetData");
    PARAM("ID3D11Asynchronous *", "ID3D11Asynchronous", "pAsync", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Asynchronous *), sizeof(ID3D11Asynchronous), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "DataSize");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "GetDataFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetData");
    METHOD_BEGIN("void", "SetPredication");
    PARAM("ID3D11Predicate *", "ID3D11Predicate", "pPredicate", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Predicate *), sizeof(ID3D11Predicate), "NOT_SET");
    PARAM("BOOL", "BOOL", "PredicateValue", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "SetPredication");
    METHOD_BEGIN("void", "GSSetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView *const *", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView *const *), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "GSSetShaderResources");
    METHOD_BEGIN("void", "GSSetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState *const *", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11SamplerState *const *), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "GSSetSamplers");
    METHOD_BEGIN("void", "OMSetRenderTargets");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11RenderTargetView *const *", "ID3D11RenderTargetView", "ppRenderTargetViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11RenderTargetView *const *), sizeof(ID3D11RenderTargetView), "NumViews");
    PARAM("ID3D11DepthStencilView *", "ID3D11DepthStencilView", "pDepthStencilView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DepthStencilView *), sizeof(ID3D11DepthStencilView), "NOT_SET");
    METHOD_END("void", "OMSetRenderTargets");
    METHOD_BEGIN("void", "OMSetRenderTargetsAndUnorderedAccessViews");
    PARAM("UINT", "UINT", "NumRTVs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11RenderTargetView *const *", "ID3D11RenderTargetView", "ppRenderTargetViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11RenderTargetView *const *), sizeof(ID3D11RenderTargetView), "NumRTVs");
    PARAM("ID3D11DepthStencilView *", "ID3D11DepthStencilView", "pDepthStencilView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DepthStencilView *), sizeof(ID3D11DepthStencilView), "NOT_SET");
    PARAM("UINT", "UINT", "UAVStartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumUAVs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView *const *", "ID3D11UnorderedAccessView", "ppUnorderedAccessViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11UnorderedAccessView *const *), sizeof(ID3D11UnorderedAccessView), "NumUAVs");
    PARAM("const UINT *", "UINT", "pUAVInitialCounts", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumUAVs");
    METHOD_END("void", "OMSetRenderTargetsAndUnorderedAccessViews");
    METHOD_BEGIN("void", "OMSetBlendState");
    PARAM("ID3D11BlendState *", "ID3D11BlendState", "pBlendState", ParamAnnot::_IN_, 1, true, sizeof(ID3D11BlendState *), sizeof(ID3D11BlendState), "NOT_SET");
    PARAM("const FLOAT *", "FLOAT", "BlendFactor", ParamAnnot::_IN_, 1, false, sizeof(const FLOAT *), sizeof(FLOAT), "NOT_SET");
    PARAM("UINT", "UINT", "SampleMask", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "OMSetBlendState");
    METHOD_BEGIN("void", "OMSetDepthStencilState");
    PARAM("ID3D11DepthStencilState *", "ID3D11DepthStencilState", "pDepthStencilState", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DepthStencilState *), sizeof(ID3D11DepthStencilState), "NOT_SET");
    PARAM("UINT", "UINT", "StencilRef", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "OMSetDepthStencilState");
    METHOD_BEGIN("void", "SOSetTargets");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppSOTargets", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pOffsets", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "SOSetTargets");
    METHOD_BEGIN("void", "DrawAuto");
    METHOD_END("void", "DrawAuto");
    METHOD_BEGIN("void", "DrawIndexedInstancedIndirect");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pBufferForArgs", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT", "UINT", "AlignedByteOffsetForArgs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DrawIndexedInstancedIndirect");
    METHOD_BEGIN("void", "DrawInstancedIndirect");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pBufferForArgs", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT", "UINT", "AlignedByteOffsetForArgs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DrawInstancedIndirect");
    METHOD_BEGIN("void", "Dispatch");
    PARAM("UINT", "UINT", "ThreadGroupCountX", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "ThreadGroupCountY", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "ThreadGroupCountZ", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "Dispatch");
    METHOD_BEGIN("void", "DispatchIndirect");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pBufferForArgs", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT", "UINT", "AlignedByteOffsetForArgs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DispatchIndirect");
    METHOD_BEGIN("void", "RSSetState");
    PARAM("ID3D11RasterizerState *", "ID3D11RasterizerState", "pRasterizerState", ParamAnnot::_IN_, 1, true, sizeof(ID3D11RasterizerState *), sizeof(ID3D11RasterizerState), "NOT_SET");
    METHOD_END("void", "RSSetState");
    METHOD_BEGIN("void", "RSSetViewports");
    PARAM("UINT", "UINT", "NumViewports", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIEWPORT *", "D3D11_VIEWPORT", "pViewports", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_VIEWPORT *), sizeof(D3D11_VIEWPORT), "NumViewports");
    METHOD_END("void", "RSSetViewports");
    METHOD_BEGIN("void", "RSSetScissorRects");
    PARAM("UINT", "UINT", "NumRects", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_RECT *", "D3D11_RECT", "pRects", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_RECT *), sizeof(D3D11_RECT), "NumRects");
    METHOD_END("void", "RSSetScissorRects");
    METHOD_BEGIN("void", "CopySubresourceRegion");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "DstSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstX", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstY", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstZ", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pSrcResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "SrcSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_BOX *", "D3D11_BOX", "pSrcBox", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BOX *), sizeof(D3D11_BOX), "NOT_SET");
    METHOD_END("void", "CopySubresourceRegion");
    METHOD_BEGIN("void", "CopyResource");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pSrcResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    METHOD_END("void", "CopyResource");
    METHOD_BEGIN("void", "UpdateSubresource");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "DstSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_BOX *", "D3D11_BOX", "pDstBox", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BOX *), sizeof(D3D11_BOX), "NOT_SET");
    PARAM("const void *", "void", "pSrcData", ParamAnnot::_IN_, 1, false, sizeof(const void *), 0, "NOT_SET");
    PARAM("UINT", "UINT", "SrcRowPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SrcDepthPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "UpdateSubresource");
    METHOD_BEGIN("void", "CopyStructureCount");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pDstBuffer", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT", "UINT", "DstAlignedByteOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView *", "ID3D11UnorderedAccessView", "pSrcView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11UnorderedAccessView *), sizeof(ID3D11UnorderedAccessView), "NOT_SET");
    METHOD_END("void", "CopyStructureCount");
    METHOD_BEGIN("void", "ClearRenderTargetView");
    PARAM("ID3D11RenderTargetView *", "ID3D11RenderTargetView", "pRenderTargetView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11RenderTargetView *), sizeof(ID3D11RenderTargetView), "NOT_SET");
    PARAM("const FLOAT *", "FLOAT", "ColorRGBA", ParamAnnot::_IN_, 1, false, sizeof(const FLOAT *), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "ClearRenderTargetView");
    METHOD_BEGIN("void", "ClearUnorderedAccessViewUint");
    PARAM("ID3D11UnorderedAccessView *", "ID3D11UnorderedAccessView", "pUnorderedAccessView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11UnorderedAccessView *), sizeof(ID3D11UnorderedAccessView), "NOT_SET");
    PARAM("const UINT *", "UINT", "Values", ParamAnnot::_IN_, 1, false, sizeof(const UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "ClearUnorderedAccessViewUint");
    METHOD_BEGIN("void", "ClearUnorderedAccessViewFloat");
    PARAM("ID3D11UnorderedAccessView *", "ID3D11UnorderedAccessView", "pUnorderedAccessView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11UnorderedAccessView *), sizeof(ID3D11UnorderedAccessView), "NOT_SET");
    PARAM("const FLOAT *", "FLOAT", "Values", ParamAnnot::_IN_, 1, false, sizeof(const FLOAT *), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "ClearUnorderedAccessViewFloat");
    METHOD_BEGIN("void", "ClearDepthStencilView");
    PARAM("ID3D11DepthStencilView *", "ID3D11DepthStencilView", "pDepthStencilView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DepthStencilView *), sizeof(ID3D11DepthStencilView), "NOT_SET");
    PARAM("UINT", "UINT", "ClearFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("FLOAT", "FLOAT", "Depth", ParamAnnot::_IN_, 0, false, sizeof(FLOAT), sizeof(FLOAT), "NOT_SET");
    PARAM("UINT8", "UINT8", "Stencil", ParamAnnot::_IN_, 0, false, sizeof(UINT8), sizeof(UINT8), "NOT_SET");
    METHOD_END("void", "ClearDepthStencilView");
    METHOD_BEGIN("void", "GenerateMips");
    PARAM("ID3D11ShaderResourceView *", "ID3D11ShaderResourceView", "pShaderResourceView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ShaderResourceView *), sizeof(ID3D11ShaderResourceView), "NOT_SET");
    METHOD_END("void", "GenerateMips");
    METHOD_BEGIN("void", "SetResourceMinLOD");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("FLOAT", "FLOAT", "MinLOD", ParamAnnot::_IN_, 0, false, sizeof(FLOAT), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "SetResourceMinLOD");
    METHOD_BEGIN("FLOAT", "GetResourceMinLOD");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    METHOD_END("FLOAT", "GetResourceMinLOD");
    METHOD_BEGIN("void", "ResolveSubresource");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "DstSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pSrcResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "SrcSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    METHOD_END("void", "ResolveSubresource");
    METHOD_BEGIN("void", "ExecuteCommandList");
    PARAM("ID3D11CommandList *", "ID3D11CommandList", "pCommandList", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CommandList *), sizeof(ID3D11CommandList), "NOT_SET");
    PARAM("BOOL", "BOOL", "RestoreContextState", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "ExecuteCommandList");
    METHOD_BEGIN("void", "HSSetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView *const *", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView *const *), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "HSSetShaderResources");
    METHOD_BEGIN("void", "HSSetShader");
    PARAM("ID3D11HullShader *", "ID3D11HullShader", "pHullShader", ParamAnnot::_IN_, 1, true, sizeof(ID3D11HullShader *), sizeof(ID3D11HullShader), "NOT_SET");
    PARAM("ID3D11ClassInstance *const *", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ClassInstance *const *), sizeof(ID3D11ClassInstance), "NumClassInstances");
    PARAM("UINT", "UINT", "NumClassInstances", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "HSSetShader");
    METHOD_BEGIN("void", "HSSetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState *const *", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11SamplerState *const *), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "HSSetSamplers");
    METHOD_BEGIN("void", "HSSetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "HSSetConstantBuffers");
    METHOD_BEGIN("void", "DSSetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView *const *", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView *const *), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "DSSetShaderResources");
    METHOD_BEGIN("void", "DSSetShader");
    PARAM("ID3D11DomainShader *", "ID3D11DomainShader", "pDomainShader", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DomainShader *), sizeof(ID3D11DomainShader), "NOT_SET");
    PARAM("ID3D11ClassInstance *const *", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ClassInstance *const *), sizeof(ID3D11ClassInstance), "NumClassInstances");
    PARAM("UINT", "UINT", "NumClassInstances", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DSSetShader");
    METHOD_BEGIN("void", "DSSetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState *const *", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11SamplerState *const *), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "DSSetSamplers");
    METHOD_BEGIN("void", "DSSetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "DSSetConstantBuffers");
    METHOD_BEGIN("void", "CSSetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView *const *", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView *const *), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "CSSetShaderResources");
    METHOD_BEGIN("void", "CSSetUnorderedAccessViews");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumUAVs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView *const *", "ID3D11UnorderedAccessView", "ppUnorderedAccessViews", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11UnorderedAccessView *const *), sizeof(ID3D11UnorderedAccessView), "NumUAVs");
    PARAM("const UINT *", "UINT", "pUAVInitialCounts", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumUAVs");
    METHOD_END("void", "CSSetUnorderedAccessViews");
    METHOD_BEGIN("void", "CSSetShader");
    PARAM("ID3D11ComputeShader *", "ID3D11ComputeShader", "pComputeShader", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ComputeShader *), sizeof(ID3D11ComputeShader), "NOT_SET");
    PARAM("ID3D11ClassInstance *const *", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11ClassInstance *const *), sizeof(ID3D11ClassInstance), "NumClassInstances");
    PARAM("UINT", "UINT", "NumClassInstances", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "CSSetShader");
    METHOD_BEGIN("void", "CSSetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState *const *", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11SamplerState *const *), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "CSSetSamplers");
    METHOD_BEGIN("void", "CSSetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "CSSetConstantBuffers");
    METHOD_BEGIN("void", "VSGetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "VSGetConstantBuffers");
    METHOD_BEGIN("void", "PSGetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "PSGetShaderResources");
    METHOD_BEGIN("void", "PSGetShader");
    PARAM("ID3D11PixelShader **", "ID3D11PixelShader", "ppPixelShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11PixelShader **), sizeof(ID3D11PixelShader), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "pNumClassInstances");
    PARAM("UINT *", "UINT", "pNumClassInstances", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "PSGetShader");
    METHOD_BEGIN("void", "PSGetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "PSGetSamplers");
    METHOD_BEGIN("void", "VSGetShader");
    PARAM("ID3D11VertexShader **", "ID3D11VertexShader", "ppVertexShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VertexShader **), sizeof(ID3D11VertexShader), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "pNumClassInstances");
    PARAM("UINT *", "UINT", "pNumClassInstances", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "VSGetShader");
    METHOD_BEGIN("void", "PSGetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "PSGetConstantBuffers");
    METHOD_BEGIN("void", "IAGetInputLayout");
    PARAM("ID3D11InputLayout **", "ID3D11InputLayout", "ppInputLayout", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11InputLayout **), sizeof(ID3D11InputLayout), "NOT_SET");
    METHOD_END("void", "IAGetInputLayout");
    METHOD_BEGIN("void", "IAGetVertexBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppVertexBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pStrides", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pOffsets", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "IAGetVertexBuffers");
    METHOD_BEGIN("void", "IAGetIndexBuffer");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "pIndexBuffer", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("DXGI_FORMAT *", "DXGI_FORMAT", "Format", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_FORMAT *), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT *", "UINT", "Offset", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "IAGetIndexBuffer");
    METHOD_BEGIN("void", "GSGetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "GSGetConstantBuffers");
    METHOD_BEGIN("void", "GSGetShader");
    PARAM("ID3D11GeometryShader **", "ID3D11GeometryShader", "ppGeometryShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11GeometryShader **), sizeof(ID3D11GeometryShader), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "pNumClassInstances");
    PARAM("UINT *", "UINT", "pNumClassInstances", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "GSGetShader");
    METHOD_BEGIN("void", "IAGetPrimitiveTopology");
    PARAM("D3D11_PRIMITIVE_TOPOLOGY *", "D3D11_PRIMITIVE_TOPOLOGY", "pTopology", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_PRIMITIVE_TOPOLOGY *), sizeof(D3D11_PRIMITIVE_TOPOLOGY), "NOT_SET");
    METHOD_END("void", "IAGetPrimitiveTopology");
    METHOD_BEGIN("void", "VSGetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "VSGetShaderResources");
    METHOD_BEGIN("void", "VSGetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "VSGetSamplers");
    METHOD_BEGIN("void", "GetPredication");
    PARAM("ID3D11Predicate **", "ID3D11Predicate", "ppPredicate", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Predicate **), sizeof(ID3D11Predicate), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pPredicateValue", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "GetPredication");
    METHOD_BEGIN("void", "GSGetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "GSGetShaderResources");
    METHOD_BEGIN("void", "GSGetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "GSGetSamplers");
    METHOD_BEGIN("void", "OMGetRenderTargets");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11RenderTargetView **", "ID3D11RenderTargetView", "ppRenderTargetViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11RenderTargetView **), sizeof(ID3D11RenderTargetView), "NumViews");
    PARAM("ID3D11DepthStencilView **", "ID3D11DepthStencilView", "ppDepthStencilView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DepthStencilView **), sizeof(ID3D11DepthStencilView), "NOT_SET");
    METHOD_END("void", "OMGetRenderTargets");
    METHOD_BEGIN("void", "OMGetRenderTargetsAndUnorderedAccessViews");
    PARAM("UINT", "UINT", "NumRTVs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11RenderTargetView **", "ID3D11RenderTargetView", "ppRenderTargetViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11RenderTargetView **), sizeof(ID3D11RenderTargetView), "NumRTVs");
    PARAM("ID3D11DepthStencilView **", "ID3D11DepthStencilView", "ppDepthStencilView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DepthStencilView **), sizeof(ID3D11DepthStencilView), "NOT_SET");
    PARAM("UINT", "UINT", "UAVStartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumUAVs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView **", "ID3D11UnorderedAccessView", "ppUnorderedAccessViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11UnorderedAccessView **), sizeof(ID3D11UnorderedAccessView), "NumUAVs");
    METHOD_END("void", "OMGetRenderTargetsAndUnorderedAccessViews");
    METHOD_BEGIN("void", "OMGetBlendState");
    PARAM("ID3D11BlendState **", "ID3D11BlendState", "ppBlendState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11BlendState **), sizeof(ID3D11BlendState), "NOT_SET");
    PARAM("FLOAT *", "FLOAT", "BlendFactor", ParamAnnot::_OUT_, 1, false, sizeof(FLOAT *), sizeof(FLOAT), "NOT_SET");
    PARAM("UINT *", "UINT", "pSampleMask", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "OMGetBlendState");
    METHOD_BEGIN("void", "OMGetDepthStencilState");
    PARAM("ID3D11DepthStencilState **", "ID3D11DepthStencilState", "ppDepthStencilState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DepthStencilState **), sizeof(ID3D11DepthStencilState), "NOT_SET");
    PARAM("UINT *", "UINT", "pStencilRef", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "OMGetDepthStencilState");
    METHOD_BEGIN("void", "SOGetTargets");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppSOTargets", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "SOGetTargets");
    METHOD_BEGIN("void", "RSGetState");
    PARAM("ID3D11RasterizerState **", "ID3D11RasterizerState", "ppRasterizerState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11RasterizerState **), sizeof(ID3D11RasterizerState), "NOT_SET");
    METHOD_END("void", "RSGetState");
    METHOD_BEGIN("void", "RSGetViewports");
    PARAM("UINT *", "UINT", "pNumViewports", ParamAnnot::_IN_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIEWPORT *", "D3D11_VIEWPORT", "pViewports", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(D3D11_VIEWPORT *), sizeof(D3D11_VIEWPORT), "pNumViewports");
    METHOD_END("void", "RSGetViewports");
    METHOD_BEGIN("void", "RSGetScissorRects");
    PARAM("UINT *", "UINT", "pNumRects", ParamAnnot::_IN_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_RECT *", "D3D11_RECT", "pRects", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(D3D11_RECT *), sizeof(D3D11_RECT), "pNumRects");
    METHOD_END("void", "RSGetScissorRects");
    METHOD_BEGIN("void", "HSGetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "HSGetShaderResources");
    METHOD_BEGIN("void", "HSGetShader");
    PARAM("ID3D11HullShader **", "ID3D11HullShader", "ppHullShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11HullShader **), sizeof(ID3D11HullShader), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "pNumClassInstances");
    PARAM("UINT *", "UINT", "pNumClassInstances", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "HSGetShader");
    METHOD_BEGIN("void", "HSGetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "HSGetSamplers");
    METHOD_BEGIN("void", "HSGetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "HSGetConstantBuffers");
    METHOD_BEGIN("void", "DSGetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "DSGetShaderResources");
    METHOD_BEGIN("void", "DSGetShader");
    PARAM("ID3D11DomainShader **", "ID3D11DomainShader", "ppDomainShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DomainShader **), sizeof(ID3D11DomainShader), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "pNumClassInstances");
    PARAM("UINT *", "UINT", "pNumClassInstances", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DSGetShader");
    METHOD_BEGIN("void", "DSGetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "DSGetSamplers");
    METHOD_BEGIN("void", "DSGetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "DSGetConstantBuffers");
    METHOD_BEGIN("void", "CSGetShaderResources");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumViews", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppShaderResourceViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NumViews");
    METHOD_END("void", "CSGetShaderResources");
    METHOD_BEGIN("void", "CSGetUnorderedAccessViews");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumUAVs", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView **", "ID3D11UnorderedAccessView", "ppUnorderedAccessViews", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11UnorderedAccessView **), sizeof(ID3D11UnorderedAccessView), "NumUAVs");
    METHOD_END("void", "CSGetUnorderedAccessViews");
    METHOD_BEGIN("void", "CSGetShader");
    PARAM("ID3D11ComputeShader **", "ID3D11ComputeShader", "ppComputeShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ComputeShader **), sizeof(ID3D11ComputeShader), "NOT_SET");
    PARAM("ID3D11ClassInstance **", "ID3D11ClassInstance", "ppClassInstances", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11ClassInstance **), sizeof(ID3D11ClassInstance), "pNumClassInstances");
    PARAM("UINT *", "UINT", "pNumClassInstances", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "CSGetShader");
    METHOD_BEGIN("void", "CSGetSamplers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumSamplers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NumSamplers");
    METHOD_END("void", "CSGetSamplers");
    METHOD_BEGIN("void", "CSGetConstantBuffers");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    METHOD_END("void", "CSGetConstantBuffers");
    METHOD_BEGIN("void", "ClearState");
    METHOD_END("void", "ClearState");
    METHOD_BEGIN("void", "Flush");
    METHOD_END("void", "Flush");
    METHOD_BEGIN("D3D11_DEVICE_CONTEXT_TYPE", "GetType");
    METHOD_END("D3D11_DEVICE_CONTEXT_TYPE", "GetType");
    METHOD_BEGIN("UINT", "GetContextFlags");
    METHOD_END("UINT", "GetContextFlags");
    METHOD_BEGIN("HRESULT", "FinishCommandList");
    PARAM("BOOL", "BOOL", "RestoreDeferredContextState", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("ID3D11CommandList **", "ID3D11CommandList", "ppCommandList", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11CommandList **), sizeof(ID3D11CommandList), "NOT_SET");
    METHOD_END("HRESULT", "FinishCommandList");
    CLASS_END("ID3D11DeviceContext");
    CLASS_BEGIN("ID3D11VideoDecoder");
    METHOD_BEGIN("HRESULT", "GetCreationParameters");
    PARAM("D3D11_VIDEO_DECODER_DESC *", "D3D11_VIDEO_DECODER_DESC", "pVideoDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_DECODER_DESC *), sizeof(D3D11_VIDEO_DECODER_DESC), "NOT_SET");
    PARAM("D3D11_VIDEO_DECODER_CONFIG *", "D3D11_VIDEO_DECODER_CONFIG", "pConfig", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_DECODER_CONFIG *), sizeof(D3D11_VIDEO_DECODER_CONFIG), "NOT_SET");
    METHOD_END("HRESULT", "GetCreationParameters");
    METHOD_BEGIN("HRESULT", "GetDriverHandle");
    PARAM("HANDLE *", "HANDLE", "pDriverHandle", ParamAnnot::_OUT_, 1, false, sizeof(HANDLE *), sizeof(HANDLE), "NOT_SET");
    METHOD_END("HRESULT", "GetDriverHandle");
    CLASS_END("ID3D11VideoDecoder");
    CLASS_BEGIN("ID3D11VideoProcessorEnumerator");
    METHOD_BEGIN("HRESULT", "GetVideoProcessorContentDesc");
    PARAM("D3D11_VIDEO_PROCESSOR_CONTENT_DESC *", "D3D11_VIDEO_PROCESSOR_CONTENT_DESC", "pContentDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_CONTENT_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_CONTENT_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoProcessorContentDesc");
    METHOD_BEGIN("HRESULT", "CheckVideoProcessorFormat");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT *", "UINT", "pFlags", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckVideoProcessorFormat");
    METHOD_BEGIN("HRESULT", "GetVideoProcessorCaps");
    PARAM("D3D11_VIDEO_PROCESSOR_CAPS *", "D3D11_VIDEO_PROCESSOR_CAPS", "pCaps", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_CAPS *), sizeof(D3D11_VIDEO_PROCESSOR_CAPS), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoProcessorCaps");
    METHOD_BEGIN("HRESULT", "GetVideoProcessorRateConversionCaps");
    PARAM("UINT", "UINT", "TypeIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS *", "D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS", "pCaps", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS *), sizeof(D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoProcessorRateConversionCaps");
    METHOD_BEGIN("HRESULT", "GetVideoProcessorCustomRate");
    PARAM("UINT", "UINT", "TypeIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "CustomRateIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_CUSTOM_RATE *", "D3D11_VIDEO_PROCESSOR_CUSTOM_RATE", "pRate", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_CUSTOM_RATE *), sizeof(D3D11_VIDEO_PROCESSOR_CUSTOM_RATE), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoProcessorCustomRate");
    METHOD_BEGIN("HRESULT", "GetVideoProcessorFilterRange");
    PARAM("D3D11_VIDEO_PROCESSOR_FILTER", "D3D11_VIDEO_PROCESSOR_FILTER", "Filter", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_FILTER), sizeof(D3D11_VIDEO_PROCESSOR_FILTER), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_FILTER_RANGE *", "D3D11_VIDEO_PROCESSOR_FILTER_RANGE", "pRange", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_FILTER_RANGE *), sizeof(D3D11_VIDEO_PROCESSOR_FILTER_RANGE), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoProcessorFilterRange");
    CLASS_END("ID3D11VideoProcessorEnumerator");
    CLASS_BEGIN("ID3D11VideoProcessor");
    METHOD_BEGIN("void", "GetContentDesc");
    PARAM("D3D11_VIDEO_PROCESSOR_CONTENT_DESC *", "D3D11_VIDEO_PROCESSOR_CONTENT_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_CONTENT_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_CONTENT_DESC), "NOT_SET");
    METHOD_END("void", "GetContentDesc");
    METHOD_BEGIN("void", "GetRateConversionCaps");
    PARAM("D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS *", "D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS", "pCaps", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS *), sizeof(D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS), "NOT_SET");
    METHOD_END("void", "GetRateConversionCaps");
    CLASS_END("ID3D11VideoProcessor");
    CLASS_BEGIN("ID3D11AuthenticatedChannel");
    METHOD_BEGIN("HRESULT", "GetCertificateSize");
    PARAM("UINT *", "UINT", "pCertificateSize", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetCertificateSize");
    METHOD_BEGIN("HRESULT", "GetCertificate");
    PARAM("UINT", "UINT", "CertificateSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BYTE *", "BYTE", "pCertificate", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(BYTE *), sizeof(BYTE), "CertificateSize");
    METHOD_END("HRESULT", "GetCertificate");
    METHOD_BEGIN("void", "GetChannelHandle");
    PARAM("HANDLE *", "HANDLE", "pChannelHandle", ParamAnnot::_OUT_, 1, false, sizeof(HANDLE *), sizeof(HANDLE), "NOT_SET");
    METHOD_END("void", "GetChannelHandle");
    CLASS_END("ID3D11AuthenticatedChannel");
    CLASS_BEGIN("ID3D11CryptoSession");
    METHOD_BEGIN("void", "GetCryptoType");
    PARAM("GUID *", "GUID", "pCryptoType", ParamAnnot::_OUT_, 1, false, sizeof(GUID *), sizeof(GUID), "NOT_SET");
    METHOD_END("void", "GetCryptoType");
    METHOD_BEGIN("void", "GetDecoderProfile");
    PARAM("GUID *", "GUID", "pDecoderProfile", ParamAnnot::_OUT_, 1, false, sizeof(GUID *), sizeof(GUID), "NOT_SET");
    METHOD_END("void", "GetDecoderProfile");
    METHOD_BEGIN("HRESULT", "GetCertificateSize");
    PARAM("UINT *", "UINT", "pCertificateSize", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetCertificateSize");
    METHOD_BEGIN("HRESULT", "GetCertificate");
    PARAM("UINT", "UINT", "CertificateSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BYTE *", "BYTE", "pCertificate", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(BYTE *), sizeof(BYTE), "CertificateSize");
    METHOD_END("HRESULT", "GetCertificate");
    METHOD_BEGIN("void", "GetCryptoSessionHandle");
    PARAM("HANDLE *", "HANDLE", "pCryptoSessionHandle", ParamAnnot::_OUT_, 1, false, sizeof(HANDLE *), sizeof(HANDLE), "NOT_SET");
    METHOD_END("void", "GetCryptoSessionHandle");
    CLASS_END("ID3D11CryptoSession");
    CLASS_BEGIN("ID3D11VideoDecoderOutputView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC *", "D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC *), sizeof(D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11VideoDecoderOutputView");
    CLASS_BEGIN("ID3D11VideoProcessorInputView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC *", "D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11VideoProcessorInputView");
    CLASS_BEGIN("ID3D11VideoProcessorOutputView");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC *", "D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    CLASS_END("ID3D11VideoProcessorOutputView");
    CLASS_BEGIN("ID3D11VideoContext");
    METHOD_BEGIN("HRESULT", "GetDecoderBuffer");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("D3D11_VIDEO_DECODER_BUFFER_TYPE", "D3D11_VIDEO_DECODER_BUFFER_TYPE", "Type", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_DECODER_BUFFER_TYPE), sizeof(D3D11_VIDEO_DECODER_BUFFER_TYPE), "NOT_SET");
    PARAM("UINT *", "UINT", "pBufferSize", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("void **", "void", "ppBuffer", ParamAnnot::_OUT_ARRAY_, 2, false, sizeof(void **), 0, "pBufferSize");
    METHOD_END("HRESULT", "GetDecoderBuffer");
    METHOD_BEGIN("HRESULT", "ReleaseDecoderBuffer");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("D3D11_VIDEO_DECODER_BUFFER_TYPE", "D3D11_VIDEO_DECODER_BUFFER_TYPE", "Type", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_DECODER_BUFFER_TYPE), sizeof(D3D11_VIDEO_DECODER_BUFFER_TYPE), "NOT_SET");
    METHOD_END("HRESULT", "ReleaseDecoderBuffer");
    METHOD_BEGIN("HRESULT", "DecoderBeginFrame");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("ID3D11VideoDecoderOutputView *", "ID3D11VideoDecoderOutputView", "pView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoderOutputView *), sizeof(ID3D11VideoDecoderOutputView), "NOT_SET");
    PARAM("UINT", "UINT", "ContentKeySize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pContentKey", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "ContentKeySize");
    METHOD_END("HRESULT", "DecoderBeginFrame");
    METHOD_BEGIN("HRESULT", "DecoderEndFrame");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    METHOD_END("HRESULT", "DecoderEndFrame");
    METHOD_BEGIN("HRESULT", "SubmitDecoderBuffers");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_BUFFER_DESC *", "D3D11_VIDEO_DECODER_BUFFER_DESC", "pBufferDesc", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_VIDEO_DECODER_BUFFER_DESC *), sizeof(D3D11_VIDEO_DECODER_BUFFER_DESC), "NumBuffers");
    METHOD_END("HRESULT", "SubmitDecoderBuffers");
    METHOD_BEGIN("APP_DEPRECATED_HRESULT", "DecoderExtension");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_EXTENSION *", "D3D11_VIDEO_DECODER_EXTENSION", "pExtensionData", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_EXTENSION *), sizeof(D3D11_VIDEO_DECODER_EXTENSION), "NOT_SET");
    METHOD_END("APP_DEPRECATED_HRESULT", "DecoderExtension");
    METHOD_BEGIN("void", "VideoProcessorSetOutputTargetRect");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("const RECT *", "RECT", "pRect", ParamAnnot::_IN_, 1, false, sizeof(const RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputTargetRect");
    METHOD_BEGIN("void", "VideoProcessorSetOutputBackgroundColor");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL", "BOOL", "YCbCr", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("const D3D11_VIDEO_COLOR *", "D3D11_VIDEO_COLOR", "pColor", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_COLOR *), sizeof(D3D11_VIDEO_COLOR), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputBackgroundColor");
    METHOD_BEGIN("void", "VideoProcessorSetOutputColorSpace");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("const D3D11_VIDEO_PROCESSOR_COLOR_SPACE *", "D3D11_VIDEO_PROCESSOR_COLOR_SPACE", "pColorSpace", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_COLOR_SPACE *), sizeof(D3D11_VIDEO_PROCESSOR_COLOR_SPACE), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputColorSpace");
    METHOD_BEGIN("void", "VideoProcessorSetOutputAlphaFillMode");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE", "D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE", "AlphaFillMode", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE), sizeof(D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputAlphaFillMode");
    METHOD_BEGIN("void", "VideoProcessorSetOutputConstriction");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("SIZE", "SIZE", "Size", ParamAnnot::_IN_, 0, false, sizeof(SIZE), sizeof(SIZE), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputConstriction");
    METHOD_BEGIN("void", "VideoProcessorSetOutputStereoMode");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputStereoMode");
    METHOD_BEGIN("APP_DEPRECATED_HRESULT", "VideoProcessorSetOutputExtension");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("const GUID *", "GUID", "pExtensionGuid", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_IN_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("APP_DEPRECATED_HRESULT", "VideoProcessorSetOutputExtension");
    METHOD_BEGIN("void", "VideoProcessorGetOutputTargetRect");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL *", "BOOL", "Enabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("RECT *", "RECT", "pRect", ParamAnnot::_OUT_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputTargetRect");
    METHOD_BEGIN("void", "VideoProcessorGetOutputBackgroundColor");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pYCbCr", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_COLOR *", "D3D11_VIDEO_COLOR", "pColor", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_COLOR *), sizeof(D3D11_VIDEO_COLOR), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputBackgroundColor");
    METHOD_BEGIN("void", "VideoProcessorGetOutputColorSpace");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_COLOR_SPACE *", "D3D11_VIDEO_PROCESSOR_COLOR_SPACE", "pColorSpace", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_COLOR_SPACE *), sizeof(D3D11_VIDEO_PROCESSOR_COLOR_SPACE), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputColorSpace");
    METHOD_BEGIN("void", "VideoProcessorGetOutputAlphaFillMode");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE *", "D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE", "pAlphaFillMode", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE *), sizeof(D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE), "NOT_SET");
    PARAM("UINT *", "UINT", "pStreamIndex", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputAlphaFillMode");
    METHOD_BEGIN("void", "VideoProcessorGetOutputConstriction");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("SIZE *", "SIZE", "pSize", ParamAnnot::_OUT_, 1, false, sizeof(SIZE *), sizeof(SIZE), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputConstriction");
    METHOD_BEGIN("void", "VideoProcessorGetOutputStereoMode");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputStereoMode");
    METHOD_BEGIN("APP_DEPRECATED_HRESULT", "VideoProcessorGetOutputExtension");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("const GUID *", "GUID", "pExtensionGuid", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "DataSize");
    METHOD_END("APP_DEPRECATED_HRESULT", "VideoProcessorGetOutputExtension");
    METHOD_BEGIN("void", "VideoProcessorSetStreamFrameFormat");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_FRAME_FORMAT", "D3D11_VIDEO_FRAME_FORMAT", "FrameFormat", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_FRAME_FORMAT), sizeof(D3D11_VIDEO_FRAME_FORMAT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamFrameFormat");
    METHOD_BEGIN("void", "VideoProcessorSetStreamColorSpace");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIDEO_PROCESSOR_COLOR_SPACE *", "D3D11_VIDEO_PROCESSOR_COLOR_SPACE", "pColorSpace", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_COLOR_SPACE *), sizeof(D3D11_VIDEO_PROCESSOR_COLOR_SPACE), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamColorSpace");
    METHOD_BEGIN("void", "VideoProcessorSetStreamOutputRate");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_OUTPUT_RATE", "D3D11_VIDEO_PROCESSOR_OUTPUT_RATE", "OutputRate", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_RATE), sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_RATE), "NOT_SET");
    PARAM("BOOL", "BOOL", "RepeatFrame", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("const DXGI_RATIONAL *", "DXGI_RATIONAL", "pCustomRate", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamOutputRate");
    METHOD_BEGIN("void", "VideoProcessorSetStreamSourceRect");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("const RECT *", "RECT", "pRect", ParamAnnot::_IN_, 1, false, sizeof(const RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamSourceRect");
    METHOD_BEGIN("void", "VideoProcessorSetStreamDestRect");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("const RECT *", "RECT", "pRect", ParamAnnot::_IN_, 1, false, sizeof(const RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamDestRect");
    METHOD_BEGIN("void", "VideoProcessorSetStreamAlpha");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("FLOAT", "FLOAT", "Alpha", ParamAnnot::_IN_, 0, false, sizeof(FLOAT), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamAlpha");
    METHOD_BEGIN("void", "VideoProcessorSetStreamPalette");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Count", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const UINT *", "UINT", "pEntries", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "Count");
    METHOD_END("void", "VideoProcessorSetStreamPalette");
    METHOD_BEGIN("void", "VideoProcessorSetStreamPixelAspectRatio");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("const DXGI_RATIONAL *", "DXGI_RATIONAL", "pSourceAspectRatio", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    PARAM("const DXGI_RATIONAL *", "DXGI_RATIONAL", "pDestinationAspectRatio", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamPixelAspectRatio");
    METHOD_BEGIN("void", "VideoProcessorSetStreamLumaKey");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("FLOAT", "FLOAT", "Lower", ParamAnnot::_IN_, 0, false, sizeof(FLOAT), sizeof(FLOAT), "NOT_SET");
    PARAM("FLOAT", "FLOAT", "Upper", ParamAnnot::_IN_, 0, false, sizeof(FLOAT), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamLumaKey");
    METHOD_BEGIN("void", "VideoProcessorSetStreamStereoFormat");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_STEREO_FORMAT", "D3D11_VIDEO_PROCESSOR_STEREO_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FORMAT), sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FORMAT), "NOT_SET");
    PARAM("BOOL", "BOOL", "LeftViewFrame0", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL", "BOOL", "BaseViewFrame0", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE", "D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE", "FlipMode", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE), sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE), "NOT_SET");
    PARAM("int", "int", "MonoOffset", ParamAnnot::_IN_, 0, false, sizeof(int), sizeof(int), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamStereoFormat");
    METHOD_BEGIN("void", "VideoProcessorSetStreamAutoProcessingMode");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamAutoProcessingMode");
    METHOD_BEGIN("void", "VideoProcessorSetStreamFilter");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_FILTER", "D3D11_VIDEO_PROCESSOR_FILTER", "Filter", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_FILTER), sizeof(D3D11_VIDEO_PROCESSOR_FILTER), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("int", "int", "Level", ParamAnnot::_IN_, 0, false, sizeof(int), sizeof(int), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamFilter");
    METHOD_BEGIN("APP_DEPRECATED_HRESULT", "VideoProcessorSetStreamExtension");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const GUID *", "GUID", "pExtensionGuid", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_IN_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("APP_DEPRECATED_HRESULT", "VideoProcessorSetStreamExtension");
    METHOD_BEGIN("void", "VideoProcessorGetStreamFrameFormat");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_FRAME_FORMAT *", "D3D11_VIDEO_FRAME_FORMAT", "pFrameFormat", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_FRAME_FORMAT *), sizeof(D3D11_VIDEO_FRAME_FORMAT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamFrameFormat");
    METHOD_BEGIN("void", "VideoProcessorGetStreamColorSpace");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_COLOR_SPACE *", "D3D11_VIDEO_PROCESSOR_COLOR_SPACE", "pColorSpace", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_COLOR_SPACE *), sizeof(D3D11_VIDEO_PROCESSOR_COLOR_SPACE), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamColorSpace");
    METHOD_BEGIN("void", "VideoProcessorGetStreamOutputRate");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_OUTPUT_RATE *", "D3D11_VIDEO_PROCESSOR_OUTPUT_RATE", "pOutputRate", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_RATE *), sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_RATE), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pRepeatFrame", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("DXGI_RATIONAL *", "DXGI_RATIONAL", "pCustomRate", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamOutputRate");
    METHOD_BEGIN("void", "VideoProcessorGetStreamSourceRect");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("RECT *", "RECT", "pRect", ParamAnnot::_OUT_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamSourceRect");
    METHOD_BEGIN("void", "VideoProcessorGetStreamDestRect");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("RECT *", "RECT", "pRect", ParamAnnot::_OUT_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamDestRect");
    METHOD_BEGIN("void", "VideoProcessorGetStreamAlpha");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("FLOAT *", "FLOAT", "pAlpha", ParamAnnot::_OUT_, 1, false, sizeof(FLOAT *), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamAlpha");
    METHOD_BEGIN("void", "VideoProcessorGetStreamPalette");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Count", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pEntries", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "Count");
    METHOD_END("void", "VideoProcessorGetStreamPalette");
    METHOD_BEGIN("void", "VideoProcessorGetStreamPixelAspectRatio");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("DXGI_RATIONAL *", "DXGI_RATIONAL", "pSourceAspectRatio", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    PARAM("DXGI_RATIONAL *", "DXGI_RATIONAL", "pDestinationAspectRatio", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamPixelAspectRatio");
    METHOD_BEGIN("void", "VideoProcessorGetStreamLumaKey");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("FLOAT *", "FLOAT", "pLower", ParamAnnot::_OUT_, 1, false, sizeof(FLOAT *), sizeof(FLOAT), "NOT_SET");
    PARAM("FLOAT *", "FLOAT", "pUpper", ParamAnnot::_OUT_, 1, false, sizeof(FLOAT *), sizeof(FLOAT), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamLumaKey");
    METHOD_BEGIN("void", "VideoProcessorGetStreamStereoFormat");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnable", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_STEREO_FORMAT *", "D3D11_VIDEO_PROCESSOR_STEREO_FORMAT", "pFormat", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FORMAT *), sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FORMAT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pLeftViewFrame0", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pBaseViewFrame0", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE *", "D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE", "pFlipMode", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE *), sizeof(D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE), "NOT_SET");
    PARAM("int *", "int", "MonoOffset", ParamAnnot::_OUT_, 1, false, sizeof(int *), sizeof(int), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamStereoFormat");
    METHOD_BEGIN("void", "VideoProcessorGetStreamAutoProcessingMode");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamAutoProcessingMode");
    METHOD_BEGIN("void", "VideoProcessorGetStreamFilter");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_FILTER", "D3D11_VIDEO_PROCESSOR_FILTER", "Filter", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_FILTER), sizeof(D3D11_VIDEO_PROCESSOR_FILTER), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnabled", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("int *", "int", "pLevel", ParamAnnot::_OUT_, 1, false, sizeof(int *), sizeof(int), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamFilter");
    METHOD_BEGIN("APP_DEPRECATED_HRESULT", "VideoProcessorGetStreamExtension");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const GUID *", "GUID", "pExtensionGuid", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "DataSize");
    METHOD_END("APP_DEPRECATED_HRESULT", "VideoProcessorGetStreamExtension");
    METHOD_BEGIN("HRESULT", "VideoProcessorBlt");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("ID3D11VideoProcessorOutputView *", "ID3D11VideoProcessorOutputView", "pView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessorOutputView *), sizeof(ID3D11VideoProcessorOutputView), "NOT_SET");
    PARAM("UINT", "UINT", "OutputFrame", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "StreamCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIDEO_PROCESSOR_STREAM *", "D3D11_VIDEO_PROCESSOR_STREAM", "pStreams", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_STREAM *), sizeof(D3D11_VIDEO_PROCESSOR_STREAM), "StreamCount");
    METHOD_END("HRESULT", "VideoProcessorBlt");
    METHOD_BEGIN("HRESULT", "NegotiateCryptoSessionKeyExchange");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_INOUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("HRESULT", "NegotiateCryptoSessionKeyExchange");
    METHOD_BEGIN("void", "EncryptionBlt");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("ID3D11Texture2D *", "ID3D11Texture2D", "pSrcSurface", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Texture2D *), sizeof(ID3D11Texture2D), "NOT_SET");
    PARAM("ID3D11Texture2D *", "ID3D11Texture2D", "pDstSurface", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Texture2D *), sizeof(ID3D11Texture2D), "NOT_SET");
    PARAM("UINT", "UINT", "IVSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pIV", ParamAnnot::_INOUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("void", "EncryptionBlt");
    METHOD_BEGIN("void", "DecryptionBlt");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("ID3D11Texture2D *", "ID3D11Texture2D", "pSrcSurface", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Texture2D *), sizeof(ID3D11Texture2D), "NOT_SET");
    PARAM("ID3D11Texture2D *", "ID3D11Texture2D", "pDstSurface", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Texture2D *), sizeof(ID3D11Texture2D), "NOT_SET");
    PARAM("D3D11_ENCRYPTED_BLOCK_INFO *", "D3D11_ENCRYPTED_BLOCK_INFO", "pEncryptedBlockInfo", ParamAnnot::_IN_, 1, false, sizeof(D3D11_ENCRYPTED_BLOCK_INFO *), sizeof(D3D11_ENCRYPTED_BLOCK_INFO), "NOT_SET");
    PARAM("UINT", "UINT", "ContentKeySize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pContentKey", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "ContentKeySize");
    PARAM("UINT", "UINT", "IVSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pIV", ParamAnnot::_INOUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("void", "DecryptionBlt");
    METHOD_BEGIN("void", "StartSessionKeyRefresh");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("UINT", "UINT", "RandomNumberSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pRandomNumber", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "RandomNumberSize");
    METHOD_END("void", "StartSessionKeyRefresh");
    METHOD_BEGIN("void", "FinishSessionKeyRefresh");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    METHOD_END("void", "FinishSessionKeyRefresh");
    METHOD_BEGIN("HRESULT", "GetEncryptionBltKey");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("UINT", "UINT", "KeySize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pReadbackKey", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "KeySize");
    METHOD_END("HRESULT", "GetEncryptionBltKey");
    METHOD_BEGIN("HRESULT", "NegotiateAuthenticatedChannelKeyExchange");
    PARAM("ID3D11AuthenticatedChannel *", "ID3D11AuthenticatedChannel", "pChannel", ParamAnnot::_IN_, 1, true, sizeof(ID3D11AuthenticatedChannel *), sizeof(ID3D11AuthenticatedChannel), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_INOUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("HRESULT", "NegotiateAuthenticatedChannelKeyExchange");
    METHOD_BEGIN("HRESULT", "QueryAuthenticatedChannel");
    PARAM("ID3D11AuthenticatedChannel *", "ID3D11AuthenticatedChannel", "pChannel", ParamAnnot::_IN_, 1, true, sizeof(ID3D11AuthenticatedChannel *), sizeof(ID3D11AuthenticatedChannel), "NOT_SET");
    PARAM("UINT", "UINT", "InputSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pInput", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "InputSize");
    PARAM("UINT", "UINT", "OutputSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pOutput", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "OutputSize");
    METHOD_END("HRESULT", "QueryAuthenticatedChannel");
    METHOD_BEGIN("HRESULT", "ConfigureAuthenticatedChannel");
    PARAM("ID3D11AuthenticatedChannel *", "ID3D11AuthenticatedChannel", "pChannel", ParamAnnot::_IN_, 1, true, sizeof(ID3D11AuthenticatedChannel *), sizeof(ID3D11AuthenticatedChannel), "NOT_SET");
    PARAM("UINT", "UINT", "InputSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pInput", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "InputSize");
    PARAM("D3D11_AUTHENTICATED_CONFIGURE_OUTPUT *", "D3D11_AUTHENTICATED_CONFIGURE_OUTPUT", "pOutput", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_AUTHENTICATED_CONFIGURE_OUTPUT *), sizeof(D3D11_AUTHENTICATED_CONFIGURE_OUTPUT), "NOT_SET");
    METHOD_END("HRESULT", "ConfigureAuthenticatedChannel");
    METHOD_BEGIN("void", "VideoProcessorSetStreamRotation");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_ROTATION", "D3D11_VIDEO_PROCESSOR_ROTATION", "Rotation", ParamAnnot::_IN_, 0, false, sizeof(D3D11_VIDEO_PROCESSOR_ROTATION), sizeof(D3D11_VIDEO_PROCESSOR_ROTATION), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamRotation");
    METHOD_BEGIN("void", "VideoProcessorGetStreamRotation");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnable", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("D3D11_VIDEO_PROCESSOR_ROTATION *", "D3D11_VIDEO_PROCESSOR_ROTATION", "pRotation", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_PROCESSOR_ROTATION *), sizeof(D3D11_VIDEO_PROCESSOR_ROTATION), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamRotation");
    CLASS_END("ID3D11VideoContext");
    CLASS_BEGIN("ID3D11VideoDevice");
    METHOD_BEGIN("HRESULT", "CreateVideoDecoder");
    PARAM("const D3D11_VIDEO_DECODER_DESC *", "D3D11_VIDEO_DECODER_DESC", "pVideoDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_DESC *), sizeof(D3D11_VIDEO_DECODER_DESC), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_CONFIG *", "D3D11_VIDEO_DECODER_CONFIG", "pConfig", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_CONFIG *), sizeof(D3D11_VIDEO_DECODER_CONFIG), "NOT_SET");
    PARAM("ID3D11VideoDecoder **", "ID3D11VideoDecoder", "ppDecoder", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VideoDecoder **), sizeof(ID3D11VideoDecoder), "NOT_SET");
    METHOD_END("HRESULT", "CreateVideoDecoder");
    METHOD_BEGIN("HRESULT", "CreateVideoProcessor");
    PARAM("ID3D11VideoProcessorEnumerator *", "ID3D11VideoProcessorEnumerator", "pEnum", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessorEnumerator *), sizeof(ID3D11VideoProcessorEnumerator), "NOT_SET");
    PARAM("UINT", "UINT", "RateConversionIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11VideoProcessor **", "ID3D11VideoProcessor", "ppVideoProcessor", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VideoProcessor **), sizeof(ID3D11VideoProcessor), "NOT_SET");
    METHOD_END("HRESULT", "CreateVideoProcessor");
    METHOD_BEGIN("HRESULT", "CreateAuthenticatedChannel");
    PARAM("D3D11_AUTHENTICATED_CHANNEL_TYPE", "D3D11_AUTHENTICATED_CHANNEL_TYPE", "ChannelType", ParamAnnot::_IN_, 0, false, sizeof(D3D11_AUTHENTICATED_CHANNEL_TYPE), sizeof(D3D11_AUTHENTICATED_CHANNEL_TYPE), "NOT_SET");
    PARAM("ID3D11AuthenticatedChannel **", "ID3D11AuthenticatedChannel", "ppAuthenticatedChannel", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11AuthenticatedChannel **), sizeof(ID3D11AuthenticatedChannel), "NOT_SET");
    METHOD_END("HRESULT", "CreateAuthenticatedChannel");
    METHOD_BEGIN("HRESULT", "CreateCryptoSession");
    PARAM("const GUID *", "GUID", "pCryptoType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("const GUID *", "GUID", "pDecoderProfile", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("const GUID *", "GUID", "pKeyExchangeType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("ID3D11CryptoSession **", "ID3D11CryptoSession", "ppCryptoSession", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11CryptoSession **), sizeof(ID3D11CryptoSession), "NOT_SET");
    METHOD_END("HRESULT", "CreateCryptoSession");
    METHOD_BEGIN("HRESULT", "CreateVideoDecoderOutputView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC *", "D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC *), sizeof(D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11VideoDecoderOutputView **", "ID3D11VideoDecoderOutputView", "ppVDOVView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VideoDecoderOutputView **), sizeof(ID3D11VideoDecoderOutputView), "NOT_SET");
    METHOD_END("HRESULT", "CreateVideoDecoderOutputView");
    METHOD_BEGIN("HRESULT", "CreateVideoProcessorInputView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("ID3D11VideoProcessorEnumerator *", "ID3D11VideoProcessorEnumerator", "pEnum", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessorEnumerator *), sizeof(ID3D11VideoProcessorEnumerator), "NOT_SET");
    PARAM("const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC *", "D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11VideoProcessorInputView **", "ID3D11VideoProcessorInputView", "ppVPIView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VideoProcessorInputView **), sizeof(ID3D11VideoProcessorInputView), "NOT_SET");
    METHOD_END("HRESULT", "CreateVideoProcessorInputView");
    METHOD_BEGIN("HRESULT", "CreateVideoProcessorOutputView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("ID3D11VideoProcessorEnumerator *", "ID3D11VideoProcessorEnumerator", "pEnum", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessorEnumerator *), sizeof(ID3D11VideoProcessorEnumerator), "NOT_SET");
    PARAM("const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC *", "D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11VideoProcessorOutputView **", "ID3D11VideoProcessorOutputView", "ppVPOView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VideoProcessorOutputView **), sizeof(ID3D11VideoProcessorOutputView), "NOT_SET");
    METHOD_END("HRESULT", "CreateVideoProcessorOutputView");
    METHOD_BEGIN("HRESULT", "CreateVideoProcessorEnumerator");
    PARAM("const D3D11_VIDEO_PROCESSOR_CONTENT_DESC *", "D3D11_VIDEO_PROCESSOR_CONTENT_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_CONTENT_DESC *), sizeof(D3D11_VIDEO_PROCESSOR_CONTENT_DESC), "NOT_SET");
    PARAM("ID3D11VideoProcessorEnumerator **", "ID3D11VideoProcessorEnumerator", "ppEnum", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VideoProcessorEnumerator **), sizeof(ID3D11VideoProcessorEnumerator), "NOT_SET");
    METHOD_END("HRESULT", "CreateVideoProcessorEnumerator");
    METHOD_BEGIN("UINT", "GetVideoDecoderProfileCount");
    METHOD_END("UINT", "GetVideoDecoderProfileCount");
    METHOD_BEGIN("HRESULT", "GetVideoDecoderProfile");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("GUID *", "GUID", "pDecoderProfile", ParamAnnot::_OUT_, 1, false, sizeof(GUID *), sizeof(GUID), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoDecoderProfile");
    METHOD_BEGIN("HRESULT", "CheckVideoDecoderFormat");
    PARAM("const GUID *", "GUID", "pDecoderProfile", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pSupported", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "CheckVideoDecoderFormat");
    METHOD_BEGIN("HRESULT", "GetVideoDecoderConfigCount");
    PARAM("const D3D11_VIDEO_DECODER_DESC *", "D3D11_VIDEO_DECODER_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_DESC *), sizeof(D3D11_VIDEO_DECODER_DESC), "NOT_SET");
    PARAM("UINT *", "UINT", "pCount", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoDecoderConfigCount");
    METHOD_BEGIN("HRESULT", "GetVideoDecoderConfig");
    PARAM("const D3D11_VIDEO_DECODER_DESC *", "D3D11_VIDEO_DECODER_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_DESC *), sizeof(D3D11_VIDEO_DECODER_DESC), "NOT_SET");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_VIDEO_DECODER_CONFIG *", "D3D11_VIDEO_DECODER_CONFIG", "pConfig", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_DECODER_CONFIG *), sizeof(D3D11_VIDEO_DECODER_CONFIG), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoDecoderConfig");
    METHOD_BEGIN("HRESULT", "GetContentProtectionCaps");
    PARAM("const GUID *", "GUID", "pCryptoType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("const GUID *", "GUID", "pDecoderProfile", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("D3D11_VIDEO_CONTENT_PROTECTION_CAPS *", "D3D11_VIDEO_CONTENT_PROTECTION_CAPS", "pCaps", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_CONTENT_PROTECTION_CAPS *), sizeof(D3D11_VIDEO_CONTENT_PROTECTION_CAPS), "NOT_SET");
    METHOD_END("HRESULT", "GetContentProtectionCaps");
    METHOD_BEGIN("HRESULT", "CheckCryptoKeyExchange");
    PARAM("const GUID *", "GUID", "pCryptoType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("const GUID *", "GUID", "pDecoderProfile", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("GUID *", "GUID", "pKeyExchangeType", ParamAnnot::_OUT_, 1, false, sizeof(GUID *), sizeof(GUID), "NOT_SET");
    METHOD_END("HRESULT", "CheckCryptoKeyExchange");
    METHOD_BEGIN("HRESULT", "SetPrivateData");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "DataSize");
    METHOD_END("HRESULT", "SetPrivateData");
    METHOD_BEGIN("HRESULT", "SetPrivateDataInterface");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("const struct IUnknown *", "IUnknown", "pData", ParamAnnot::_IN_, 1, true, sizeof(const struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    METHOD_END("HRESULT", "SetPrivateDataInterface");
    CLASS_END("ID3D11VideoDevice");
    CLASS_BEGIN("ID3D11Device");
    METHOD_BEGIN("HRESULT", "CreateBuffer");
    PARAM("const D3D11_BUFFER_DESC *", "D3D11_BUFFER_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BUFFER_DESC *), sizeof(D3D11_BUFFER_DESC), "NOT_SET");
    PARAM("const D3D11_SUBRESOURCE_DATA *", "D3D11_SUBRESOURCE_DATA", "pInitialData", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_SUBRESOURCE_DATA *), sizeof(D3D11_SUBRESOURCE_DATA), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppBuffer", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NOT_SET");
    METHOD_END("HRESULT", "CreateBuffer");
    METHOD_BEGIN("HRESULT", "CreateTexture1D");
    PARAM("const D3D11_TEXTURE1D_DESC *", "D3D11_TEXTURE1D_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TEXTURE1D_DESC *), sizeof(D3D11_TEXTURE1D_DESC), "NOT_SET");
    PARAM("const D3D11_SUBRESOURCE_DATA *", "D3D11_SUBRESOURCE_DATA", "pInitialData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_SUBRESOURCE_DATA *), sizeof(D3D11_SUBRESOURCE_DATA), "_Inexpressible_(pDesc->MipLevelspDesc->ArraySize)");
    PARAM("ID3D11Texture1D **", "ID3D11Texture1D", "ppTexture1D", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Texture1D **), sizeof(ID3D11Texture1D), "NOT_SET");
    METHOD_END("HRESULT", "CreateTexture1D");
    METHOD_BEGIN("HRESULT", "CreateTexture2D");
    PARAM("const D3D11_TEXTURE2D_DESC *", "D3D11_TEXTURE2D_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TEXTURE2D_DESC *), sizeof(D3D11_TEXTURE2D_DESC), "NOT_SET");
    PARAM("const D3D11_SUBRESOURCE_DATA *", "D3D11_SUBRESOURCE_DATA", "pInitialData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_SUBRESOURCE_DATA *), sizeof(D3D11_SUBRESOURCE_DATA), "_Inexpressible_(pDesc->MipLevelspDesc->ArraySize)");
    PARAM("ID3D11Texture2D **", "ID3D11Texture2D", "ppTexture2D", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Texture2D **), sizeof(ID3D11Texture2D), "NOT_SET");
    METHOD_END("HRESULT", "CreateTexture2D");
    METHOD_BEGIN("HRESULT", "CreateTexture3D");
    PARAM("const D3D11_TEXTURE3D_DESC *", "D3D11_TEXTURE3D_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TEXTURE3D_DESC *), sizeof(D3D11_TEXTURE3D_DESC), "NOT_SET");
    PARAM("const D3D11_SUBRESOURCE_DATA *", "D3D11_SUBRESOURCE_DATA", "pInitialData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_SUBRESOURCE_DATA *), sizeof(D3D11_SUBRESOURCE_DATA), "_Inexpressible_(pDesc->MipLevels)");
    PARAM("ID3D11Texture3D **", "ID3D11Texture3D", "ppTexture3D", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Texture3D **), sizeof(ID3D11Texture3D), "NOT_SET");
    METHOD_END("HRESULT", "CreateTexture3D");
    METHOD_BEGIN("HRESULT", "CreateShaderResourceView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_SHADER_RESOURCE_VIEW_DESC *", "D3D11_SHADER_RESOURCE_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_SHADER_RESOURCE_VIEW_DESC *), sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11ShaderResourceView **", "ID3D11ShaderResourceView", "ppSRView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ShaderResourceView **), sizeof(ID3D11ShaderResourceView), "NOT_SET");
    METHOD_END("HRESULT", "CreateShaderResourceView");
    METHOD_BEGIN("HRESULT", "CreateUnorderedAccessView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_UNORDERED_ACCESS_VIEW_DESC *", "D3D11_UNORDERED_ACCESS_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_UNORDERED_ACCESS_VIEW_DESC *), sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView **", "ID3D11UnorderedAccessView", "ppUAView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11UnorderedAccessView **), sizeof(ID3D11UnorderedAccessView), "NOT_SET");
    METHOD_END("HRESULT", "CreateUnorderedAccessView");
    METHOD_BEGIN("HRESULT", "CreateRenderTargetView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_RENDER_TARGET_VIEW_DESC *", "D3D11_RENDER_TARGET_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_RENDER_TARGET_VIEW_DESC *), sizeof(D3D11_RENDER_TARGET_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11RenderTargetView **", "ID3D11RenderTargetView", "ppRTView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11RenderTargetView **), sizeof(ID3D11RenderTargetView), "NOT_SET");
    METHOD_END("HRESULT", "CreateRenderTargetView");
    METHOD_BEGIN("HRESULT", "CreateDepthStencilView");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_DEPTH_STENCIL_VIEW_DESC *", "D3D11_DEPTH_STENCIL_VIEW_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_DEPTH_STENCIL_VIEW_DESC *), sizeof(D3D11_DEPTH_STENCIL_VIEW_DESC), "NOT_SET");
    PARAM("ID3D11DepthStencilView **", "ID3D11DepthStencilView", "ppDepthStencilView", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DepthStencilView **), sizeof(ID3D11DepthStencilView), "NOT_SET");
    METHOD_END("HRESULT", "CreateDepthStencilView");
    METHOD_BEGIN("HRESULT", "CreateInputLayout");
    PARAM("const D3D11_INPUT_ELEMENT_DESC *", "D3D11_INPUT_ELEMENT_DESC", "pInputElementDescs", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_INPUT_ELEMENT_DESC *), sizeof(D3D11_INPUT_ELEMENT_DESC), "NumElements");
    PARAM("UINT", "UINT", "NumElements", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pShaderBytecodeWithInputSignature", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11InputLayout **", "ID3D11InputLayout", "ppInputLayout", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11InputLayout **), sizeof(ID3D11InputLayout), "NOT_SET");
    METHOD_END("HRESULT", "CreateInputLayout");
    METHOD_BEGIN("HRESULT", "CreateVertexShader");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11VertexShader **", "ID3D11VertexShader", "ppVertexShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11VertexShader **), sizeof(ID3D11VertexShader), "NOT_SET");
    METHOD_END("HRESULT", "CreateVertexShader");
    METHOD_BEGIN("HRESULT", "CreateGeometryShader");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11GeometryShader **", "ID3D11GeometryShader", "ppGeometryShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11GeometryShader **), sizeof(ID3D11GeometryShader), "NOT_SET");
    METHOD_END("HRESULT", "CreateGeometryShader");
    METHOD_BEGIN("HRESULT", "CreateGeometryShaderWithStreamOutput");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("const D3D11_SO_DECLARATION_ENTRY *", "D3D11_SO_DECLARATION_ENTRY", "pSODeclaration", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_SO_DECLARATION_ENTRY *), sizeof(D3D11_SO_DECLARATION_ENTRY), "NumEntries");
    PARAM("UINT", "UINT", "NumEntries", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const UINT *", "UINT", "pBufferStrides", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumStrides");
    PARAM("UINT", "UINT", "NumStrides", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "RasterizedStream", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11GeometryShader **", "ID3D11GeometryShader", "ppGeometryShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11GeometryShader **), sizeof(ID3D11GeometryShader), "NOT_SET");
    METHOD_END("HRESULT", "CreateGeometryShaderWithStreamOutput");
    METHOD_BEGIN("HRESULT", "CreatePixelShader");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11PixelShader **", "ID3D11PixelShader", "ppPixelShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11PixelShader **), sizeof(ID3D11PixelShader), "NOT_SET");
    METHOD_END("HRESULT", "CreatePixelShader");
    METHOD_BEGIN("HRESULT", "CreateHullShader");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11HullShader **", "ID3D11HullShader", "ppHullShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11HullShader **), sizeof(ID3D11HullShader), "NOT_SET");
    METHOD_END("HRESULT", "CreateHullShader");
    METHOD_BEGIN("HRESULT", "CreateDomainShader");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11DomainShader **", "ID3D11DomainShader", "ppDomainShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DomainShader **), sizeof(ID3D11DomainShader), "NOT_SET");
    METHOD_END("HRESULT", "CreateDomainShader");
    METHOD_BEGIN("HRESULT", "CreateComputeShader");
    PARAM("const void *", "void", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3D11ClassLinkage *", "ID3D11ClassLinkage", "pClassLinkage", ParamAnnot::_IN_, 1, true, sizeof(ID3D11ClassLinkage *), sizeof(ID3D11ClassLinkage), "NOT_SET");
    PARAM("ID3D11ComputeShader **", "ID3D11ComputeShader", "ppComputeShader", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ComputeShader **), sizeof(ID3D11ComputeShader), "NOT_SET");
    METHOD_END("HRESULT", "CreateComputeShader");
    METHOD_BEGIN("HRESULT", "CreateClassLinkage");
    PARAM("ID3D11ClassLinkage **", "ID3D11ClassLinkage", "ppLinkage", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ClassLinkage **), sizeof(ID3D11ClassLinkage), "NOT_SET");
    METHOD_END("HRESULT", "CreateClassLinkage");
    METHOD_BEGIN("HRESULT", "CreateBlendState");
    PARAM("const D3D11_BLEND_DESC *", "D3D11_BLEND_DESC", "pBlendStateDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BLEND_DESC *), sizeof(D3D11_BLEND_DESC), "NOT_SET");
    PARAM("ID3D11BlendState **", "ID3D11BlendState", "ppBlendState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11BlendState **), sizeof(ID3D11BlendState), "NOT_SET");
    METHOD_END("HRESULT", "CreateBlendState");
    METHOD_BEGIN("HRESULT", "CreateDepthStencilState");
    PARAM("const D3D11_DEPTH_STENCIL_DESC *", "D3D11_DEPTH_STENCIL_DESC", "pDepthStencilDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_DEPTH_STENCIL_DESC *), sizeof(D3D11_DEPTH_STENCIL_DESC), "NOT_SET");
    PARAM("ID3D11DepthStencilState **", "ID3D11DepthStencilState", "ppDepthStencilState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DepthStencilState **), sizeof(ID3D11DepthStencilState), "NOT_SET");
    METHOD_END("HRESULT", "CreateDepthStencilState");
    METHOD_BEGIN("HRESULT", "CreateRasterizerState");
    PARAM("const D3D11_RASTERIZER_DESC *", "D3D11_RASTERIZER_DESC", "pRasterizerDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_RASTERIZER_DESC *), sizeof(D3D11_RASTERIZER_DESC), "NOT_SET");
    PARAM("ID3D11RasterizerState **", "ID3D11RasterizerState", "ppRasterizerState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11RasterizerState **), sizeof(ID3D11RasterizerState), "NOT_SET");
    METHOD_END("HRESULT", "CreateRasterizerState");
    METHOD_BEGIN("HRESULT", "CreateSamplerState");
    PARAM("const D3D11_SAMPLER_DESC *", "D3D11_SAMPLER_DESC", "pSamplerDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_SAMPLER_DESC *), sizeof(D3D11_SAMPLER_DESC), "NOT_SET");
    PARAM("ID3D11SamplerState **", "ID3D11SamplerState", "ppSamplerState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11SamplerState **), sizeof(ID3D11SamplerState), "NOT_SET");
    METHOD_END("HRESULT", "CreateSamplerState");
    METHOD_BEGIN("HRESULT", "CreateQuery");
    PARAM("const D3D11_QUERY_DESC *", "D3D11_QUERY_DESC", "pQueryDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_QUERY_DESC *), sizeof(D3D11_QUERY_DESC), "NOT_SET");
    PARAM("ID3D11Query **", "ID3D11Query", "ppQuery", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Query **), sizeof(ID3D11Query), "NOT_SET");
    METHOD_END("HRESULT", "CreateQuery");
    METHOD_BEGIN("HRESULT", "CreatePredicate");
    PARAM("const D3D11_QUERY_DESC *", "D3D11_QUERY_DESC", "pPredicateDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_QUERY_DESC *), sizeof(D3D11_QUERY_DESC), "NOT_SET");
    PARAM("ID3D11Predicate **", "ID3D11Predicate", "ppPredicate", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Predicate **), sizeof(ID3D11Predicate), "NOT_SET");
    METHOD_END("HRESULT", "CreatePredicate");
    METHOD_BEGIN("HRESULT", "CreateCounter");
    PARAM("const D3D11_COUNTER_DESC *", "D3D11_COUNTER_DESC", "pCounterDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_COUNTER_DESC *), sizeof(D3D11_COUNTER_DESC), "NOT_SET");
    PARAM("ID3D11Counter **", "ID3D11Counter", "ppCounter", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Counter **), sizeof(ID3D11Counter), "NOT_SET");
    METHOD_END("HRESULT", "CreateCounter");
    METHOD_BEGIN("HRESULT", "CreateDeferredContext");
    PARAM("UINT", "UINT", "ContextFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11DeviceContext **", "ID3D11DeviceContext", "ppDeferredContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext **), sizeof(ID3D11DeviceContext), "NOT_SET");
    METHOD_END("HRESULT", "CreateDeferredContext");
    METHOD_BEGIN("HRESULT", "OpenSharedResource");
    PARAM("HANDLE", "HANDLE", "hResource", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("const IID &", "IID", "ReturnedInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppResource", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "OpenSharedResource");
    METHOD_BEGIN("HRESULT", "CheckFormatSupport");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT *", "UINT", "pFormatSupport", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckFormatSupport");
    METHOD_BEGIN("HRESULT", "CheckMultisampleQualityLevels");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "SampleCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pNumQualityLevels", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckMultisampleQualityLevels");
    METHOD_BEGIN("void", "CheckCounterInfo");
    PARAM("D3D11_COUNTER_INFO *", "D3D11_COUNTER_INFO", "pCounterInfo", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_COUNTER_INFO *), sizeof(D3D11_COUNTER_INFO), "NOT_SET");
    METHOD_END("void", "CheckCounterInfo");
    METHOD_BEGIN("HRESULT", "CheckCounter");
    PARAM("const D3D11_COUNTER_DESC *", "D3D11_COUNTER_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_COUNTER_DESC *), sizeof(D3D11_COUNTER_DESC), "NOT_SET");
    PARAM("D3D11_COUNTER_TYPE *", "D3D11_COUNTER_TYPE", "pType", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_COUNTER_TYPE *), sizeof(D3D11_COUNTER_TYPE), "NOT_SET");
    PARAM("UINT *", "UINT", "pActiveCounters", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("LPSTR", "LPSTR", "szName", ParamAnnot::_OUT_ARRAY_, 0, false, sizeof(LPSTR), sizeof(LPSTR), "pNameLength");
    PARAM("UINT *", "UINT", "pNameLength", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("LPSTR", "LPSTR", "szUnits", ParamAnnot::_OUT_ARRAY_, 0, false, sizeof(LPSTR), sizeof(LPSTR), "pUnitsLength");
    PARAM("UINT *", "UINT", "pUnitsLength", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("LPSTR", "LPSTR", "szDescription", ParamAnnot::_OUT_ARRAY_, 0, false, sizeof(LPSTR), sizeof(LPSTR), "pDescriptionLength");
    PARAM("UINT *", "UINT", "pDescriptionLength", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckCounter");
    METHOD_BEGIN("HRESULT", "CheckFeatureSupport");
    PARAM("D3D11_FEATURE", "D3D11_FEATURE", "Feature", ParamAnnot::_IN_, 0, false, sizeof(D3D11_FEATURE), sizeof(D3D11_FEATURE), "NOT_SET");
    PARAM("void *", "void", "pFeatureSupportData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "FeatureSupportDataSize");
    PARAM("UINT", "UINT", "FeatureSupportDataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckFeatureSupport");
    METHOD_BEGIN("HRESULT", "GetPrivateData");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT *", "UINT", "pDataSize", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "pDataSize");
    METHOD_END("HRESULT", "GetPrivateData");
    METHOD_BEGIN("HRESULT", "SetPrivateData");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "DataSize");
    METHOD_END("HRESULT", "SetPrivateData");
    METHOD_BEGIN("HRESULT", "SetPrivateDataInterface");
    PARAM("const GUID &", "GUID", "guid", ParamAnnot::_IN_, 0, false, sizeof(const GUID &), sizeof(GUID), "NOT_SET");
    PARAM("const struct IUnknown *", "IUnknown", "pData", ParamAnnot::_IN_, 1, true, sizeof(const struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    METHOD_END("HRESULT", "SetPrivateDataInterface");
    METHOD_BEGIN("D3D_FEATURE_LEVEL", "GetFeatureLevel");
    METHOD_END("D3D_FEATURE_LEVEL", "GetFeatureLevel");
    METHOD_BEGIN("UINT", "GetCreationFlags");
    METHOD_END("UINT", "GetCreationFlags");
    METHOD_BEGIN("HRESULT", "GetDeviceRemovedReason");
    METHOD_END("HRESULT", "GetDeviceRemovedReason");
    METHOD_BEGIN("void", "GetImmediateContext");
    PARAM("ID3D11DeviceContext **", "ID3D11DeviceContext", "ppImmediateContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext **), sizeof(ID3D11DeviceContext), "NOT_SET");
    METHOD_END("void", "GetImmediateContext");
    METHOD_BEGIN("HRESULT", "SetExceptionMode");
    PARAM("UINT", "UINT", "RaiseFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetExceptionMode");
    METHOD_BEGIN("UINT", "GetExceptionMode");
    METHOD_END("UINT", "GetExceptionMode");
    CLASS_END("ID3D11Device");
    CLASS_BEGIN("ID3D11Debug");
    METHOD_BEGIN("HRESULT", "SetFeatureMask");
    PARAM("UINT", "UINT", "Mask", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetFeatureMask");
    METHOD_BEGIN("UINT", "GetFeatureMask");
    METHOD_END("UINT", "GetFeatureMask");
    METHOD_BEGIN("HRESULT", "SetPresentPerRenderOpDelay");
    PARAM("UINT", "UINT", "Milliseconds", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetPresentPerRenderOpDelay");
    METHOD_BEGIN("UINT", "GetPresentPerRenderOpDelay");
    METHOD_END("UINT", "GetPresentPerRenderOpDelay");
    METHOD_BEGIN("HRESULT", "SetSwapChain");
    PARAM("IDXGISwapChain *", "IDXGISwapChain", "pSwapChain", ParamAnnot::_IN_, 1, true, sizeof(IDXGISwapChain *), sizeof(IDXGISwapChain), "NOT_SET");
    METHOD_END("HRESULT", "SetSwapChain");
    METHOD_BEGIN("HRESULT", "GetSwapChain");
    PARAM("IDXGISwapChain **", "IDXGISwapChain", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain **), sizeof(IDXGISwapChain), "NOT_SET");
    METHOD_END("HRESULT", "GetSwapChain");
    METHOD_BEGIN("HRESULT", "ValidateContext");
    PARAM("ID3D11DeviceContext *", "ID3D11DeviceContext", "pContext", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DeviceContext *), sizeof(ID3D11DeviceContext), "NOT_SET");
    METHOD_END("HRESULT", "ValidateContext");
    METHOD_BEGIN("HRESULT", "ReportLiveDeviceObjects");
    PARAM("D3D11_RLDO_FLAGS", "D3D11_RLDO_FLAGS", "Flags", ParamAnnot::_IN_, 0, false, sizeof(D3D11_RLDO_FLAGS), sizeof(D3D11_RLDO_FLAGS), "NOT_SET");
    METHOD_END("HRESULT", "ReportLiveDeviceObjects");
    METHOD_BEGIN("HRESULT", "ValidateContextForDispatch");
    PARAM("ID3D11DeviceContext *", "ID3D11DeviceContext", "pContext", ParamAnnot::_IN_, 1, true, sizeof(ID3D11DeviceContext *), sizeof(ID3D11DeviceContext), "NOT_SET");
    METHOD_END("HRESULT", "ValidateContextForDispatch");
    CLASS_END("ID3D11Debug");
    CLASS_BEGIN("ID3D11SwitchToRef");
    METHOD_BEGIN("BOOL", "SetUseRef");
    PARAM("BOOL", "BOOL", "UseRef", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("BOOL", "SetUseRef");
    METHOD_BEGIN("BOOL", "GetUseRef");
    METHOD_END("BOOL", "GetUseRef");
    CLASS_END("ID3D11SwitchToRef");
    CLASS_BEGIN("ID3D11TracingDevice");
    METHOD_BEGIN("HRESULT", "SetShaderTrackingOptionsByType");
    PARAM("UINT", "UINT", "ResourceTypeFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Options", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetShaderTrackingOptionsByType");
    METHOD_BEGIN("HRESULT", "SetShaderTrackingOptions");
    PARAM("struct IUnknown *", "IUnknown", "pShader", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("UINT", "UINT", "Options", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetShaderTrackingOptions");
    CLASS_END("ID3D11TracingDevice");
    CLASS_BEGIN("ID3D11RefTrackingOptions");
    METHOD_BEGIN("HRESULT", "SetTrackingOptions");
    PARAM("UINT", "UINT", "uOptions", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetTrackingOptions");
    CLASS_END("ID3D11RefTrackingOptions");
    CLASS_BEGIN("ID3D11RefDefaultTrackingOptions");
    METHOD_BEGIN("HRESULT", "SetTrackingOptions");
    PARAM("UINT", "UINT", "ResourceTypeFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Options", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetTrackingOptions");
    CLASS_END("ID3D11RefDefaultTrackingOptions");
    CLASS_BEGIN("ID3D11InfoQueue");
    METHOD_BEGIN("HRESULT", "SetMessageCountLimit");
    PARAM("UINT64", "UINT64", "MessageCountLimit", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "SetMessageCountLimit");
    METHOD_BEGIN("void", "ClearStoredMessages");
    METHOD_END("void", "ClearStoredMessages");
    METHOD_BEGIN("HRESULT", "GetMessageW");
    PARAM("UINT64", "UINT64", "MessageIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    PARAM("D3D11_MESSAGE *", "D3D11_MESSAGE", "pMessage", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(D3D11_MESSAGE *), sizeof(D3D11_MESSAGE), "pMessageByteLength");
    PARAM("SIZE_T *", "SIZE_T", "pMessageByteLength", ParamAnnot::_INOUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    METHOD_END("HRESULT", "GetMessageW");
    METHOD_BEGIN("UINT64", "GetNumMessagesAllowedByStorageFilter");
    METHOD_END("UINT64", "GetNumMessagesAllowedByStorageFilter");
    METHOD_BEGIN("UINT64", "GetNumMessagesDeniedByStorageFilter");
    METHOD_END("UINT64", "GetNumMessagesDeniedByStorageFilter");
    METHOD_BEGIN("UINT64", "GetNumStoredMessages");
    METHOD_END("UINT64", "GetNumStoredMessages");
    METHOD_BEGIN("UINT64", "GetNumStoredMessagesAllowedByRetrievalFilter");
    METHOD_END("UINT64", "GetNumStoredMessagesAllowedByRetrievalFilter");
    METHOD_BEGIN("UINT64", "GetNumMessagesDiscardedByMessageCountLimit");
    METHOD_END("UINT64", "GetNumMessagesDiscardedByMessageCountLimit");
    METHOD_BEGIN("UINT64", "GetMessageCountLimit");
    METHOD_END("UINT64", "GetMessageCountLimit");
    METHOD_BEGIN("HRESULT", "AddStorageFilterEntries");
    PARAM("D3D11_INFO_QUEUE_FILTER *", "D3D11_INFO_QUEUE_FILTER", "pFilter", ParamAnnot::_IN_, 1, false, sizeof(D3D11_INFO_QUEUE_FILTER *), sizeof(D3D11_INFO_QUEUE_FILTER), "NOT_SET");
    METHOD_END("HRESULT", "AddStorageFilterEntries");
    METHOD_BEGIN("HRESULT", "GetStorageFilter");
    PARAM("D3D11_INFO_QUEUE_FILTER *", "D3D11_INFO_QUEUE_FILTER", "pFilter", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(D3D11_INFO_QUEUE_FILTER *), sizeof(D3D11_INFO_QUEUE_FILTER), "pFilterByteLength");
    PARAM("SIZE_T *", "SIZE_T", "pFilterByteLength", ParamAnnot::_INOUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    METHOD_END("HRESULT", "GetStorageFilter");
    METHOD_BEGIN("void", "ClearStorageFilter");
    METHOD_END("void", "ClearStorageFilter");
    METHOD_BEGIN("HRESULT", "PushEmptyStorageFilter");
    METHOD_END("HRESULT", "PushEmptyStorageFilter");
    METHOD_BEGIN("HRESULT", "PushCopyOfStorageFilter");
    METHOD_END("HRESULT", "PushCopyOfStorageFilter");
    METHOD_BEGIN("HRESULT", "PushStorageFilter");
    PARAM("D3D11_INFO_QUEUE_FILTER *", "D3D11_INFO_QUEUE_FILTER", "pFilter", ParamAnnot::_IN_, 1, false, sizeof(D3D11_INFO_QUEUE_FILTER *), sizeof(D3D11_INFO_QUEUE_FILTER), "NOT_SET");
    METHOD_END("HRESULT", "PushStorageFilter");
    METHOD_BEGIN("void", "PopStorageFilter");
    METHOD_END("void", "PopStorageFilter");
    METHOD_BEGIN("UINT", "GetStorageFilterStackSize");
    METHOD_END("UINT", "GetStorageFilterStackSize");
    METHOD_BEGIN("HRESULT", "AddRetrievalFilterEntries");
    PARAM("D3D11_INFO_QUEUE_FILTER *", "D3D11_INFO_QUEUE_FILTER", "pFilter", ParamAnnot::_IN_, 1, false, sizeof(D3D11_INFO_QUEUE_FILTER *), sizeof(D3D11_INFO_QUEUE_FILTER), "NOT_SET");
    METHOD_END("HRESULT", "AddRetrievalFilterEntries");
    METHOD_BEGIN("HRESULT", "GetRetrievalFilter");
    PARAM("D3D11_INFO_QUEUE_FILTER *", "D3D11_INFO_QUEUE_FILTER", "pFilter", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(D3D11_INFO_QUEUE_FILTER *), sizeof(D3D11_INFO_QUEUE_FILTER), "pFilterByteLength");
    PARAM("SIZE_T *", "SIZE_T", "pFilterByteLength", ParamAnnot::_INOUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    METHOD_END("HRESULT", "GetRetrievalFilter");
    METHOD_BEGIN("void", "ClearRetrievalFilter");
    METHOD_END("void", "ClearRetrievalFilter");
    METHOD_BEGIN("HRESULT", "PushEmptyRetrievalFilter");
    METHOD_END("HRESULT", "PushEmptyRetrievalFilter");
    METHOD_BEGIN("HRESULT", "PushCopyOfRetrievalFilter");
    METHOD_END("HRESULT", "PushCopyOfRetrievalFilter");
    METHOD_BEGIN("HRESULT", "PushRetrievalFilter");
    PARAM("D3D11_INFO_QUEUE_FILTER *", "D3D11_INFO_QUEUE_FILTER", "pFilter", ParamAnnot::_IN_, 1, false, sizeof(D3D11_INFO_QUEUE_FILTER *), sizeof(D3D11_INFO_QUEUE_FILTER), "NOT_SET");
    METHOD_END("HRESULT", "PushRetrievalFilter");
    METHOD_BEGIN("void", "PopRetrievalFilter");
    METHOD_END("void", "PopRetrievalFilter");
    METHOD_BEGIN("UINT", "GetRetrievalFilterStackSize");
    METHOD_END("UINT", "GetRetrievalFilterStackSize");
    METHOD_BEGIN("HRESULT", "AddMessage");
    PARAM("D3D11_MESSAGE_CATEGORY", "D3D11_MESSAGE_CATEGORY", "Category", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_CATEGORY), sizeof(D3D11_MESSAGE_CATEGORY), "NOT_SET");
    PARAM("D3D11_MESSAGE_SEVERITY", "D3D11_MESSAGE_SEVERITY", "Severity", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_SEVERITY), sizeof(D3D11_MESSAGE_SEVERITY), "NOT_SET");
    PARAM("D3D11_MESSAGE_ID", "D3D11_MESSAGE_ID", "ID", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_ID), sizeof(D3D11_MESSAGE_ID), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pDescription", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("HRESULT", "AddMessage");
    METHOD_BEGIN("HRESULT", "AddApplicationMessage");
    PARAM("D3D11_MESSAGE_SEVERITY", "D3D11_MESSAGE_SEVERITY", "Severity", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_SEVERITY), sizeof(D3D11_MESSAGE_SEVERITY), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pDescription", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("HRESULT", "AddApplicationMessage");
    METHOD_BEGIN("HRESULT", "SetBreakOnCategory");
    PARAM("D3D11_MESSAGE_CATEGORY", "D3D11_MESSAGE_CATEGORY", "Category", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_CATEGORY), sizeof(D3D11_MESSAGE_CATEGORY), "NOT_SET");
    PARAM("BOOL", "BOOL", "bEnable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "SetBreakOnCategory");
    METHOD_BEGIN("HRESULT", "SetBreakOnSeverity");
    PARAM("D3D11_MESSAGE_SEVERITY", "D3D11_MESSAGE_SEVERITY", "Severity", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_SEVERITY), sizeof(D3D11_MESSAGE_SEVERITY), "NOT_SET");
    PARAM("BOOL", "BOOL", "bEnable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "SetBreakOnSeverity");
    METHOD_BEGIN("HRESULT", "SetBreakOnID");
    PARAM("D3D11_MESSAGE_ID", "D3D11_MESSAGE_ID", "ID", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_ID), sizeof(D3D11_MESSAGE_ID), "NOT_SET");
    PARAM("BOOL", "BOOL", "bEnable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "SetBreakOnID");
    METHOD_BEGIN("BOOL", "GetBreakOnCategory");
    PARAM("D3D11_MESSAGE_CATEGORY", "D3D11_MESSAGE_CATEGORY", "Category", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_CATEGORY), sizeof(D3D11_MESSAGE_CATEGORY), "NOT_SET");
    METHOD_END("BOOL", "GetBreakOnCategory");
    METHOD_BEGIN("BOOL", "GetBreakOnSeverity");
    PARAM("D3D11_MESSAGE_SEVERITY", "D3D11_MESSAGE_SEVERITY", "Severity", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_SEVERITY), sizeof(D3D11_MESSAGE_SEVERITY), "NOT_SET");
    METHOD_END("BOOL", "GetBreakOnSeverity");
    METHOD_BEGIN("BOOL", "GetBreakOnID");
    PARAM("D3D11_MESSAGE_ID", "D3D11_MESSAGE_ID", "ID", ParamAnnot::_IN_, 0, false, sizeof(D3D11_MESSAGE_ID), sizeof(D3D11_MESSAGE_ID), "NOT_SET");
    METHOD_END("BOOL", "GetBreakOnID");
    METHOD_BEGIN("void", "SetMuteDebugOutput");
    PARAM("BOOL", "BOOL", "bMute", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "SetMuteDebugOutput");
    METHOD_BEGIN("BOOL", "GetMuteDebugOutput");
    METHOD_END("BOOL", "GetMuteDebugOutput");
    CLASS_END("ID3D11InfoQueue");
    CLASS_BEGIN("ID3DDeviceContextState");
    CLASS_END("ID3DDeviceContextState");
    CLASS_BEGIN("IDXGIDisplayControl");
    METHOD_BEGIN("BOOL", "IsStereoEnabled");
    METHOD_END("BOOL", "IsStereoEnabled");
    METHOD_BEGIN("void", "SetStereoEnabled");
    PARAM("BOOL", "BOOL", "enabled", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "SetStereoEnabled");
    CLASS_END("IDXGIDisplayControl");
    CLASS_BEGIN("IDXGIOutputDuplication");
    METHOD_BEGIN("void", "GetDesc");
    PARAM("DXGI_OUTDUPL_DESC *", "DXGI_OUTDUPL_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_OUTDUPL_DESC *), sizeof(DXGI_OUTDUPL_DESC), "NOT_SET");
    METHOD_END("void", "GetDesc");
    METHOD_BEGIN("HRESULT", "AcquireNextFrame");
    PARAM("UINT", "UINT", "TimeoutInMilliseconds", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_OUTDUPL_FRAME_INFO *", "DXGI_OUTDUPL_FRAME_INFO", "pFrameInfo", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_OUTDUPL_FRAME_INFO *), sizeof(DXGI_OUTDUPL_FRAME_INFO), "NOT_SET");
    PARAM("IDXGIResource **", "IDXGIResource", "ppDesktopResource", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIResource **), sizeof(IDXGIResource), "NOT_SET");
    METHOD_END("HRESULT", "AcquireNextFrame");
    METHOD_BEGIN("HRESULT", "GetFrameDirtyRects");
    PARAM("UINT", "UINT", "DirtyRectsBufferSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("RECT *", "RECT", "pDirtyRectsBuffer", ParamAnnot::_IN_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    PARAM("UINT *", "UINT", "pDirtyRectsBufferSizeRequired", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetFrameDirtyRects");
    METHOD_BEGIN("HRESULT", "GetFrameMoveRects");
    PARAM("UINT", "UINT", "MoveRectsBufferSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_OUTDUPL_MOVE_RECT *", "DXGI_OUTDUPL_MOVE_RECT", "pMoveRectBuffer", ParamAnnot::_IN_, 1, false, sizeof(DXGI_OUTDUPL_MOVE_RECT *), sizeof(DXGI_OUTDUPL_MOVE_RECT), "NOT_SET");
    PARAM("UINT *", "UINT", "pMoveRectsBufferSizeRequired", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetFrameMoveRects");
    METHOD_BEGIN("HRESULT", "GetFramePointerShape");
    PARAM("UINT", "UINT", "PointerShapeBufferSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pPointerShapeBuffer", ParamAnnot::_IN_, 1, false, sizeof(void *), 0, "NOT_SET");
    PARAM("UINT *", "UINT", "pPointerShapeBufferSizeRequired", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_OUTDUPL_POINTER_SHAPE_INFO *", "DXGI_OUTDUPL_POINTER_SHAPE_INFO", "pPointerShapeInfo", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_OUTDUPL_POINTER_SHAPE_INFO *), sizeof(DXGI_OUTDUPL_POINTER_SHAPE_INFO), "NOT_SET");
    METHOD_END("HRESULT", "GetFramePointerShape");
    METHOD_BEGIN("HRESULT", "MapDesktopSurface");
    PARAM("DXGI_MAPPED_RECT *", "DXGI_MAPPED_RECT", "pLockedRect", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_MAPPED_RECT *), sizeof(DXGI_MAPPED_RECT), "NOT_SET");
    METHOD_END("HRESULT", "MapDesktopSurface");
    METHOD_BEGIN("HRESULT", "UnMapDesktopSurface");
    METHOD_END("HRESULT", "UnMapDesktopSurface");
    METHOD_BEGIN("HRESULT", "ReleaseFrame");
    METHOD_END("HRESULT", "ReleaseFrame");
    CLASS_END("IDXGIOutputDuplication");
    CLASS_BEGIN("IDXGISurface2");
    METHOD_BEGIN("HRESULT", "GetResource");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppParentResource", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    PARAM("UINT *", "UINT", "pSubresourceIndex", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetResource");
    CLASS_END("IDXGISurface2");
    CLASS_BEGIN("IDXGIResource1");
    METHOD_BEGIN("HRESULT", "CreateSubresourceSurface");
    PARAM("UINT", "UINT", "index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGISurface2 **", "IDXGISurface2", "ppSurface", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISurface2 **), sizeof(IDXGISurface2), "NOT_SET");
    METHOD_END("HRESULT", "CreateSubresourceSurface");
    METHOD_BEGIN("HRESULT", "CreateSharedHandle");
    PARAM("const SECURITY_ATTRIBUTES *", "SECURITY_ATTRIBUTES", "pAttributes", ParamAnnot::_IN_, 1, false, sizeof(const SECURITY_ATTRIBUTES *), sizeof(SECURITY_ATTRIBUTES), "NOT_SET");
    PARAM("DWORD", "DWORD", "dwAccess", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    PARAM("LPCWSTR", "LPCWSTR", "lpName", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("HANDLE *", "HANDLE", "pHandle", ParamAnnot::_OUT_, 1, false, sizeof(HANDLE *), sizeof(HANDLE), "NOT_SET");
    METHOD_END("HRESULT", "CreateSharedHandle");
    CLASS_END("IDXGIResource1");
    CLASS_BEGIN("IDXGIDevice2");
    METHOD_BEGIN("HRESULT", "OfferResources");
    PARAM("UINT", "UINT", "NumResources", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIResource *const *", "IDXGIResource", "ppResources", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(IDXGIResource *const *), sizeof(IDXGIResource), "NumResources");
    PARAM("DXGI_OFFER_RESOURCE_PRIORITY", "DXGI_OFFER_RESOURCE_PRIORITY", "Priority", ParamAnnot::_IN_, 0, false, sizeof(DXGI_OFFER_RESOURCE_PRIORITY), sizeof(DXGI_OFFER_RESOURCE_PRIORITY), "NOT_SET");
    METHOD_END("HRESULT", "OfferResources");
    METHOD_BEGIN("HRESULT", "ReclaimResources");
    PARAM("UINT", "UINT", "NumResources", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIResource *const *", "IDXGIResource", "ppResources", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(IDXGIResource *const *), sizeof(IDXGIResource), "NumResources");
    PARAM("BOOL *", "BOOL", "pDiscarded", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NumResources");
    METHOD_END("HRESULT", "ReclaimResources");
    METHOD_BEGIN("HRESULT", "EnqueueSetEvent");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    METHOD_END("HRESULT", "EnqueueSetEvent");
    CLASS_END("IDXGIDevice2");
    CLASS_BEGIN("IDXGISwapChain1");
    METHOD_BEGIN("HRESULT", "GetDesc1");
    PARAM("DXGI_SWAP_CHAIN_DESC1 *", "DXGI_SWAP_CHAIN_DESC1", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_SWAP_CHAIN_DESC1 *), sizeof(DXGI_SWAP_CHAIN_DESC1), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc1");
    METHOD_BEGIN("HRESULT", "GetFullscreenDesc");
    PARAM("DXGI_SWAP_CHAIN_FULLSCREEN_DESC *", "DXGI_SWAP_CHAIN_FULLSCREEN_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_SWAP_CHAIN_FULLSCREEN_DESC *), sizeof(DXGI_SWAP_CHAIN_FULLSCREEN_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetFullscreenDesc");
    METHOD_BEGIN("HRESULT", "GetHwnd");
    PARAM("HWND *", "HWND", "pHwnd", ParamAnnot::_OUT_, 1, false, sizeof(HWND *), sizeof(HWND), "NOT_SET");
    METHOD_END("HRESULT", "GetHwnd");
    METHOD_BEGIN("HRESULT", "GetCoreWindow");
    PARAM("const IID &", "IID", "refiid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppUnk", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "GetCoreWindow");
    METHOD_BEGIN("HRESULT", "Present1");
    PARAM("UINT", "UINT", "SyncInterval", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "PresentFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const DXGI_PRESENT_PARAMETERS *", "DXGI_PRESENT_PARAMETERS", "pPresentParameters", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_PRESENT_PARAMETERS *), sizeof(DXGI_PRESENT_PARAMETERS), "NOT_SET");
    METHOD_END("HRESULT", "Present1");
    METHOD_BEGIN("BOOL", "IsTemporaryMonoSupported");
    METHOD_END("BOOL", "IsTemporaryMonoSupported");
    METHOD_BEGIN("HRESULT", "GetRestrictToOutput");
    PARAM("IDXGIOutput **", "IDXGIOutput", "ppRestrictToOutput", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIOutput **), sizeof(IDXGIOutput), "NOT_SET");
    METHOD_END("HRESULT", "GetRestrictToOutput");
    METHOD_BEGIN("HRESULT", "SetBackgroundColor");
    PARAM("const DXGI_RGBA *", "DXGI_RGBA", "pColor", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RGBA *), sizeof(DXGI_RGBA), "NOT_SET");
    METHOD_END("HRESULT", "SetBackgroundColor");
    METHOD_BEGIN("HRESULT", "GetBackgroundColor");
    PARAM("DXGI_RGBA *", "DXGI_RGBA", "pColor", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_RGBA *), sizeof(DXGI_RGBA), "NOT_SET");
    METHOD_END("HRESULT", "GetBackgroundColor");
    METHOD_BEGIN("HRESULT", "SetRotation");
    PARAM("DXGI_MODE_ROTATION", "DXGI_MODE_ROTATION", "Rotation", ParamAnnot::_IN_, 0, false, sizeof(DXGI_MODE_ROTATION), sizeof(DXGI_MODE_ROTATION), "NOT_SET");
    METHOD_END("HRESULT", "SetRotation");
    METHOD_BEGIN("HRESULT", "GetRotation");
    PARAM("DXGI_MODE_ROTATION *", "DXGI_MODE_ROTATION", "pRotation", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_MODE_ROTATION *), sizeof(DXGI_MODE_ROTATION), "NOT_SET");
    METHOD_END("HRESULT", "GetRotation");
    CLASS_END("IDXGISwapChain1");
    CLASS_BEGIN("IDXGIFactory2");
    METHOD_BEGIN("BOOL", "IsWindowedStereoEnabled");
    METHOD_END("BOOL", "IsWindowedStereoEnabled");
    METHOD_BEGIN("HRESULT", "CreateSwapChainForHwnd");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("HWND", "HWND", "hWnd", ParamAnnot::_IN_, 0, false, sizeof(HWND), sizeof(HWND), "NOT_SET");
    PARAM("const DXGI_SWAP_CHAIN_DESC1 *", "DXGI_SWAP_CHAIN_DESC1", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SWAP_CHAIN_DESC1 *), sizeof(DXGI_SWAP_CHAIN_DESC1), "NOT_SET");
    PARAM("const DXGI_SWAP_CHAIN_FULLSCREEN_DESC *", "DXGI_SWAP_CHAIN_FULLSCREEN_DESC", "pFullscreenDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SWAP_CHAIN_FULLSCREEN_DESC *), sizeof(DXGI_SWAP_CHAIN_FULLSCREEN_DESC), "NOT_SET");
    PARAM("IDXGIOutput *", "IDXGIOutput", "pRestrictToOutput", ParamAnnot::_IN_, 1, true, sizeof(IDXGIOutput *), sizeof(IDXGIOutput), "NOT_SET");
    PARAM("IDXGISwapChain1 **", "IDXGISwapChain1", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain1 **), sizeof(IDXGISwapChain1), "NOT_SET");
    METHOD_END("HRESULT", "CreateSwapChainForHwnd");
    METHOD_BEGIN("HRESULT", "CreateSwapChainForCoreWindow");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("struct IUnknown *", "IUnknown", "pWindow", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("const DXGI_SWAP_CHAIN_DESC1 *", "DXGI_SWAP_CHAIN_DESC1", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SWAP_CHAIN_DESC1 *), sizeof(DXGI_SWAP_CHAIN_DESC1), "NOT_SET");
    PARAM("IDXGIOutput *", "IDXGIOutput", "pRestrictToOutput", ParamAnnot::_IN_, 1, true, sizeof(IDXGIOutput *), sizeof(IDXGIOutput), "NOT_SET");
    PARAM("IDXGISwapChain1 **", "IDXGISwapChain1", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain1 **), sizeof(IDXGISwapChain1), "NOT_SET");
    METHOD_END("HRESULT", "CreateSwapChainForCoreWindow");
    METHOD_BEGIN("HRESULT", "GetSharedResourceAdapterLuid");
    PARAM("HANDLE", "HANDLE", "hResource", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("LUID *", "LUID", "pLuid", ParamAnnot::_OUT_, 1, false, sizeof(LUID *), sizeof(LUID), "NOT_SET");
    METHOD_END("HRESULT", "GetSharedResourceAdapterLuid");
    METHOD_BEGIN("HRESULT", "RegisterStereoStatusWindow");
    PARAM("HWND", "HWND", "WindowHandle", ParamAnnot::_IN_, 0, false, sizeof(HWND), sizeof(HWND), "NOT_SET");
    PARAM("UINT", "UINT", "wMsg", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterStereoStatusWindow");
    METHOD_BEGIN("HRESULT", "RegisterStereoStatusEvent");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterStereoStatusEvent");
    METHOD_BEGIN("void", "UnregisterStereoStatus");
    PARAM("DWORD", "DWORD", "dwCookie", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    METHOD_END("void", "UnregisterStereoStatus");
    METHOD_BEGIN("HRESULT", "RegisterOcclusionStatusWindow");
    PARAM("HWND", "HWND", "WindowHandle", ParamAnnot::_IN_, 0, false, sizeof(HWND), sizeof(HWND), "NOT_SET");
    PARAM("UINT", "UINT", "wMsg", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterOcclusionStatusWindow");
    METHOD_BEGIN("HRESULT", "RegisterOcclusionStatusEvent");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterOcclusionStatusEvent");
    METHOD_BEGIN("void", "UnregisterOcclusionStatus");
    PARAM("DWORD", "DWORD", "dwCookie", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    METHOD_END("void", "UnregisterOcclusionStatus");
    METHOD_BEGIN("HRESULT", "CreateSwapChainForComposition");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("const DXGI_SWAP_CHAIN_DESC1 *", "DXGI_SWAP_CHAIN_DESC1", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SWAP_CHAIN_DESC1 *), sizeof(DXGI_SWAP_CHAIN_DESC1), "NOT_SET");
    PARAM("IDXGIOutput *", "IDXGIOutput", "pRestrictToOutput", ParamAnnot::_IN_, 1, true, sizeof(IDXGIOutput *), sizeof(IDXGIOutput), "NOT_SET");
    PARAM("IDXGISwapChain1 **", "IDXGISwapChain1", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain1 **), sizeof(IDXGISwapChain1), "NOT_SET");
    METHOD_END("HRESULT", "CreateSwapChainForComposition");
    CLASS_END("IDXGIFactory2");
    CLASS_BEGIN("IDXGIAdapter2");
    METHOD_BEGIN("HRESULT", "GetDesc2");
    PARAM("DXGI_ADAPTER_DESC2 *", "DXGI_ADAPTER_DESC2", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_ADAPTER_DESC2 *), sizeof(DXGI_ADAPTER_DESC2), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc2");
    CLASS_END("IDXGIAdapter2");
    CLASS_BEGIN("IDXGIOutput1");
    METHOD_BEGIN("HRESULT", "GetDisplayModeList1");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "EnumFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pNumModes", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_MODE_DESC1 *", "DXGI_MODE_DESC1", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(DXGI_MODE_DESC1 *), sizeof(DXGI_MODE_DESC1), "NOT_SET");
    METHOD_END("HRESULT", "GetDisplayModeList1");
    METHOD_BEGIN("HRESULT", "FindClosestMatchingMode1");
    PARAM("const DXGI_MODE_DESC1 *", "DXGI_MODE_DESC1", "pModeToMatch", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_MODE_DESC1 *), sizeof(DXGI_MODE_DESC1), "NOT_SET");
    PARAM("DXGI_MODE_DESC1 *", "DXGI_MODE_DESC1", "pClosestMatch", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_MODE_DESC1 *), sizeof(DXGI_MODE_DESC1), "NOT_SET");
    PARAM("struct IUnknown *", "IUnknown", "pConcernedDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    METHOD_END("HRESULT", "FindClosestMatchingMode1");
    METHOD_BEGIN("HRESULT", "GetDisplaySurfaceData1");
    PARAM("IDXGIResource *", "IDXGIResource", "pDestination", ParamAnnot::_IN_, 1, true, sizeof(IDXGIResource *), sizeof(IDXGIResource), "NOT_SET");
    METHOD_END("HRESULT", "GetDisplaySurfaceData1");
    METHOD_BEGIN("HRESULT", "DuplicateOutput");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("IDXGIOutputDuplication **", "IDXGIOutputDuplication", "ppOutputDuplication", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIOutputDuplication **), sizeof(IDXGIOutputDuplication), "NOT_SET");
    METHOD_END("HRESULT", "DuplicateOutput");
    CLASS_END("IDXGIOutput1");
    CLASS_BEGIN("ID3D11BlendState1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_BLEND_DESC1 *", "D3D11_BLEND_DESC1", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_BLEND_DESC1 *), sizeof(D3D11_BLEND_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11BlendState1");
    CLASS_BEGIN("ID3D11RasterizerState1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_RASTERIZER_DESC1 *", "D3D11_RASTERIZER_DESC1", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_RASTERIZER_DESC1 *), sizeof(D3D11_RASTERIZER_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11RasterizerState1");
    CLASS_BEGIN("ID3D11DeviceContext1");
    METHOD_BEGIN("void", "CopySubresourceRegion1");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "DstSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstX", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstY", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstZ", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pSrcResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "SrcSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_BOX *", "D3D11_BOX", "pSrcBox", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BOX *), sizeof(D3D11_BOX), "NOT_SET");
    PARAM("UINT", "UINT", "CopyFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "CopySubresourceRegion1");
    METHOD_BEGIN("void", "UpdateSubresource1");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "DstSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_BOX *", "D3D11_BOX", "pDstBox", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BOX *), sizeof(D3D11_BOX), "NOT_SET");
    PARAM("const void *", "void", "pSrcData", ParamAnnot::_IN_, 1, false, sizeof(const void *), 0, "NOT_SET");
    PARAM("UINT", "UINT", "SrcRowPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SrcDepthPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "CopyFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "UpdateSubresource1");
    METHOD_BEGIN("void", "DiscardResource");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    METHOD_END("void", "DiscardResource");
    METHOD_BEGIN("void", "DiscardView");
    PARAM("ID3D11View *", "ID3D11View", "pResourceView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11View *), sizeof(ID3D11View), "NOT_SET");
    METHOD_END("void", "DiscardView");
    METHOD_BEGIN("void", "VSSetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pFirstConstant", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pNumConstants", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "VSSetConstantBuffers1");
    METHOD_BEGIN("void", "HSSetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pFirstConstant", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pNumConstants", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "HSSetConstantBuffers1");
    METHOD_BEGIN("void", "DSSetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pFirstConstant", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pNumConstants", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "DSSetConstantBuffers1");
    METHOD_BEGIN("void", "GSSetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pFirstConstant", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pNumConstants", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "GSSetConstantBuffers1");
    METHOD_BEGIN("void", "PSSetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pFirstConstant", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pNumConstants", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "PSSetConstantBuffers1");
    METHOD_BEGIN("void", "CSSetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("const UINT *", "UINT", "pFirstConstant", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    PARAM("const UINT *", "UINT", "pNumConstants", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "CSSetConstantBuffers1");
    METHOD_BEGIN("void", "VSGetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pFirstConstant", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pNumConstants", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "VSGetConstantBuffers1");
    METHOD_BEGIN("void", "HSGetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pFirstConstant", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pNumConstants", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "HSGetConstantBuffers1");
    METHOD_BEGIN("void", "DSGetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pFirstConstant", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pNumConstants", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "DSGetConstantBuffers1");
    METHOD_BEGIN("void", "GSGetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pFirstConstant", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pNumConstants", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "GSGetConstantBuffers1");
    METHOD_BEGIN("void", "PSGetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pFirstConstant", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pNumConstants", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "PSGetConstantBuffers1");
    METHOD_BEGIN("void", "CSGetConstantBuffers1");
    PARAM("UINT", "UINT", "StartSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Buffer **", "ID3D11Buffer", "ppConstantBuffers", ParamAnnot::_OUT_ARRAY_, 2, true, sizeof(ID3D11Buffer **), sizeof(ID3D11Buffer), "NumBuffers");
    PARAM("UINT *", "UINT", "pFirstConstant", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    PARAM("UINT *", "UINT", "pNumConstants", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "NumBuffers");
    METHOD_END("void", "CSGetConstantBuffers1");
    METHOD_BEGIN("void", "SwapDeviceContextState");
    PARAM("ID3DDeviceContextState *", "ID3DDeviceContextState", "pState", ParamAnnot::_IN_, 1, true, sizeof(ID3DDeviceContextState *), sizeof(ID3DDeviceContextState), "NOT_SET");
    PARAM("ID3DDeviceContextState **", "ID3DDeviceContextState", "ppPreviousState", ParamAnnot::_OUT_, 2, true, sizeof(ID3DDeviceContextState **), sizeof(ID3DDeviceContextState), "NOT_SET");
    METHOD_END("void", "SwapDeviceContextState");
    METHOD_BEGIN("void", "ClearView");
    PARAM("ID3D11View *", "ID3D11View", "pView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11View *), sizeof(ID3D11View), "NOT_SET");
    PARAM("const FLOAT *", "FLOAT", "Color", ParamAnnot::_IN_, 1, false, sizeof(const FLOAT *), sizeof(FLOAT), "NOT_SET");
    PARAM("const D3D11_RECT *", "D3D11_RECT", "pRect", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_RECT *), sizeof(D3D11_RECT), "NumRects");
    PARAM("UINT", "UINT", "NumRects", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "ClearView");
    METHOD_BEGIN("void", "DiscardView1");
    PARAM("ID3D11View *", "ID3D11View", "pResourceView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11View *), sizeof(ID3D11View), "NOT_SET");
    PARAM("const D3D11_RECT *", "D3D11_RECT", "pRects", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_RECT *), sizeof(D3D11_RECT), "NumRects");
    PARAM("UINT", "UINT", "NumRects", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "DiscardView1");
    CLASS_END("ID3D11DeviceContext1");
    CLASS_BEGIN("ID3D11VideoContext1");
    METHOD_BEGIN("HRESULT", "SubmitDecoderBuffers1");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_BUFFER_DESC1 *", "D3D11_VIDEO_DECODER_BUFFER_DESC1", "pBufferDesc", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_VIDEO_DECODER_BUFFER_DESC1 *), sizeof(D3D11_VIDEO_DECODER_BUFFER_DESC1), "NumBuffers");
    METHOD_END("HRESULT", "SubmitDecoderBuffers1");
    METHOD_BEGIN("HRESULT", "GetDataForNewHardwareKey");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("UINT", "UINT", "PrivateInputSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pPrivatInputData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "PrivateInputSize");
    PARAM("UINT64 *", "UINT64", "pPrivateOutputData", ParamAnnot::_OUT_, 1, false, sizeof(UINT64 *), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "GetDataForNewHardwareKey");
    METHOD_BEGIN("HRESULT", "CheckCryptoSessionStatus");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("D3D11_CRYPTO_SESSION_STATUS *", "D3D11_CRYPTO_SESSION_STATUS", "pStatus", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_CRYPTO_SESSION_STATUS *), sizeof(D3D11_CRYPTO_SESSION_STATUS), "NOT_SET");
    METHOD_END("HRESULT", "CheckCryptoSessionStatus");
    METHOD_BEGIN("HRESULT", "DecoderEnableDownsampling");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "InputColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("const D3D11_VIDEO_SAMPLE_DESC *", "D3D11_VIDEO_SAMPLE_DESC", "pOutputDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_SAMPLE_DESC *), sizeof(D3D11_VIDEO_SAMPLE_DESC), "NOT_SET");
    PARAM("UINT", "UINT", "ReferenceFrameCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "DecoderEnableDownsampling");
    METHOD_BEGIN("HRESULT", "DecoderUpdateDownsampling");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("const D3D11_VIDEO_SAMPLE_DESC *", "D3D11_VIDEO_SAMPLE_DESC", "pOutputDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_SAMPLE_DESC *), sizeof(D3D11_VIDEO_SAMPLE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "DecoderUpdateDownsampling");
    METHOD_BEGIN("void", "VideoProcessorSetOutputColorSpace1");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "ColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputColorSpace1");
    METHOD_BEGIN("void", "VideoProcessorSetOutputShaderUsage");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL", "BOOL", "ShaderUsage", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetOutputShaderUsage");
    METHOD_BEGIN("void", "VideoProcessorGetOutputColorSpace1");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE *", "DXGI_COLOR_SPACE_TYPE", "pColorSpace", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_COLOR_SPACE_TYPE *), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputColorSpace1");
    METHOD_BEGIN("void", "VideoProcessorGetOutputShaderUsage");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pShaderUsage", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetOutputShaderUsage");
    METHOD_BEGIN("void", "VideoProcessorSetStreamColorSpace1");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "ColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamColorSpace1");
    METHOD_BEGIN("void", "VideoProcessorSetStreamMirror");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL", "BOOL", "Enable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL", "BOOL", "FlipHorizontal", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL", "BOOL", "FlipVertical", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorSetStreamMirror");
    METHOD_BEGIN("void", "VideoProcessorGetStreamColorSpace1");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE *", "DXGI_COLOR_SPACE_TYPE", "pColorSpace", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_COLOR_SPACE_TYPE *), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamColorSpace1");
    METHOD_BEGIN("void", "VideoProcessorGetStreamMirror");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pEnable", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pFlipHorizontal", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pFlipVertical", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "VideoProcessorGetStreamMirror");
    METHOD_BEGIN("HRESULT", "VideoProcessorGetBehaviorHints");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "OutputWidth", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "OutputHeight", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "OutputFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "StreamCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT *", "D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT", "pStreams", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT *), sizeof(D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT), "StreamCount");
    PARAM("UINT *", "UINT", "pBehaviorHints", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "VideoProcessorGetBehaviorHints");
    CLASS_END("ID3D11VideoContext1");
    CLASS_BEGIN("ID3D11VideoDevice1");
    METHOD_BEGIN("HRESULT", "GetCryptoSessionPrivateDataSize");
    PARAM("const GUID *", "GUID", "pCryptoType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("const GUID *", "GUID", "pDecoderProfile", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("const GUID *", "GUID", "pKeyExchangeType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT *", "UINT", "pPrivateInputSize", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pPrivateOutputSize", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetCryptoSessionPrivateDataSize");
    METHOD_BEGIN("HRESULT", "GetVideoDecoderCaps");
    PARAM("const GUID *", "GUID", "pDecoderProfile", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT", "UINT", "SampleWidth", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SampleHeight", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const DXGI_RATIONAL *", "DXGI_RATIONAL", "pFrameRate", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    PARAM("UINT", "UINT", "BitRate", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const GUID *", "GUID", "pCryptoType", ParamAnnot::_IN_, 1, false, sizeof(const GUID *), sizeof(GUID), "NOT_SET");
    PARAM("UINT *", "UINT", "pDecoderCaps", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetVideoDecoderCaps");
    METHOD_BEGIN("HRESULT", "CheckVideoDecoderDownsampling");
    PARAM("const D3D11_VIDEO_DECODER_DESC *", "D3D11_VIDEO_DECODER_DESC", "pInputDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_DESC *), sizeof(D3D11_VIDEO_DECODER_DESC), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "InputColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_CONFIG *", "D3D11_VIDEO_DECODER_CONFIG", "pInputConfig", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_CONFIG *), sizeof(D3D11_VIDEO_DECODER_CONFIG), "NOT_SET");
    PARAM("const DXGI_RATIONAL *", "DXGI_RATIONAL", "pFrameRate", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    PARAM("const D3D11_VIDEO_SAMPLE_DESC *", "D3D11_VIDEO_SAMPLE_DESC", "pOutputDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_SAMPLE_DESC *), sizeof(D3D11_VIDEO_SAMPLE_DESC), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pSupported", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pRealTimeHint", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "CheckVideoDecoderDownsampling");
    METHOD_BEGIN("HRESULT", "RecommendVideoDecoderDownsampleParameters");
    PARAM("const D3D11_VIDEO_DECODER_DESC *", "D3D11_VIDEO_DECODER_DESC", "pInputDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_DESC *), sizeof(D3D11_VIDEO_DECODER_DESC), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "InputColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_CONFIG *", "D3D11_VIDEO_DECODER_CONFIG", "pInputConfig", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_VIDEO_DECODER_CONFIG *), sizeof(D3D11_VIDEO_DECODER_CONFIG), "NOT_SET");
    PARAM("const DXGI_RATIONAL *", "DXGI_RATIONAL", "pFrameRate", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_RATIONAL *), sizeof(DXGI_RATIONAL), "NOT_SET");
    PARAM("D3D11_VIDEO_SAMPLE_DESC *", "D3D11_VIDEO_SAMPLE_DESC", "pRecommendedOutputDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_VIDEO_SAMPLE_DESC *), sizeof(D3D11_VIDEO_SAMPLE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "RecommendVideoDecoderDownsampleParameters");
    CLASS_END("ID3D11VideoDevice1");
    CLASS_BEGIN("ID3D11VideoProcessorEnumerator1");
    METHOD_BEGIN("HRESULT", "CheckVideoProcessorFormatConversion");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "InputFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "InputColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "OutputFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "OutputColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("BOOL *", "BOOL", "pSupported", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "CheckVideoProcessorFormatConversion");
    CLASS_END("ID3D11VideoProcessorEnumerator1");
    CLASS_BEGIN("ID3D11Device1");
    METHOD_BEGIN("void", "GetImmediateContext1");
    PARAM("ID3D11DeviceContext1 **", "ID3D11DeviceContext1", "ppImmediateContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext1 **), sizeof(ID3D11DeviceContext1), "NOT_SET");
    METHOD_END("void", "GetImmediateContext1");
    METHOD_BEGIN("HRESULT", "CreateDeferredContext1");
    PARAM("UINT", "UINT", "ContextFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11DeviceContext1 **", "ID3D11DeviceContext1", "ppDeferredContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext1 **), sizeof(ID3D11DeviceContext1), "NOT_SET");
    METHOD_END("HRESULT", "CreateDeferredContext1");
    METHOD_BEGIN("HRESULT", "CreateBlendState1");
    PARAM("const D3D11_BLEND_DESC1 *", "D3D11_BLEND_DESC1", "pBlendStateDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BLEND_DESC1 *), sizeof(D3D11_BLEND_DESC1), "NOT_SET");
    PARAM("ID3D11BlendState1 **", "ID3D11BlendState1", "ppBlendState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11BlendState1 **), sizeof(ID3D11BlendState1), "NOT_SET");
    METHOD_END("HRESULT", "CreateBlendState1");
    METHOD_BEGIN("HRESULT", "CreateRasterizerState1");
    PARAM("const D3D11_RASTERIZER_DESC1 *", "D3D11_RASTERIZER_DESC1", "pRasterizerDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_RASTERIZER_DESC1 *), sizeof(D3D11_RASTERIZER_DESC1), "NOT_SET");
    PARAM("ID3D11RasterizerState1 **", "ID3D11RasterizerState1", "ppRasterizerState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11RasterizerState1 **), sizeof(ID3D11RasterizerState1), "NOT_SET");
    METHOD_END("HRESULT", "CreateRasterizerState1");
    METHOD_BEGIN("HRESULT", "CreateDeviceContextState");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pFeatureLevels", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "FeatureLevels");
    PARAM("UINT", "UINT", "FeatureLevels", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SDKVersion", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const IID &", "IID", "EmulatedInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pChosenFeatureLevel", ParamAnnot::_OUT_, 1, false, sizeof(D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "NOT_SET");
    PARAM("ID3DDeviceContextState **", "ID3DDeviceContextState", "ppContextState", ParamAnnot::_OUT_, 2, true, sizeof(ID3DDeviceContextState **), sizeof(ID3DDeviceContextState), "NOT_SET");
    METHOD_END("HRESULT", "CreateDeviceContextState");
    METHOD_BEGIN("HRESULT", "OpenSharedResource1");
    PARAM("HANDLE", "HANDLE", "hResource", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("const IID &", "IID", "returnedInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppResource", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "OpenSharedResource1");
    METHOD_BEGIN("HRESULT", "OpenSharedResourceByName");
    PARAM("LPCWSTR", "LPCWSTR", "lpName", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("DWORD", "DWORD", "dwDesiredAccess", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    PARAM("const IID &", "IID", "returnedInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppResource", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "OpenSharedResourceByName");
    CLASS_END("ID3D11Device1");
    CLASS_BEGIN("ID3DUserDefinedAnnotation");
    METHOD_BEGIN("INT", "BeginEvent");
    PARAM("LPCWSTR", "LPCWSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    METHOD_END("INT", "BeginEvent");
    METHOD_BEGIN("INT", "EndEvent");
    METHOD_END("INT", "EndEvent");
    METHOD_BEGIN("void", "SetMarker");
    PARAM("LPCWSTR", "LPCWSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    METHOD_END("void", "SetMarker");
    METHOD_BEGIN("BOOL", "GetStatus");
    METHOD_END("BOOL", "GetStatus");
    CLASS_END("ID3DUserDefinedAnnotation");
    CLASS_BEGIN("IDXGIDevice3");
    METHOD_BEGIN("void", "Trim");
    METHOD_END("void", "Trim");
    CLASS_END("IDXGIDevice3");
    CLASS_BEGIN("IDXGISwapChain2");
    METHOD_BEGIN("HRESULT", "SetSourceSize");
    PARAM("UINT", "UINT", "Width", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Height", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetSourceSize");
    METHOD_BEGIN("HRESULT", "GetSourceSize");
    PARAM("UINT *", "UINT", "pWidth", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pHeight", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetSourceSize");
    METHOD_BEGIN("HRESULT", "SetMaximumFrameLatency");
    PARAM("UINT", "UINT", "MaxLatency", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetMaximumFrameLatency");
    METHOD_BEGIN("HRESULT", "GetMaximumFrameLatency");
    PARAM("UINT *", "UINT", "pMaxLatency", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetMaximumFrameLatency");
    METHOD_BEGIN("HANDLE", "GetFrameLatencyWaitableObject");
    METHOD_END("HANDLE", "GetFrameLatencyWaitableObject");
    METHOD_BEGIN("HRESULT", "SetMatrixTransform");
    PARAM("const DXGI_MATRIX_3X2_F *", "DXGI_MATRIX_3X2_F", "pMatrix", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_MATRIX_3X2_F *), sizeof(DXGI_MATRIX_3X2_F), "NOT_SET");
    METHOD_END("HRESULT", "SetMatrixTransform");
    METHOD_BEGIN("HRESULT", "GetMatrixTransform");
    PARAM("DXGI_MATRIX_3X2_F *", "DXGI_MATRIX_3X2_F", "pMatrix", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_MATRIX_3X2_F *), sizeof(DXGI_MATRIX_3X2_F), "NOT_SET");
    METHOD_END("HRESULT", "GetMatrixTransform");
    CLASS_END("IDXGISwapChain2");
    CLASS_BEGIN("IDXGIOutput2");
    METHOD_BEGIN("BOOL", "SupportsOverlays");
    METHOD_END("BOOL", "SupportsOverlays");
    CLASS_END("IDXGIOutput2");
    CLASS_BEGIN("IDXGIFactory3");
    METHOD_BEGIN("UINT", "GetCreationFlags");
    METHOD_END("UINT", "GetCreationFlags");
    CLASS_END("IDXGIFactory3");
    CLASS_BEGIN("IDXGIDecodeSwapChain");
    METHOD_BEGIN("HRESULT", "PresentBuffer");
    PARAM("UINT", "UINT", "BufferToPresent", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SyncInterval", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "PresentBuffer");
    METHOD_BEGIN("HRESULT", "SetSourceRect");
    PARAM("const RECT *", "RECT", "pRect", ParamAnnot::_IN_, 1, false, sizeof(const RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("HRESULT", "SetSourceRect");
    METHOD_BEGIN("HRESULT", "SetTargetRect");
    PARAM("const RECT *", "RECT", "pRect", ParamAnnot::_IN_, 1, false, sizeof(const RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("HRESULT", "SetTargetRect");
    METHOD_BEGIN("HRESULT", "SetDestSize");
    PARAM("UINT", "UINT", "Width", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Height", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetDestSize");
    METHOD_BEGIN("HRESULT", "GetSourceRect");
    PARAM("RECT *", "RECT", "pRect", ParamAnnot::_OUT_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("HRESULT", "GetSourceRect");
    METHOD_BEGIN("HRESULT", "GetTargetRect");
    PARAM("RECT *", "RECT", "pRect", ParamAnnot::_OUT_, 1, false, sizeof(RECT *), sizeof(RECT), "NOT_SET");
    METHOD_END("HRESULT", "GetTargetRect");
    METHOD_BEGIN("HRESULT", "GetDestSize");
    PARAM("UINT *", "UINT", "pWidth", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pHeight", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "GetDestSize");
    METHOD_BEGIN("HRESULT", "SetColorSpace");
    PARAM("DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS", "DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS", "ColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS), sizeof(DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS), "NOT_SET");
    METHOD_END("HRESULT", "SetColorSpace");
    METHOD_BEGIN("DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS", "GetColorSpace");
    METHOD_END("DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS", "GetColorSpace");
    CLASS_END("IDXGIDecodeSwapChain");
    CLASS_BEGIN("IDXGIFactoryMedia");
    METHOD_BEGIN("HRESULT", "CreateSwapChainForCompositionSurfaceHandle");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("HANDLE", "HANDLE", "hSurface", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("const DXGI_SWAP_CHAIN_DESC1 *", "DXGI_SWAP_CHAIN_DESC1", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SWAP_CHAIN_DESC1 *), sizeof(DXGI_SWAP_CHAIN_DESC1), "NOT_SET");
    PARAM("IDXGIOutput *", "IDXGIOutput", "pRestrictToOutput", ParamAnnot::_IN_, 1, true, sizeof(IDXGIOutput *), sizeof(IDXGIOutput), "NOT_SET");
    PARAM("IDXGISwapChain1 **", "IDXGISwapChain1", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain1 **), sizeof(IDXGISwapChain1), "NOT_SET");
    METHOD_END("HRESULT", "CreateSwapChainForCompositionSurfaceHandle");
    METHOD_BEGIN("HRESULT", "CreateDecodeSwapChainForCompositionSurfaceHandle");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("HANDLE", "HANDLE", "hSurface", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("DXGI_DECODE_SWAP_CHAIN_DESC *", "DXGI_DECODE_SWAP_CHAIN_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(DXGI_DECODE_SWAP_CHAIN_DESC *), sizeof(DXGI_DECODE_SWAP_CHAIN_DESC), "NOT_SET");
    PARAM("IDXGIResource *", "IDXGIResource", "pYuvDecodeBuffers", ParamAnnot::_IN_, 1, true, sizeof(IDXGIResource *), sizeof(IDXGIResource), "NOT_SET");
    PARAM("IDXGIOutput *", "IDXGIOutput", "pRestrictToOutput", ParamAnnot::_IN_, 1, true, sizeof(IDXGIOutput *), sizeof(IDXGIOutput), "NOT_SET");
    PARAM("IDXGIDecodeSwapChain **", "IDXGIDecodeSwapChain", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIDecodeSwapChain **), sizeof(IDXGIDecodeSwapChain), "NOT_SET");
    METHOD_END("HRESULT", "CreateDecodeSwapChainForCompositionSurfaceHandle");
    CLASS_END("IDXGIFactoryMedia");
    CLASS_BEGIN("IDXGISwapChainMedia");
    METHOD_BEGIN("HRESULT", "GetFrameStatisticsMedia");
    PARAM("DXGI_FRAME_STATISTICS_MEDIA *", "DXGI_FRAME_STATISTICS_MEDIA", "pStats", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_FRAME_STATISTICS_MEDIA *), sizeof(DXGI_FRAME_STATISTICS_MEDIA), "NOT_SET");
    METHOD_END("HRESULT", "GetFrameStatisticsMedia");
    METHOD_BEGIN("HRESULT", "SetPresentDuration");
    PARAM("UINT", "UINT", "Duration", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "SetPresentDuration");
    METHOD_BEGIN("HRESULT", "CheckPresentDurationSupport");
    PARAM("UINT", "UINT", "DesiredPresentDuration", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pClosestSmallerPresentDuration", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pClosestLargerPresentDuration", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckPresentDurationSupport");
    CLASS_END("IDXGISwapChainMedia");
    CLASS_BEGIN("IDXGIOutput3");
    METHOD_BEGIN("HRESULT", "CheckOverlaySupport");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "EnumFormat", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("struct IUnknown *", "IUnknown", "pConcernedDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("UINT *", "UINT", "pFlags", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckOverlaySupport");
    CLASS_END("IDXGIOutput3");
    CLASS_BEGIN("ID3D11DeviceContext2");
    METHOD_BEGIN("HRESULT", "UpdateTileMappings");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pTiledResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "NumTiledResourceRegions", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_TILED_RESOURCE_COORDINATE *", "D3D11_TILED_RESOURCE_COORDINATE", "pTiledResourceRegionStartCoordinates", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_TILED_RESOURCE_COORDINATE *), sizeof(D3D11_TILED_RESOURCE_COORDINATE), "NumTiledResourceRegions");
    PARAM("const D3D11_TILE_REGION_SIZE *", "D3D11_TILE_REGION_SIZE", "pTiledResourceRegionSizes", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_TILE_REGION_SIZE *), sizeof(D3D11_TILE_REGION_SIZE), "NumTiledResourceRegions");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pTilePool", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT", "UINT", "NumRanges", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const UINT *", "UINT", "pRangeFlags", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumRanges");
    PARAM("const UINT *", "UINT", "pTilePoolStartOffsets", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumRanges");
    PARAM("const UINT *", "UINT", "pRangeTileCounts", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumRanges");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "UpdateTileMappings");
    METHOD_BEGIN("HRESULT", "CopyTileMappings");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDestTiledResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_TILED_RESOURCE_COORDINATE *", "D3D11_TILED_RESOURCE_COORDINATE", "pDestRegionStartCoordinate", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILED_RESOURCE_COORDINATE *), sizeof(D3D11_TILED_RESOURCE_COORDINATE), "NOT_SET");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pSourceTiledResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_TILED_RESOURCE_COORDINATE *", "D3D11_TILED_RESOURCE_COORDINATE", "pSourceRegionStartCoordinate", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILED_RESOURCE_COORDINATE *), sizeof(D3D11_TILED_RESOURCE_COORDINATE), "NOT_SET");
    PARAM("const D3D11_TILE_REGION_SIZE *", "D3D11_TILE_REGION_SIZE", "pTileRegionSize", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILE_REGION_SIZE *), sizeof(D3D11_TILE_REGION_SIZE), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CopyTileMappings");
    METHOD_BEGIN("void", "CopyTiles");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pTiledResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_TILED_RESOURCE_COORDINATE *", "D3D11_TILED_RESOURCE_COORDINATE", "pTileRegionStartCoordinate", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILED_RESOURCE_COORDINATE *), sizeof(D3D11_TILED_RESOURCE_COORDINATE), "NOT_SET");
    PARAM("const D3D11_TILE_REGION_SIZE *", "D3D11_TILE_REGION_SIZE", "pTileRegionSize", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILE_REGION_SIZE *), sizeof(D3D11_TILE_REGION_SIZE), "NOT_SET");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pBuffer", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT64", "UINT64", "BufferStartOffsetInBytes", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "CopyTiles");
    METHOD_BEGIN("void", "UpdateTiles");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDestTiledResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_TILED_RESOURCE_COORDINATE *", "D3D11_TILED_RESOURCE_COORDINATE", "pDestTileRegionStartCoordinate", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILED_RESOURCE_COORDINATE *), sizeof(D3D11_TILED_RESOURCE_COORDINATE), "NOT_SET");
    PARAM("const D3D11_TILE_REGION_SIZE *", "D3D11_TILE_REGION_SIZE", "pDestTileRegionSize", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TILE_REGION_SIZE *), sizeof(D3D11_TILE_REGION_SIZE), "NOT_SET");
    PARAM("const void *", "void", "pSourceTileData", ParamAnnot::_IN_, 1, false, sizeof(const void *), 0, "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "UpdateTiles");
    METHOD_BEGIN("HRESULT", "ResizeTilePool");
    PARAM("ID3D11Buffer *", "ID3D11Buffer", "pTilePool", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Buffer *), sizeof(ID3D11Buffer), "NOT_SET");
    PARAM("UINT64", "UINT64", "NewSizeInBytes", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "ResizeTilePool");
    METHOD_BEGIN("void", "TiledResourceBarrier");
    PARAM("struct ID3D11DeviceChild *", "ID3D11DeviceChild", "pTiledResourceOrViewAccessBeforeBarrier", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11DeviceChild *), sizeof(ID3D11DeviceChild), "NOT_SET");
    PARAM("struct ID3D11DeviceChild *", "ID3D11DeviceChild", "pTiledResourceOrViewAccessAfterBarrier", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11DeviceChild *), sizeof(ID3D11DeviceChild), "NOT_SET");
    METHOD_END("void", "TiledResourceBarrier");
    METHOD_BEGIN("BOOL", "IsAnnotationEnabled");
    METHOD_END("BOOL", "IsAnnotationEnabled");
    METHOD_BEGIN("void", "SetMarkerInt");
    PARAM("LPCWSTR", "LPCWSTR", "pLabel", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("INT", "INT", "Data", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("void", "SetMarkerInt");
    METHOD_BEGIN("void", "BeginEventInt");
    PARAM("LPCWSTR", "LPCWSTR", "pLabel", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("INT", "INT", "Data", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("void", "BeginEventInt");
    METHOD_BEGIN("void", "EndEvent");
    METHOD_END("void", "EndEvent");
    CLASS_END("ID3D11DeviceContext2");
    CLASS_BEGIN("ID3D11Device2");
    METHOD_BEGIN("void", "GetImmediateContext2");
    PARAM("ID3D11DeviceContext2 **", "ID3D11DeviceContext2", "ppImmediateContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext2 **), sizeof(ID3D11DeviceContext2), "NOT_SET");
    METHOD_END("void", "GetImmediateContext2");
    METHOD_BEGIN("HRESULT", "CreateDeferredContext2");
    PARAM("UINT", "UINT", "ContextFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11DeviceContext2 **", "ID3D11DeviceContext2", "ppDeferredContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext2 **), sizeof(ID3D11DeviceContext2), "NOT_SET");
    METHOD_END("HRESULT", "CreateDeferredContext2");
    METHOD_BEGIN("void", "GetResourceTiling");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pTiledResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT *", "UINT", "pNumTilesForEntireResource", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_PACKED_MIP_DESC *", "D3D11_PACKED_MIP_DESC", "pPackedMipDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_PACKED_MIP_DESC *), sizeof(D3D11_PACKED_MIP_DESC), "NOT_SET");
    PARAM("D3D11_TILE_SHAPE *", "D3D11_TILE_SHAPE", "pStandardTileShapeForNonPackedMips", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_TILE_SHAPE *), sizeof(D3D11_TILE_SHAPE), "NOT_SET");
    PARAM("UINT *", "UINT", "pNumSubresourceTilings", ParamAnnot::_INOUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "FirstSubresourceTilingToGet", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_SUBRESOURCE_TILING *", "D3D11_SUBRESOURCE_TILING", "pSubresourceTilingsForNonPackedMips", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(D3D11_SUBRESOURCE_TILING *), sizeof(D3D11_SUBRESOURCE_TILING), "pNumSubresourceTilings");
    METHOD_END("void", "GetResourceTiling");
    METHOD_BEGIN("HRESULT", "CheckMultisampleQualityLevels1");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "SampleCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pNumQualityLevels", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckMultisampleQualityLevels1");
    CLASS_END("ID3D11Device2");
    CLASS_BEGIN("ID3D11Texture2D1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_TEXTURE2D_DESC1 *", "D3D11_TEXTURE2D_DESC1", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_TEXTURE2D_DESC1 *), sizeof(D3D11_TEXTURE2D_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11Texture2D1");
    CLASS_BEGIN("ID3D11Texture3D1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_TEXTURE3D_DESC1 *", "D3D11_TEXTURE3D_DESC1", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_TEXTURE3D_DESC1 *), sizeof(D3D11_TEXTURE3D_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11Texture3D1");
    CLASS_BEGIN("ID3D11RasterizerState2");
    METHOD_BEGIN("void", "GetDesc2");
    PARAM("D3D11_RASTERIZER_DESC2 *", "D3D11_RASTERIZER_DESC2", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_RASTERIZER_DESC2 *), sizeof(D3D11_RASTERIZER_DESC2), "NOT_SET");
    METHOD_END("void", "GetDesc2");
    CLASS_END("ID3D11RasterizerState2");
    CLASS_BEGIN("ID3D11ShaderResourceView1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_SHADER_RESOURCE_VIEW_DESC1 *", "D3D11_SHADER_RESOURCE_VIEW_DESC1", "pDesc1", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC1 *), sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11ShaderResourceView1");
    CLASS_BEGIN("ID3D11RenderTargetView1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_RENDER_TARGET_VIEW_DESC1 *", "D3D11_RENDER_TARGET_VIEW_DESC1", "pDesc1", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_RENDER_TARGET_VIEW_DESC1 *), sizeof(D3D11_RENDER_TARGET_VIEW_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11RenderTargetView1");
    CLASS_BEGIN("ID3D11UnorderedAccessView1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_UNORDERED_ACCESS_VIEW_DESC1 *", "D3D11_UNORDERED_ACCESS_VIEW_DESC1", "pDesc1", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC1 *), sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11UnorderedAccessView1");
    CLASS_BEGIN("ID3D11Query1");
    METHOD_BEGIN("void", "GetDesc1");
    PARAM("D3D11_QUERY_DESC1 *", "D3D11_QUERY_DESC1", "pDesc1", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_QUERY_DESC1 *), sizeof(D3D11_QUERY_DESC1), "NOT_SET");
    METHOD_END("void", "GetDesc1");
    CLASS_END("ID3D11Query1");
    CLASS_BEGIN("ID3D11DeviceContext3");
    METHOD_BEGIN("void", "Flush1");
    PARAM("D3D11_CONTEXT_TYPE", "D3D11_CONTEXT_TYPE", "ContextType", ParamAnnot::_IN_, 0, false, sizeof(D3D11_CONTEXT_TYPE), sizeof(D3D11_CONTEXT_TYPE), "NOT_SET");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    METHOD_END("void", "Flush1");
    METHOD_BEGIN("void", "SetHardwareProtectionState");
    PARAM("BOOL", "BOOL", "HwProtectionEnable", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "SetHardwareProtectionState");
    METHOD_BEGIN("void", "GetHardwareProtectionState");
    PARAM("BOOL *", "BOOL", "pHwProtectionEnable", ParamAnnot::_OUT_, 1, false, sizeof(BOOL *), sizeof(BOOL), "NOT_SET");
    METHOD_END("void", "GetHardwareProtectionState");
    CLASS_END("ID3D11DeviceContext3");
    CLASS_BEGIN("ID3D11Fence");
    METHOD_BEGIN("HRESULT", "CreateSharedHandle");
    PARAM("const SECURITY_ATTRIBUTES *", "SECURITY_ATTRIBUTES", "pAttributes", ParamAnnot::_IN_, 1, false, sizeof(const SECURITY_ATTRIBUTES *), sizeof(SECURITY_ATTRIBUTES), "NOT_SET");
    PARAM("DWORD", "DWORD", "dwAccess", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    PARAM("LPCWSTR", "LPCWSTR", "lpName", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("HANDLE *", "HANDLE", "pHandle", ParamAnnot::_OUT_, 1, false, sizeof(HANDLE *), sizeof(HANDLE), "NOT_SET");
    METHOD_END("HRESULT", "CreateSharedHandle");
    METHOD_BEGIN("UINT64", "GetCompletedValue");
    METHOD_END("UINT64", "GetCompletedValue");
    METHOD_BEGIN("HRESULT", "SetEventOnCompletion");
    PARAM("UINT64", "UINT64", "Value", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    METHOD_END("HRESULT", "SetEventOnCompletion");
    CLASS_END("ID3D11Fence");
    CLASS_BEGIN("ID3D11DeviceContext4");
    METHOD_BEGIN("HRESULT", "Signal");
    PARAM("ID3D11Fence *", "ID3D11Fence", "pFence", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Fence *), sizeof(ID3D11Fence), "NOT_SET");
    PARAM("UINT64", "UINT64", "Value", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "Signal");
    METHOD_BEGIN("HRESULT", "Wait");
    PARAM("ID3D11Fence *", "ID3D11Fence", "pFence", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Fence *), sizeof(ID3D11Fence), "NOT_SET");
    PARAM("UINT64", "UINT64", "Value", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "Wait");
    CLASS_END("ID3D11DeviceContext4");
    CLASS_BEGIN("ID3D11Device3");
    METHOD_BEGIN("HRESULT", "CreateTexture2D1");
    PARAM("const D3D11_TEXTURE2D_DESC1 *", "D3D11_TEXTURE2D_DESC1", "pDesc1", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TEXTURE2D_DESC1 *), sizeof(D3D11_TEXTURE2D_DESC1), "NOT_SET");
    PARAM("const D3D11_SUBRESOURCE_DATA *", "D3D11_SUBRESOURCE_DATA", "pInitialData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_SUBRESOURCE_DATA *), sizeof(D3D11_SUBRESOURCE_DATA), "_Inexpressible_(pDesc1->MipLevelspDesc1->ArraySize)");
    PARAM("ID3D11Texture2D1 **", "ID3D11Texture2D1", "ppTexture2D", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Texture2D1 **), sizeof(ID3D11Texture2D1), "NOT_SET");
    METHOD_END("HRESULT", "CreateTexture2D1");
    METHOD_BEGIN("HRESULT", "CreateTexture3D1");
    PARAM("const D3D11_TEXTURE3D_DESC1 *", "D3D11_TEXTURE3D_DESC1", "pDesc1", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_TEXTURE3D_DESC1 *), sizeof(D3D11_TEXTURE3D_DESC1), "NOT_SET");
    PARAM("const D3D11_SUBRESOURCE_DATA *", "D3D11_SUBRESOURCE_DATA", "pInitialData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_SUBRESOURCE_DATA *), sizeof(D3D11_SUBRESOURCE_DATA), "_Inexpressible_(pDesc1->MipLevels)");
    PARAM("ID3D11Texture3D1 **", "ID3D11Texture3D1", "ppTexture3D", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Texture3D1 **), sizeof(ID3D11Texture3D1), "NOT_SET");
    METHOD_END("HRESULT", "CreateTexture3D1");
    METHOD_BEGIN("HRESULT", "CreateRasterizerState2");
    PARAM("const D3D11_RASTERIZER_DESC2 *", "D3D11_RASTERIZER_DESC2", "pRasterizerDesc", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_RASTERIZER_DESC2 *), sizeof(D3D11_RASTERIZER_DESC2), "NOT_SET");
    PARAM("ID3D11RasterizerState2 **", "ID3D11RasterizerState2", "ppRasterizerState", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11RasterizerState2 **), sizeof(ID3D11RasterizerState2), "NOT_SET");
    METHOD_END("HRESULT", "CreateRasterizerState2");
    METHOD_BEGIN("HRESULT", "CreateShaderResourceView1");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_SHADER_RESOURCE_VIEW_DESC1 *", "D3D11_SHADER_RESOURCE_VIEW_DESC1", "pDesc1", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_SHADER_RESOURCE_VIEW_DESC1 *), sizeof(D3D11_SHADER_RESOURCE_VIEW_DESC1), "NOT_SET");
    PARAM("ID3D11ShaderResourceView1 **", "ID3D11ShaderResourceView1", "ppSRView1", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11ShaderResourceView1 **), sizeof(ID3D11ShaderResourceView1), "NOT_SET");
    METHOD_END("HRESULT", "CreateShaderResourceView1");
    METHOD_BEGIN("HRESULT", "CreateUnorderedAccessView1");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_UNORDERED_ACCESS_VIEW_DESC1 *", "D3D11_UNORDERED_ACCESS_VIEW_DESC1", "pDesc1", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_UNORDERED_ACCESS_VIEW_DESC1 *), sizeof(D3D11_UNORDERED_ACCESS_VIEW_DESC1), "NOT_SET");
    PARAM("ID3D11UnorderedAccessView1 **", "ID3D11UnorderedAccessView1", "ppUAView1", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11UnorderedAccessView1 **), sizeof(ID3D11UnorderedAccessView1), "NOT_SET");
    METHOD_END("HRESULT", "CreateUnorderedAccessView1");
    METHOD_BEGIN("HRESULT", "CreateRenderTargetView1");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("const D3D11_RENDER_TARGET_VIEW_DESC1 *", "D3D11_RENDER_TARGET_VIEW_DESC1", "pDesc1", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_RENDER_TARGET_VIEW_DESC1 *), sizeof(D3D11_RENDER_TARGET_VIEW_DESC1), "NOT_SET");
    PARAM("ID3D11RenderTargetView1 **", "ID3D11RenderTargetView1", "ppRTView1", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11RenderTargetView1 **), sizeof(ID3D11RenderTargetView1), "NOT_SET");
    METHOD_END("HRESULT", "CreateRenderTargetView1");
    METHOD_BEGIN("HRESULT", "CreateQuery1");
    PARAM("const D3D11_QUERY_DESC1 *", "D3D11_QUERY_DESC1", "pQueryDesc1", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_QUERY_DESC1 *), sizeof(D3D11_QUERY_DESC1), "NOT_SET");
    PARAM("ID3D11Query1 **", "ID3D11Query1", "ppQuery1", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Query1 **), sizeof(ID3D11Query1), "NOT_SET");
    METHOD_END("HRESULT", "CreateQuery1");
    METHOD_BEGIN("void", "GetImmediateContext3");
    PARAM("ID3D11DeviceContext3 **", "ID3D11DeviceContext3", "ppImmediateContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext3 **), sizeof(ID3D11DeviceContext3), "NOT_SET");
    METHOD_END("void", "GetImmediateContext3");
    METHOD_BEGIN("HRESULT", "CreateDeferredContext3");
    PARAM("UINT", "UINT", "ContextFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11DeviceContext3 **", "ID3D11DeviceContext3", "ppDeferredContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext3 **), sizeof(ID3D11DeviceContext3), "NOT_SET");
    METHOD_END("HRESULT", "CreateDeferredContext3");
    METHOD_BEGIN("void", "WriteToSubresource");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pDstResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "DstSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_BOX *", "D3D11_BOX", "pDstBox", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BOX *), sizeof(D3D11_BOX), "NOT_SET");
    PARAM("const void *", "void", "pSrcData", ParamAnnot::_IN_, 1, false, sizeof(const void *), 0, "NOT_SET");
    PARAM("UINT", "UINT", "SrcRowPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SrcDepthPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("void", "WriteToSubresource");
    METHOD_BEGIN("void", "ReadFromSubresource");
    PARAM("void *", "void", "pDstData", ParamAnnot::_OUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    PARAM("UINT", "UINT", "DstRowPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "DstDepthPitch", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Resource *", "ID3D11Resource", "pSrcResource", ParamAnnot::_IN_, 1, true, sizeof(ID3D11Resource *), sizeof(ID3D11Resource), "NOT_SET");
    PARAM("UINT", "UINT", "SrcSubresource", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_BOX *", "D3D11_BOX", "pSrcBox", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_BOX *), sizeof(D3D11_BOX), "NOT_SET");
    METHOD_END("void", "ReadFromSubresource");
    CLASS_END("ID3D11Device3");
    CLASS_BEGIN("IDXGISwapChain3");
    METHOD_BEGIN("UINT", "GetCurrentBackBufferIndex");
    METHOD_END("UINT", "GetCurrentBackBufferIndex");
    METHOD_BEGIN("HRESULT", "CheckColorSpaceSupport");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "ColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("UINT *", "UINT", "pColorSpaceSupport", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckColorSpaceSupport");
    METHOD_BEGIN("HRESULT", "SetColorSpace1");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "ColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    METHOD_END("HRESULT", "SetColorSpace1");
    METHOD_BEGIN("HRESULT", "ResizeBuffers1");
    PARAM("UINT", "UINT", "BufferCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Width", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Height", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("UINT", "UINT", "SwapChainFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const UINT *", "UINT", "pCreationNodeMask", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "BufferCount");
    PARAM("struct IUnknown *const *", "IUnknown", "ppPresentQueue", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(struct IUnknown *const *), sizeof(IUnknown), "BufferCount");
    METHOD_END("HRESULT", "ResizeBuffers1");
    CLASS_END("IDXGISwapChain3");
    CLASS_BEGIN("IDXGIOutput4");
    METHOD_BEGIN("HRESULT", "CheckOverlayColorSpaceSupport");
    PARAM("DXGI_FORMAT", "DXGI_FORMAT", "Format", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FORMAT), sizeof(DXGI_FORMAT), "NOT_SET");
    PARAM("DXGI_COLOR_SPACE_TYPE", "DXGI_COLOR_SPACE_TYPE", "ColorSpace", ParamAnnot::_IN_, 0, false, sizeof(DXGI_COLOR_SPACE_TYPE), sizeof(DXGI_COLOR_SPACE_TYPE), "NOT_SET");
    PARAM("struct IUnknown *", "IUnknown", "pConcernedDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("UINT *", "UINT", "pFlags", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckOverlayColorSpaceSupport");
    CLASS_END("IDXGIOutput4");
    CLASS_BEGIN("IDXGIFactory4");
    METHOD_BEGIN("HRESULT", "EnumAdapterByLuid");
    PARAM("LUID", "LUID", "AdapterLuid", ParamAnnot::_IN_, 0, false, sizeof(LUID), sizeof(LUID), "NOT_SET");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppvAdapter", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "EnumAdapterByLuid");
    METHOD_BEGIN("HRESULT", "EnumWarpAdapter");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppvAdapter", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "EnumWarpAdapter");
    CLASS_END("IDXGIFactory4");
    CLASS_BEGIN("IDXGIAdapter3");
    METHOD_BEGIN("HRESULT", "RegisterHardwareContentProtectionTeardownStatusEvent");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterHardwareContentProtectionTeardownStatusEvent");
    METHOD_BEGIN("void", "UnregisterHardwareContentProtectionTeardownStatus");
    PARAM("DWORD", "DWORD", "dwCookie", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    METHOD_END("void", "UnregisterHardwareContentProtectionTeardownStatus");
    METHOD_BEGIN("HRESULT", "QueryVideoMemoryInfo");
    PARAM("UINT", "UINT", "NodeIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_MEMORY_SEGMENT_GROUP", "DXGI_MEMORY_SEGMENT_GROUP", "MemorySegmentGroup", ParamAnnot::_IN_, 0, false, sizeof(DXGI_MEMORY_SEGMENT_GROUP), sizeof(DXGI_MEMORY_SEGMENT_GROUP), "NOT_SET");
    PARAM("DXGI_QUERY_VIDEO_MEMORY_INFO *", "DXGI_QUERY_VIDEO_MEMORY_INFO", "pVideoMemoryInfo", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_QUERY_VIDEO_MEMORY_INFO *), sizeof(DXGI_QUERY_VIDEO_MEMORY_INFO), "NOT_SET");
    METHOD_END("HRESULT", "QueryVideoMemoryInfo");
    METHOD_BEGIN("HRESULT", "SetVideoMemoryReservation");
    PARAM("UINT", "UINT", "NodeIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_MEMORY_SEGMENT_GROUP", "DXGI_MEMORY_SEGMENT_GROUP", "MemorySegmentGroup", ParamAnnot::_IN_, 0, false, sizeof(DXGI_MEMORY_SEGMENT_GROUP), sizeof(DXGI_MEMORY_SEGMENT_GROUP), "NOT_SET");
    PARAM("UINT64", "UINT64", "Reservation", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    METHOD_END("HRESULT", "SetVideoMemoryReservation");
    METHOD_BEGIN("HRESULT", "RegisterVideoMemoryBudgetChangeNotificationEvent");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterVideoMemoryBudgetChangeNotificationEvent");
    METHOD_BEGIN("void", "UnregisterVideoMemoryBudgetChangeNotification");
    PARAM("DWORD", "DWORD", "dwCookie", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    METHOD_END("void", "UnregisterVideoMemoryBudgetChangeNotification");
    CLASS_END("IDXGIAdapter3");
    CLASS_BEGIN("IDXGIOutput5");
    METHOD_BEGIN("HRESULT", "DuplicateOutput1");
    PARAM("struct IUnknown *", "IUnknown", "pDevice", ParamAnnot::_IN_, 1, true, sizeof(struct IUnknown *), sizeof(IUnknown), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SupportedFormatsCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const DXGI_FORMAT *", "DXGI_FORMAT", "pSupportedFormats", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const DXGI_FORMAT *), sizeof(DXGI_FORMAT), "SupportedFormatsCount");
    PARAM("IDXGIOutputDuplication **", "IDXGIOutputDuplication", "ppOutputDuplication", ParamAnnot::_OUT_, 2, true, sizeof(IDXGIOutputDuplication **), sizeof(IDXGIOutputDuplication), "NOT_SET");
    METHOD_END("HRESULT", "DuplicateOutput1");
    CLASS_END("IDXGIOutput5");
    CLASS_BEGIN("IDXGISwapChain4");
    METHOD_BEGIN("HRESULT", "SetHDRMetaData");
    PARAM("DXGI_HDR_METADATA_TYPE", "DXGI_HDR_METADATA_TYPE", "Type", ParamAnnot::_IN_, 0, false, sizeof(DXGI_HDR_METADATA_TYPE), sizeof(DXGI_HDR_METADATA_TYPE), "NOT_SET");
    PARAM("UINT", "UINT", "Size", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pMetaData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(void *), 0, "Size");
    METHOD_END("HRESULT", "SetHDRMetaData");
    CLASS_END("IDXGISwapChain4");
    CLASS_BEGIN("IDXGIDevice4");
    METHOD_BEGIN("HRESULT", "OfferResources1");
    PARAM("UINT", "UINT", "NumResources", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIResource *const *", "IDXGIResource", "ppResources", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(IDXGIResource *const *), sizeof(IDXGIResource), "NumResources");
    PARAM("DXGI_OFFER_RESOURCE_PRIORITY", "DXGI_OFFER_RESOURCE_PRIORITY", "Priority", ParamAnnot::_IN_, 0, false, sizeof(DXGI_OFFER_RESOURCE_PRIORITY), sizeof(DXGI_OFFER_RESOURCE_PRIORITY), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "OfferResources1");
    METHOD_BEGIN("HRESULT", "ReclaimResources1");
    PARAM("UINT", "UINT", "NumResources", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("IDXGIResource *const *", "IDXGIResource", "ppResources", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(IDXGIResource *const *), sizeof(IDXGIResource), "NumResources");
    PARAM("DXGI_RECLAIM_RESOURCE_RESULTS *", "DXGI_RECLAIM_RESOURCE_RESULTS", "pResults", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(DXGI_RECLAIM_RESOURCE_RESULTS *), sizeof(DXGI_RECLAIM_RESOURCE_RESULTS), "NumResources");
    METHOD_END("HRESULT", "ReclaimResources1");
    CLASS_END("IDXGIDevice4");
    CLASS_BEGIN("IDXGIFactory5");
    METHOD_BEGIN("HRESULT", "CheckFeatureSupport");
    PARAM("DXGI_FEATURE", "DXGI_FEATURE", "Feature", ParamAnnot::_IN_, 0, false, sizeof(DXGI_FEATURE), sizeof(DXGI_FEATURE), "NOT_SET");
    PARAM("void *", "void", "pFeatureSupportData", ParamAnnot::_INOUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    PARAM("UINT", "UINT", "FeatureSupportDataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckFeatureSupport");
    CLASS_END("IDXGIFactory5");
    CLASS_BEGIN("ID3D11Device4");
    METHOD_BEGIN("HRESULT", "RegisterDeviceRemovedEvent");
    PARAM("HANDLE", "HANDLE", "hEvent", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("DWORD *", "DWORD", "pdwCookie", ParamAnnot::_OUT_, 1, false, sizeof(DWORD *), sizeof(DWORD), "NOT_SET");
    METHOD_END("HRESULT", "RegisterDeviceRemovedEvent");
    METHOD_BEGIN("void", "UnregisterDeviceRemoved");
    PARAM("DWORD", "DWORD", "dwCookie", ParamAnnot::_IN_, 0, false, sizeof(DWORD), sizeof(DWORD), "NOT_SET");
    METHOD_END("void", "UnregisterDeviceRemoved");
    CLASS_END("ID3D11Device4");
    CLASS_BEGIN("ID3D11Device5");
    METHOD_BEGIN("HRESULT", "OpenSharedFence");
    PARAM("HANDLE", "HANDLE", "hFence", ParamAnnot::_IN_, 0, false, sizeof(HANDLE), sizeof(HANDLE), "NOT_SET");
    PARAM("const IID &", "IID", "ReturnedInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppFence", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "OpenSharedFence");
    METHOD_BEGIN("HRESULT", "CreateFence");
    PARAM("UINT64", "UINT64", "InitialValue", ParamAnnot::_IN_, 0, false, sizeof(UINT64), sizeof(UINT64), "NOT_SET");
    PARAM("D3D11_FENCE_FLAG", "D3D11_FENCE_FLAG", "Flags", ParamAnnot::_IN_, 0, false, sizeof(D3D11_FENCE_FLAG), sizeof(D3D11_FENCE_FLAG), "NOT_SET");
    PARAM("const IID &", "IID", "ReturnedInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppFence", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "CreateFence");
    CLASS_END("ID3D11Device5");
    CLASS_BEGIN("ID3D11Multithread");
    METHOD_BEGIN("void", "Enter");
    METHOD_END("void", "Enter");
    METHOD_BEGIN("void", "Leave");
    METHOD_END("void", "Leave");
    METHOD_BEGIN("BOOL", "SetMultithreadProtected");
    PARAM("BOOL", "BOOL", "bMTProtect", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("BOOL", "SetMultithreadProtected");
    METHOD_BEGIN("BOOL", "GetMultithreadProtected");
    METHOD_END("BOOL", "GetMultithreadProtected");
    CLASS_END("ID3D11Multithread");
    CLASS_BEGIN("ID3D11VideoContext2");
    METHOD_BEGIN("void", "VideoProcessorSetOutputHDRMetaData");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("DXGI_HDR_METADATA_TYPE", "DXGI_HDR_METADATA_TYPE", "Type", ParamAnnot::_IN_, 0, false, sizeof(DXGI_HDR_METADATA_TYPE), sizeof(DXGI_HDR_METADATA_TYPE), "NOT_SET");
    PARAM("UINT", "UINT", "Size", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pHDRMetaData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "Size");
    METHOD_END("void", "VideoProcessorSetOutputHDRMetaData");
    METHOD_BEGIN("void", "VideoProcessorGetOutputHDRMetaData");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("DXGI_HDR_METADATA_TYPE *", "DXGI_HDR_METADATA_TYPE", "pType", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_HDR_METADATA_TYPE *), sizeof(DXGI_HDR_METADATA_TYPE), "NOT_SET");
    PARAM("UINT", "UINT", "Size", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pMetaData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "Size");
    METHOD_END("void", "VideoProcessorGetOutputHDRMetaData");
    METHOD_BEGIN("void", "VideoProcessorSetStreamHDRMetaData");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_HDR_METADATA_TYPE", "DXGI_HDR_METADATA_TYPE", "Type", ParamAnnot::_IN_, 0, false, sizeof(DXGI_HDR_METADATA_TYPE), sizeof(DXGI_HDR_METADATA_TYPE), "NOT_SET");
    PARAM("UINT", "UINT", "Size", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pHDRMetaData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "Size");
    METHOD_END("void", "VideoProcessorSetStreamHDRMetaData");
    METHOD_BEGIN("void", "VideoProcessorGetStreamHDRMetaData");
    PARAM("ID3D11VideoProcessor *", "ID3D11VideoProcessor", "pVideoProcessor", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoProcessor *), sizeof(ID3D11VideoProcessor), "NOT_SET");
    PARAM("UINT", "UINT", "StreamIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("DXGI_HDR_METADATA_TYPE *", "DXGI_HDR_METADATA_TYPE", "pType", ParamAnnot::_OUT_, 1, false, sizeof(DXGI_HDR_METADATA_TYPE *), sizeof(DXGI_HDR_METADATA_TYPE), "NOT_SET");
    PARAM("UINT", "UINT", "Size", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pMetaData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "Size");
    METHOD_END("void", "VideoProcessorGetStreamHDRMetaData");
    CLASS_END("ID3D11VideoContext2");
    CLASS_BEGIN("ID3D11VideoDevice2");
    METHOD_BEGIN("HRESULT", "CheckFeatureSupport");
    PARAM("D3D11_FEATURE_VIDEO", "D3D11_FEATURE_VIDEO", "Feature", ParamAnnot::_IN_, 0, false, sizeof(D3D11_FEATURE_VIDEO), sizeof(D3D11_FEATURE_VIDEO), "NOT_SET");
    PARAM("void *", "void", "pFeatureSupportData", ParamAnnot::_OUT_ARRAY_, 1, false, sizeof(void *), 0, "FeatureSupportDataSize");
    PARAM("UINT", "UINT", "FeatureSupportDataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "CheckFeatureSupport");
    METHOD_BEGIN("HRESULT", "NegotiateCryptoSessionKeyExchangeMT");
    PARAM("ID3D11CryptoSession *", "ID3D11CryptoSession", "pCryptoSession", ParamAnnot::_IN_, 1, true, sizeof(ID3D11CryptoSession *), sizeof(ID3D11CryptoSession), "NOT_SET");
    PARAM("D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS", "D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS", "flags", ParamAnnot::_IN_, 0, false, sizeof(D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS), sizeof(D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS), "NOT_SET");
    PARAM("UINT", "UINT", "DataSize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("void *", "void", "pData", ParamAnnot::_INOUT_, 1, false, sizeof(void *), 0, "NOT_SET");
    METHOD_END("HRESULT", "NegotiateCryptoSessionKeyExchangeMT");
    CLASS_END("ID3D11VideoDevice2");
    CLASS_BEGIN("ID3D11VideoContext3");
    METHOD_BEGIN("HRESULT", "DecoderBeginFrame1");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("ID3D11VideoDecoderOutputView *", "ID3D11VideoDecoderOutputView", "pView", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoderOutputView *), sizeof(ID3D11VideoDecoderOutputView), "NOT_SET");
    PARAM("UINT", "UINT", "ContentKeySize", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const void *", "void", "pContentKey", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const void *), 0, "ContentKeySize");
    PARAM("UINT", "UINT", "NumComponentHistograms", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const UINT *", "UINT", "pHistogramOffsets", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const UINT *), sizeof(UINT), "NumComponentHistograms");
    PARAM("ID3D11Buffer *const *", "ID3D11Buffer", "ppHistogramBuffers", ParamAnnot::_IN_ARRAY_, 2, true, sizeof(ID3D11Buffer *const *), sizeof(ID3D11Buffer), "NumComponentHistograms");
    METHOD_END("HRESULT", "DecoderBeginFrame1");
    METHOD_BEGIN("HRESULT", "SubmitDecoderBuffers2");
    PARAM("ID3D11VideoDecoder *", "ID3D11VideoDecoder", "pDecoder", ParamAnnot::_IN_, 1, true, sizeof(ID3D11VideoDecoder *), sizeof(ID3D11VideoDecoder), "NOT_SET");
    PARAM("UINT", "UINT", "NumBuffers", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D11_VIDEO_DECODER_BUFFER_DESC2 *", "D3D11_VIDEO_DECODER_BUFFER_DESC2", "pBufferDesc", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D11_VIDEO_DECODER_BUFFER_DESC2 *), sizeof(D3D11_VIDEO_DECODER_BUFFER_DESC2), "NumBuffers");
    METHOD_END("HRESULT", "SubmitDecoderBuffers2");
    CLASS_END("ID3D11VideoContext3");
    CLASS_BEGIN("ID3D11ShaderReflectionType");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_SHADER_TYPE_DESC *", "D3D11_SHADER_TYPE_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_TYPE_DESC *), sizeof(D3D11_SHADER_TYPE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("struct ID3D11ShaderReflectionType *", "GetMemberTypeByIndex");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("struct ID3D11ShaderReflectionType *", "GetMemberTypeByIndex");
    METHOD_BEGIN("struct ID3D11ShaderReflectionType *", "GetMemberTypeByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("struct ID3D11ShaderReflectionType *", "GetMemberTypeByName");
    METHOD_BEGIN("LPCSTR", "GetMemberTypeName");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("LPCSTR", "GetMemberTypeName");
    METHOD_BEGIN("HRESULT", "IsEqual");
    PARAM("struct ID3D11ShaderReflectionType *", "ID3D11ShaderReflectionType", "pType", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11ShaderReflectionType *), sizeof(ID3D11ShaderReflectionType), "NOT_SET");
    METHOD_END("HRESULT", "IsEqual");
    METHOD_BEGIN("struct ID3D11ShaderReflectionType *", "GetSubType");
    METHOD_END("struct ID3D11ShaderReflectionType *", "GetSubType");
    METHOD_BEGIN("struct ID3D11ShaderReflectionType *", "GetBaseClass");
    METHOD_END("struct ID3D11ShaderReflectionType *", "GetBaseClass");
    METHOD_BEGIN("UINT", "GetNumInterfaces");
    METHOD_END("UINT", "GetNumInterfaces");
    METHOD_BEGIN("struct ID3D11ShaderReflectionType *", "GetInterfaceByIndex");
    PARAM("UINT", "UINT", "uIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("struct ID3D11ShaderReflectionType *", "GetInterfaceByIndex");
    METHOD_BEGIN("HRESULT", "IsOfType");
    PARAM("struct ID3D11ShaderReflectionType *", "ID3D11ShaderReflectionType", "pType", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11ShaderReflectionType *), sizeof(ID3D11ShaderReflectionType), "NOT_SET");
    METHOD_END("HRESULT", "IsOfType");
    METHOD_BEGIN("HRESULT", "ImplementsInterface");
    PARAM("struct ID3D11ShaderReflectionType *", "ID3D11ShaderReflectionType", "pBase", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11ShaderReflectionType *), sizeof(ID3D11ShaderReflectionType), "NOT_SET");
    METHOD_END("HRESULT", "ImplementsInterface");
    CLASS_END("ID3D11ShaderReflectionType");
    CLASS_BEGIN("ID3D11ShaderReflectionVariable");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_SHADER_VARIABLE_DESC *", "D3D11_SHADER_VARIABLE_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_VARIABLE_DESC *), sizeof(D3D11_SHADER_VARIABLE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D11ShaderReflectionType *", "GetType");
    METHOD_END("ID3D11ShaderReflectionType *", "GetType");
    METHOD_BEGIN("ID3D11ShaderReflectionConstantBuffer *", "GetBuffer");
    METHOD_END("ID3D11ShaderReflectionConstantBuffer *", "GetBuffer");
    METHOD_BEGIN("UINT", "GetInterfaceSlot");
    PARAM("UINT", "UINT", "uArrayIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("UINT", "GetInterfaceSlot");
    CLASS_END("ID3D11ShaderReflectionVariable");
    CLASS_BEGIN("ID3D11ShaderReflectionConstantBuffer");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_SHADER_BUFFER_DESC *", "D3D11_SHADER_BUFFER_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(D3D11_SHADER_BUFFER_DESC *), sizeof(D3D11_SHADER_BUFFER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D11ShaderReflectionVariable *", "GetVariableByIndex");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionVariable *", "GetVariableByIndex");
    METHOD_BEGIN("ID3D11ShaderReflectionVariable *", "GetVariableByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionVariable *", "GetVariableByName");
    CLASS_END("ID3D11ShaderReflectionConstantBuffer");
    CLASS_BEGIN("ID3D11ShaderReflection");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_SHADER_DESC *", "D3D11_SHADER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_DESC *), sizeof(D3D11_SHADER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    METHOD_BEGIN("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDesc");
    PARAM("UINT", "UINT", "ResourceIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_SHADER_INPUT_BIND_DESC *", "D3D11_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_INPUT_BIND_DESC *), sizeof(D3D11_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDesc");
    METHOD_BEGIN("HRESULT", "GetInputParameterDesc");
    PARAM("UINT", "UINT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_SIGNATURE_PARAMETER_DESC *", "D3D11_SIGNATURE_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SIGNATURE_PARAMETER_DESC *), sizeof(D3D11_SIGNATURE_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetInputParameterDesc");
    METHOD_BEGIN("HRESULT", "GetOutputParameterDesc");
    PARAM("UINT", "UINT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_SIGNATURE_PARAMETER_DESC *", "D3D11_SIGNATURE_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SIGNATURE_PARAMETER_DESC *), sizeof(D3D11_SIGNATURE_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetOutputParameterDesc");
    METHOD_BEGIN("HRESULT", "GetPatchConstantParameterDesc");
    PARAM("UINT", "UINT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_SIGNATURE_PARAMETER_DESC *", "D3D11_SIGNATURE_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SIGNATURE_PARAMETER_DESC *), sizeof(D3D11_SIGNATURE_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetPatchConstantParameterDesc");
    METHOD_BEGIN("ID3D11ShaderReflectionVariable *", "GetVariableByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionVariable *", "GetVariableByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDescByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("D3D11_SHADER_INPUT_BIND_DESC *", "D3D11_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_INPUT_BIND_DESC *), sizeof(D3D11_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDescByName");
    METHOD_BEGIN("UINT", "GetMovInstructionCount");
    METHOD_END("UINT", "GetMovInstructionCount");
    METHOD_BEGIN("UINT", "GetMovcInstructionCount");
    METHOD_END("UINT", "GetMovcInstructionCount");
    METHOD_BEGIN("UINT", "GetConversionInstructionCount");
    METHOD_END("UINT", "GetConversionInstructionCount");
    METHOD_BEGIN("UINT", "GetBitwiseInstructionCount");
    METHOD_END("UINT", "GetBitwiseInstructionCount");
    METHOD_BEGIN("D3D_PRIMITIVE", "GetGSInputPrimitive");
    METHOD_END("D3D_PRIMITIVE", "GetGSInputPrimitive");
    METHOD_BEGIN("BOOL", "IsSampleFrequencyShader");
    METHOD_END("BOOL", "IsSampleFrequencyShader");
    METHOD_BEGIN("UINT", "GetNumInterfaceSlots");
    METHOD_END("UINT", "GetNumInterfaceSlots");
    METHOD_BEGIN("HRESULT", "GetMinFeatureLevel");
    PARAM("enum D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pLevel", ParamAnnot::_OUT_, 1, false, sizeof(enum D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "NOT_SET");
    METHOD_END("HRESULT", "GetMinFeatureLevel");
    METHOD_BEGIN("UINT", "GetThreadGroupSize");
    PARAM("UINT *", "UINT", "pSizeX", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pSizeY", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pSizeZ", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("UINT", "GetThreadGroupSize");
    METHOD_BEGIN("UINT64", "GetRequiresFlags");
    METHOD_END("UINT64", "GetRequiresFlags");
    CLASS_END("ID3D11ShaderReflection");
    CLASS_BEGIN("ID3D11LibraryReflection");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_LIBRARY_DESC *", "D3D11_LIBRARY_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_LIBRARY_DESC *), sizeof(D3D11_LIBRARY_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D11FunctionReflection *", "GetFunctionByIndex");
    PARAM("INT", "INT", "FunctionIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("ID3D11FunctionReflection *", "GetFunctionByIndex");
    CLASS_END("ID3D11LibraryReflection");
    CLASS_BEGIN("ID3D11FunctionReflection");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_FUNCTION_DESC *", "D3D11_FUNCTION_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_FUNCTION_DESC *), sizeof(D3D11_FUNCTION_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    PARAM("UINT", "UINT", "BufferIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    METHOD_BEGIN("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDesc");
    PARAM("UINT", "UINT", "ResourceIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D11_SHADER_INPUT_BIND_DESC *", "D3D11_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_INPUT_BIND_DESC *), sizeof(D3D11_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDesc");
    METHOD_BEGIN("ID3D11ShaderReflectionVariable *", "GetVariableByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D11ShaderReflectionVariable *", "GetVariableByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDescByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("D3D11_SHADER_INPUT_BIND_DESC *", "D3D11_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_SHADER_INPUT_BIND_DESC *), sizeof(D3D11_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDescByName");
    METHOD_BEGIN("ID3D11FunctionParameterReflection *", "GetFunctionParameter");
    PARAM("INT", "INT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("ID3D11FunctionParameterReflection *", "GetFunctionParameter");
    CLASS_END("ID3D11FunctionReflection");
    CLASS_BEGIN("ID3D11FunctionParameterReflection");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D11_PARAMETER_DESC *", "D3D11_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D11_PARAMETER_DESC *), sizeof(D3D11_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    CLASS_END("ID3D11FunctionParameterReflection");
    CLASS_BEGIN("ID3D11Module");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "CreateInstance");
    PARAM("LPCSTR", "LPCSTR", "pNamespace", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("struct ID3D11ModuleInstance **", "ID3D11ModuleInstance", "ppModuleInstance", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11ModuleInstance **), sizeof(ID3D11ModuleInstance), "NOT_SET");
    METHOD_END("HRESULT", "CreateInstance");
    CLASS_END("ID3D11Module");
    CLASS_BEGIN("ID3D11ModuleInstance");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "BindConstantBuffer");
    PARAM("UINT", "UINT", "uSrcSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "cbDstOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindConstantBuffer");
    METHOD_BEGIN("HRESULT", "BindConstantBufferByName");
    PARAM("LPCSTR", "LPCSTR", "pName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "cbDstOffset", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindConstantBufferByName");
    METHOD_BEGIN("HRESULT", "BindResource");
    PARAM("UINT", "UINT", "uSrcSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindResource");
    METHOD_BEGIN("HRESULT", "BindResourceByName");
    PARAM("LPCSTR", "LPCSTR", "pName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindResourceByName");
    METHOD_BEGIN("HRESULT", "BindSampler");
    PARAM("UINT", "UINT", "uSrcSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindSampler");
    METHOD_BEGIN("HRESULT", "BindSamplerByName");
    PARAM("LPCSTR", "LPCSTR", "pName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindSamplerByName");
    METHOD_BEGIN("HRESULT", "BindUnorderedAccessView");
    PARAM("UINT", "UINT", "uSrcSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindUnorderedAccessView");
    METHOD_BEGIN("HRESULT", "BindUnorderedAccessViewByName");
    PARAM("LPCSTR", "LPCSTR", "pName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "uDstSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindUnorderedAccessViewByName");
    METHOD_BEGIN("HRESULT", "BindResourceAsUnorderedAccessView");
    PARAM("UINT", "UINT", "uSrcSrvSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uDstUavSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindResourceAsUnorderedAccessView");
    METHOD_BEGIN("HRESULT", "BindResourceAsUnorderedAccessViewByName");
    PARAM("LPCSTR", "LPCSTR", "pSrvName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "uDstUavSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCount", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "BindResourceAsUnorderedAccessViewByName");
    CLASS_END("ID3D11ModuleInstance");
    CLASS_BEGIN("ID3D11Linker");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "Link");
    PARAM("struct ID3D11ModuleInstance *", "ID3D11ModuleInstance", "pEntry", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11ModuleInstance *), sizeof(ID3D11ModuleInstance), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pEntryName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pTargetName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "uFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppShaderBlob", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorBuffer", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "Link");
    METHOD_BEGIN("HRESULT", "UseLibrary");
    PARAM("struct ID3D11ModuleInstance *", "ID3D11ModuleInstance", "pLibraryMI", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11ModuleInstance *), sizeof(ID3D11ModuleInstance), "NOT_SET");
    METHOD_END("HRESULT", "UseLibrary");
    METHOD_BEGIN("HRESULT", "AddClipPlaneFromCBuffer");
    PARAM("UINT", "UINT", "uCBufferSlot", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uCBufferEntry", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "AddClipPlaneFromCBuffer");
    CLASS_END("ID3D11Linker");
    CLASS_BEGIN("ID3D11LinkingNode");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    CLASS_END("ID3D11LinkingNode");
    CLASS_BEGIN("ID3D11FunctionLinkingGraph");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "CreateModuleInstance");
    PARAM("struct ID3D11ModuleInstance **", "ID3D11ModuleInstance", "ppModuleInstance", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11ModuleInstance **), sizeof(ID3D11ModuleInstance), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorBuffer", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "CreateModuleInstance");
    METHOD_BEGIN("HRESULT", "SetInputSignature");
    PARAM("const D3D11_PARAMETER_DESC *", "D3D11_PARAMETER_DESC", "pInputParameters", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_PARAMETER_DESC *), sizeof(D3D11_PARAMETER_DESC), "NOT_SET");
    PARAM("UINT", "UINT", "cInputParameters", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("struct ID3D11LinkingNode **", "ID3D11LinkingNode", "ppInputNode", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11LinkingNode **), sizeof(ID3D11LinkingNode), "NOT_SET");
    METHOD_END("HRESULT", "SetInputSignature");
    METHOD_BEGIN("HRESULT", "SetOutputSignature");
    PARAM("const D3D11_PARAMETER_DESC *", "D3D11_PARAMETER_DESC", "pOutputParameters", ParamAnnot::_IN_, 1, false, sizeof(const D3D11_PARAMETER_DESC *), sizeof(D3D11_PARAMETER_DESC), "NOT_SET");
    PARAM("UINT", "UINT", "cOutputParameters", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("struct ID3D11LinkingNode **", "ID3D11LinkingNode", "ppOutputNode", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11LinkingNode **), sizeof(ID3D11LinkingNode), "NOT_SET");
    METHOD_END("HRESULT", "SetOutputSignature");
    METHOD_BEGIN("HRESULT", "CallFunction");
    PARAM("LPCSTR", "LPCSTR", "pModuleInstanceNamespace", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("struct ID3D11Module *", "ID3D11Module", "pModuleWithFunctionPrototype", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11Module *), sizeof(ID3D11Module), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pFunctionName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("struct ID3D11LinkingNode **", "ID3D11LinkingNode", "ppCallNode", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11LinkingNode **), sizeof(ID3D11LinkingNode), "NOT_SET");
    METHOD_END("HRESULT", "CallFunction");
    METHOD_BEGIN("HRESULT", "PassValue");
    PARAM("struct ID3D11LinkingNode *", "ID3D11LinkingNode", "pSrcNode", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11LinkingNode *), sizeof(ID3D11LinkingNode), "NOT_SET");
    PARAM("INT", "INT", "SrcParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    PARAM("struct ID3D11LinkingNode *", "ID3D11LinkingNode", "pDstNode", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11LinkingNode *), sizeof(ID3D11LinkingNode), "NOT_SET");
    PARAM("INT", "INT", "DstParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("HRESULT", "PassValue");
    METHOD_BEGIN("HRESULT", "PassValueWithSwizzle");
    PARAM("struct ID3D11LinkingNode *", "ID3D11LinkingNode", "pSrcNode", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11LinkingNode *), sizeof(ID3D11LinkingNode), "NOT_SET");
    PARAM("INT", "INT", "SrcParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pSrcSwizzle", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("struct ID3D11LinkingNode *", "ID3D11LinkingNode", "pDstNode", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D11LinkingNode *), sizeof(ID3D11LinkingNode), "NOT_SET");
    PARAM("INT", "INT", "DstParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pDstSwizzle", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("HRESULT", "PassValueWithSwizzle");
    METHOD_BEGIN("HRESULT", "GetLastError");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorBuffer", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "GetLastError");
    METHOD_BEGIN("HRESULT", "GenerateHlsl");
    PARAM("UINT", "UINT", "uFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppBuffer", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "GenerateHlsl");
    CLASS_END("ID3D11FunctionLinkingGraph");
    CLASS_BEGIN("ID3D12ShaderReflectionType");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_SHADER_TYPE_DESC *", "D3D12_SHADER_TYPE_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_TYPE_DESC *), sizeof(D3D12_SHADER_TYPE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("struct ID3D12ShaderReflectionType *", "GetMemberTypeByIndex");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("struct ID3D12ShaderReflectionType *", "GetMemberTypeByIndex");
    METHOD_BEGIN("struct ID3D12ShaderReflectionType *", "GetMemberTypeByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("struct ID3D12ShaderReflectionType *", "GetMemberTypeByName");
    METHOD_BEGIN("LPCSTR", "GetMemberTypeName");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("LPCSTR", "GetMemberTypeName");
    METHOD_BEGIN("HRESULT", "IsEqual");
    PARAM("struct ID3D12ShaderReflectionType *", "ID3D12ShaderReflectionType", "pType", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D12ShaderReflectionType *), sizeof(ID3D12ShaderReflectionType), "NOT_SET");
    METHOD_END("HRESULT", "IsEqual");
    METHOD_BEGIN("struct ID3D12ShaderReflectionType *", "GetSubType");
    METHOD_END("struct ID3D12ShaderReflectionType *", "GetSubType");
    METHOD_BEGIN("struct ID3D12ShaderReflectionType *", "GetBaseClass");
    METHOD_END("struct ID3D12ShaderReflectionType *", "GetBaseClass");
    METHOD_BEGIN("UINT", "GetNumInterfaces");
    METHOD_END("UINT", "GetNumInterfaces");
    METHOD_BEGIN("struct ID3D12ShaderReflectionType *", "GetInterfaceByIndex");
    PARAM("UINT", "UINT", "uIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("struct ID3D12ShaderReflectionType *", "GetInterfaceByIndex");
    METHOD_BEGIN("HRESULT", "IsOfType");
    PARAM("struct ID3D12ShaderReflectionType *", "ID3D12ShaderReflectionType", "pType", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D12ShaderReflectionType *), sizeof(ID3D12ShaderReflectionType), "NOT_SET");
    METHOD_END("HRESULT", "IsOfType");
    METHOD_BEGIN("HRESULT", "ImplementsInterface");
    PARAM("struct ID3D12ShaderReflectionType *", "ID3D12ShaderReflectionType", "pBase", ParamAnnot::_IN_, 1, true, sizeof(struct ID3D12ShaderReflectionType *), sizeof(ID3D12ShaderReflectionType), "NOT_SET");
    METHOD_END("HRESULT", "ImplementsInterface");
    CLASS_END("ID3D12ShaderReflectionType");
    CLASS_BEGIN("ID3D12ShaderReflectionVariable");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_SHADER_VARIABLE_DESC *", "D3D12_SHADER_VARIABLE_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_VARIABLE_DESC *), sizeof(D3D12_SHADER_VARIABLE_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D12ShaderReflectionType *", "GetType");
    METHOD_END("ID3D12ShaderReflectionType *", "GetType");
    METHOD_BEGIN("ID3D12ShaderReflectionConstantBuffer *", "GetBuffer");
    METHOD_END("ID3D12ShaderReflectionConstantBuffer *", "GetBuffer");
    METHOD_BEGIN("UINT", "GetInterfaceSlot");
    PARAM("UINT", "UINT", "uArrayIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("UINT", "GetInterfaceSlot");
    CLASS_END("ID3D12ShaderReflectionVariable");
    CLASS_BEGIN("ID3D12ShaderReflectionConstantBuffer");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_SHADER_BUFFER_DESC *", "D3D12_SHADER_BUFFER_DESC", "pDesc", ParamAnnot::_IN_, 1, false, sizeof(D3D12_SHADER_BUFFER_DESC *), sizeof(D3D12_SHADER_BUFFER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D12ShaderReflectionVariable *", "GetVariableByIndex");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionVariable *", "GetVariableByIndex");
    METHOD_BEGIN("ID3D12ShaderReflectionVariable *", "GetVariableByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionVariable *", "GetVariableByName");
    CLASS_END("ID3D12ShaderReflectionConstantBuffer");
    CLASS_BEGIN("ID3D12ShaderReflection");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_SHADER_DESC *", "D3D12_SHADER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_DESC *), sizeof(D3D12_SHADER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    PARAM("UINT", "UINT", "Index", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    METHOD_BEGIN("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDesc");
    PARAM("UINT", "UINT", "ResourceIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D12_SHADER_INPUT_BIND_DESC *", "D3D12_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_INPUT_BIND_DESC *), sizeof(D3D12_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDesc");
    METHOD_BEGIN("HRESULT", "GetInputParameterDesc");
    PARAM("UINT", "UINT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D12_SIGNATURE_PARAMETER_DESC *", "D3D12_SIGNATURE_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SIGNATURE_PARAMETER_DESC *), sizeof(D3D12_SIGNATURE_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetInputParameterDesc");
    METHOD_BEGIN("HRESULT", "GetOutputParameterDesc");
    PARAM("UINT", "UINT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D12_SIGNATURE_PARAMETER_DESC *", "D3D12_SIGNATURE_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SIGNATURE_PARAMETER_DESC *), sizeof(D3D12_SIGNATURE_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetOutputParameterDesc");
    METHOD_BEGIN("HRESULT", "GetPatchConstantParameterDesc");
    PARAM("UINT", "UINT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D12_SIGNATURE_PARAMETER_DESC *", "D3D12_SIGNATURE_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SIGNATURE_PARAMETER_DESC *), sizeof(D3D12_SIGNATURE_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetPatchConstantParameterDesc");
    METHOD_BEGIN("ID3D12ShaderReflectionVariable *", "GetVariableByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionVariable *", "GetVariableByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDescByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("D3D12_SHADER_INPUT_BIND_DESC *", "D3D12_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_INPUT_BIND_DESC *), sizeof(D3D12_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDescByName");
    METHOD_BEGIN("UINT", "GetMovInstructionCount");
    METHOD_END("UINT", "GetMovInstructionCount");
    METHOD_BEGIN("UINT", "GetMovcInstructionCount");
    METHOD_END("UINT", "GetMovcInstructionCount");
    METHOD_BEGIN("UINT", "GetConversionInstructionCount");
    METHOD_END("UINT", "GetConversionInstructionCount");
    METHOD_BEGIN("UINT", "GetBitwiseInstructionCount");
    METHOD_END("UINT", "GetBitwiseInstructionCount");
    METHOD_BEGIN("D3D_PRIMITIVE", "GetGSInputPrimitive");
    METHOD_END("D3D_PRIMITIVE", "GetGSInputPrimitive");
    METHOD_BEGIN("BOOL", "IsSampleFrequencyShader");
    METHOD_END("BOOL", "IsSampleFrequencyShader");
    METHOD_BEGIN("UINT", "GetNumInterfaceSlots");
    METHOD_END("UINT", "GetNumInterfaceSlots");
    METHOD_BEGIN("HRESULT", "GetMinFeatureLevel");
    PARAM("enum D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pLevel", ParamAnnot::_OUT_, 1, false, sizeof(enum D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "NOT_SET");
    METHOD_END("HRESULT", "GetMinFeatureLevel");
    METHOD_BEGIN("UINT", "GetThreadGroupSize");
    PARAM("UINT *", "UINT", "pSizeX", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pSizeY", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pSizeZ", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("UINT", "GetThreadGroupSize");
    METHOD_BEGIN("UINT64", "GetRequiresFlags");
    METHOD_END("UINT64", "GetRequiresFlags");
    CLASS_END("ID3D12ShaderReflection");
    CLASS_BEGIN("ID3D12LibraryReflection");
    METHOD_BEGIN("HRESULT", "QueryInterface");
    PARAM("const IID &", "IID", "iid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppv", ParamAnnot::_OUT_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "QueryInterface");
    METHOD_BEGIN("ULONG", "AddRef");
    METHOD_END("ULONG", "AddRef");
    METHOD_BEGIN("ULONG", "Release");
    METHOD_END("ULONG", "Release");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_LIBRARY_DESC *", "D3D12_LIBRARY_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_LIBRARY_DESC *), sizeof(D3D12_LIBRARY_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D12FunctionReflection *", "GetFunctionByIndex");
    PARAM("INT", "INT", "FunctionIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("ID3D12FunctionReflection *", "GetFunctionByIndex");
    CLASS_END("ID3D12LibraryReflection");
    CLASS_BEGIN("ID3D12FunctionReflection");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_FUNCTION_DESC *", "D3D12_FUNCTION_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_FUNCTION_DESC *), sizeof(D3D12_FUNCTION_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    METHOD_BEGIN("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    PARAM("UINT", "UINT", "BufferIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByIndex");
    METHOD_BEGIN("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionConstantBuffer *", "GetConstantBufferByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDesc");
    PARAM("UINT", "UINT", "ResourceIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D12_SHADER_INPUT_BIND_DESC *", "D3D12_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_INPUT_BIND_DESC *), sizeof(D3D12_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDesc");
    METHOD_BEGIN("ID3D12ShaderReflectionVariable *", "GetVariableByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    METHOD_END("ID3D12ShaderReflectionVariable *", "GetVariableByName");
    METHOD_BEGIN("HRESULT", "GetResourceBindingDescByName");
    PARAM("LPCSTR", "LPCSTR", "Name", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("D3D12_SHADER_INPUT_BIND_DESC *", "D3D12_SHADER_INPUT_BIND_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_SHADER_INPUT_BIND_DESC *), sizeof(D3D12_SHADER_INPUT_BIND_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetResourceBindingDescByName");
    METHOD_BEGIN("ID3D12FunctionParameterReflection *", "GetFunctionParameter");
    PARAM("INT", "INT", "ParameterIndex", ParamAnnot::_IN_, 0, false, sizeof(INT), sizeof(INT), "NOT_SET");
    METHOD_END("ID3D12FunctionParameterReflection *", "GetFunctionParameter");
    CLASS_END("ID3D12FunctionReflection");
    CLASS_BEGIN("ID3D12FunctionParameterReflection");
    METHOD_BEGIN("HRESULT", "GetDesc");
    PARAM("D3D12_PARAMETER_DESC *", "D3D12_PARAMETER_DESC", "pDesc", ParamAnnot::_OUT_, 1, false, sizeof(D3D12_PARAMETER_DESC *), sizeof(D3D12_PARAMETER_DESC), "NOT_SET");
    METHOD_END("HRESULT", "GetDesc");
    CLASS_END("ID3D12FunctionParameterReflection");
    CLASS_BEGIN("GLOBAL");
    METHOD_BEGIN("HRESULT", "CreateDXGIFactory");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppFactory", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "CreateDXGIFactory");
    METHOD_BEGIN("HRESULT", "CreateDXGIFactory1");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppFactory", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "CreateDXGIFactory1");
    METHOD_BEGIN("UINT", "D3D11CalcSubresource");
    PARAM("UINT", "UINT", "MipSlice", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "ArraySlice", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "MipLevels", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    METHOD_END("UINT", "D3D11CalcSubresource");
    METHOD_BEGIN("HRESULT", "D3D11CreateDevice");
    PARAM("IDXGIAdapter *", "IDXGIAdapter", "pAdapter", ParamAnnot::_IN_, 1, true, sizeof(IDXGIAdapter *), sizeof(IDXGIAdapter), "NOT_SET");
    PARAM("D3D_DRIVER_TYPE", "D3D_DRIVER_TYPE", "DriverType", ParamAnnot::_IN_, 0, false, sizeof(D3D_DRIVER_TYPE), sizeof(D3D_DRIVER_TYPE), "NOT_SET");
    PARAM("HMODULE", "HMODULE", "Software", ParamAnnot::_IN_, 0, false, sizeof(HMODULE), sizeof(HMODULE), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pFeatureLevels", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "FeatureLevels");
    PARAM("UINT", "UINT", "FeatureLevels", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SDKVersion", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3D11Device **", "ID3D11Device", "ppDevice", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Device **), sizeof(ID3D11Device), "NOT_SET");
    PARAM("D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pFeatureLevel", ParamAnnot::_OUT_, 1, false, sizeof(D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "NOT_SET");
    PARAM("ID3D11DeviceContext **", "ID3D11DeviceContext", "ppImmediateContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext **), sizeof(ID3D11DeviceContext), "NOT_SET");
    METHOD_END("HRESULT", "D3D11CreateDevice");
    METHOD_BEGIN("HRESULT", "D3D11CreateDeviceAndSwapChain");
    PARAM("IDXGIAdapter *", "IDXGIAdapter", "pAdapter", ParamAnnot::_IN_, 1, true, sizeof(IDXGIAdapter *), sizeof(IDXGIAdapter), "NOT_SET");
    PARAM("D3D_DRIVER_TYPE", "D3D_DRIVER_TYPE", "DriverType", ParamAnnot::_IN_, 0, false, sizeof(D3D_DRIVER_TYPE), sizeof(D3D_DRIVER_TYPE), "NOT_SET");
    PARAM("HMODULE", "HMODULE", "Software", ParamAnnot::_IN_, 0, false, sizeof(HMODULE), sizeof(HMODULE), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pFeatureLevels", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "FeatureLevels");
    PARAM("UINT", "UINT", "FeatureLevels", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SDKVersion", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const DXGI_SWAP_CHAIN_DESC *", "DXGI_SWAP_CHAIN_DESC", "pSwapChainDesc", ParamAnnot::_IN_, 1, false, sizeof(const DXGI_SWAP_CHAIN_DESC *), sizeof(DXGI_SWAP_CHAIN_DESC), "NOT_SET");
    PARAM("IDXGISwapChain **", "IDXGISwapChain", "ppSwapChain", ParamAnnot::_OUT_, 2, true, sizeof(IDXGISwapChain **), sizeof(IDXGISwapChain), "NOT_SET");
    PARAM("ID3D11Device **", "ID3D11Device", "ppDevice", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11Device **), sizeof(ID3D11Device), "NOT_SET");
    PARAM("D3D_FEATURE_LEVEL *", "D3D_FEATURE_LEVEL", "pFeatureLevel", ParamAnnot::_OUT_, 1, false, sizeof(D3D_FEATURE_LEVEL *), sizeof(D3D_FEATURE_LEVEL), "NOT_SET");
    PARAM("ID3D11DeviceContext **", "ID3D11DeviceContext", "ppImmediateContext", ParamAnnot::_OUT_, 2, true, sizeof(ID3D11DeviceContext **), sizeof(ID3D11DeviceContext), "NOT_SET");
    METHOD_END("HRESULT", "D3D11CreateDeviceAndSwapChain");
    METHOD_BEGIN("HRESULT", "CreateDXGIFactory2");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppFactory", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "CreateDXGIFactory2");
    METHOD_BEGIN("HRESULT", "DXGIGetDebugInterface1");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "pDebug", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "DXGIGetDebugInterface1");
    METHOD_BEGIN("HRESULT", "D3DReadFileToBlob");
    PARAM("LPCWSTR", "LPCWSTR", "pFileName", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppContents", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DReadFileToBlob");
    METHOD_BEGIN("HRESULT", "D3DWriteBlobToFile");
    PARAM("ID3DBlob *", "ID3DBlob", "pBlob", ParamAnnot::_IN_, 1, false, sizeof(ID3DBlob *), sizeof(ID3DBlob), "NOT_SET");
    PARAM("LPCWSTR", "LPCWSTR", "pFileName", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("BOOL", "BOOL", "bOverwrite", ParamAnnot::_IN_, 0, false, sizeof(BOOL), sizeof(BOOL), "NOT_SET");
    METHOD_END("HRESULT", "D3DWriteBlobToFile");
    METHOD_BEGIN("HRESULT", "D3DCompile");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pSourceName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("const D3D_SHADER_MACRO *", "D3D_SHADER_MACRO", "pDefines", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D_SHADER_MACRO *), sizeof(D3D_SHADER_MACRO), "_Inexpressible_(pDefines->Name!=NULL)");
    PARAM("ID3DInclude *", "ID3DInclude", "pInclude", ParamAnnot::_IN_, 1, true, sizeof(ID3DInclude *), sizeof(ID3DInclude), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pEntrypoint", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pTarget", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "Flags1", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags2", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppCode", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorMsgs", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DCompile");
    METHOD_BEGIN("HRESULT", "D3DCompile2");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pSourceName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("const D3D_SHADER_MACRO *", "D3D_SHADER_MACRO", "pDefines", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D_SHADER_MACRO *), sizeof(D3D_SHADER_MACRO), "_Inexpressible_(pDefines->Name!=NULL)");
    PARAM("ID3DInclude *", "ID3DInclude", "pInclude", ParamAnnot::_IN_, 1, true, sizeof(ID3DInclude *), sizeof(ID3DInclude), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pEntrypoint", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pTarget", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "Flags1", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags2", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "SecondaryDataFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("LPCVOID", "LPCVOID", "pSecondaryData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SecondaryDataSize");
    PARAM("SIZE_T", "SIZE_T", "SecondaryDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppCode", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorMsgs", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DCompile2");
    METHOD_BEGIN("HRESULT", "D3DCompileFromFile");
    PARAM("LPCWSTR", "LPCWSTR", "pFileName", ParamAnnot::_IN_, 0, false, sizeof(LPCWSTR), sizeof(LPCWSTR), "NOT_SET");
    PARAM("const D3D_SHADER_MACRO *", "D3D_SHADER_MACRO", "pDefines", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(const D3D_SHADER_MACRO *), sizeof(D3D_SHADER_MACRO), "_Inexpressible_(pDefines->Name!=NULL)");
    PARAM("ID3DInclude *", "ID3DInclude", "pInclude", ParamAnnot::_IN_, 1, true, sizeof(ID3DInclude *), sizeof(ID3DInclude), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pEntrypoint", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pTarget", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("UINT", "UINT", "Flags1", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "Flags2", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppCode", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorMsgs", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DCompileFromFile");
    METHOD_BEGIN("HRESULT", "D3DPreprocess");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "pSourceName", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("const D3D_SHADER_MACRO *", "D3D_SHADER_MACRO", "pDefines", ParamAnnot::_IN_, 1, false, sizeof(const D3D_SHADER_MACRO *), sizeof(D3D_SHADER_MACRO), "NOT_SET");
    PARAM("ID3DInclude *", "ID3DInclude", "pInclude", ParamAnnot::_IN_, 1, true, sizeof(ID3DInclude *), sizeof(ID3DInclude), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppCodeText", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppErrorMsgs", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DPreprocess");
    METHOD_BEGIN("HRESULT", "D3DGetDebugInfo");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppDebugInfo", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DGetDebugInfo");
    METHOD_BEGIN("HRESULT", "D3DReflect");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("const IID &", "IID", "pInterface", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("void **", "void", "ppReflector", ParamAnnot::_OUT_, 2, false, sizeof(void **), 0, "NOT_SET");
    METHOD_END("HRESULT", "D3DReflect");
    METHOD_BEGIN("HRESULT", "D3DReflectLibrary");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "NOT_SET");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("const IID &", "IID", "riid", ParamAnnot::_IN_, 0, false, sizeof(const IID &), sizeof(IID), "NOT_SET");
    PARAM("LPVOID *", "LPVOID", "ppReflector", ParamAnnot::_IN_, 1, false, sizeof(LPVOID *), sizeof(LPVOID), "NOT_SET");
    METHOD_END("HRESULT", "D3DReflectLibrary");
    METHOD_BEGIN("HRESULT", "D3DDisassemble");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "szComments", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppDisassembly", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DDisassemble");
    METHOD_BEGIN("HRESULT", "D3DDisassembleRegion");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("LPCSTR", "LPCSTR", "szComments", ParamAnnot::_IN_, 0, false, sizeof(LPCSTR), sizeof(LPCSTR), "NOT_SET");
    PARAM("SIZE_T", "SIZE_T", "StartByteOffset", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("SIZE_T", "SIZE_T", "NumInsts", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("SIZE_T *", "SIZE_T", "pFinishByteOffset", ParamAnnot::_OUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppDisassembly", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DDisassembleRegion");
    METHOD_BEGIN("HRESULT", "D3DCreateLinker");
    PARAM("struct ID3D11Linker **", "ID3D11Linker", "ppLinker", ParamAnnot::_IN_, 2, true, sizeof(struct ID3D11Linker **), sizeof(ID3D11Linker), "NOT_SET");
    METHOD_END("HRESULT", "D3DCreateLinker");
    METHOD_BEGIN("HRESULT", "D3DLoadModule");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "NOT_SET");
    PARAM("SIZE_T", "SIZE_T", "cbSrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("struct ID3D11Module **", "ID3D11Module", "ppModule", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11Module **), sizeof(ID3D11Module), "NOT_SET");
    METHOD_END("HRESULT", "D3DLoadModule");
    METHOD_BEGIN("HRESULT", "D3DCreateFunctionLinkingGraph");
    PARAM("UINT", "UINT", "uFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("struct ID3D11FunctionLinkingGraph **", "ID3D11FunctionLinkingGraph", "ppFunctionLinkingGraph", ParamAnnot::_OUT_, 2, true, sizeof(struct ID3D11FunctionLinkingGraph **), sizeof(ID3D11FunctionLinkingGraph), "NOT_SET");
    METHOD_END("HRESULT", "D3DCreateFunctionLinkingGraph");
    METHOD_BEGIN("HRESULT", "D3DGetTraceInstructionOffsets");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("SIZE_T", "SIZE_T", "StartInstIndex", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("SIZE_T", "SIZE_T", "NumInsts", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("SIZE_T *", "SIZE_T", "pOffsets", ParamAnnot::_IN_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    PARAM("SIZE_T *", "SIZE_T", "pTotalInsts", ParamAnnot::_OUT_, 1, false, sizeof(SIZE_T *), sizeof(SIZE_T), "NOT_SET");
    METHOD_END("HRESULT", "D3DGetTraceInstructionOffsets");
    METHOD_BEGIN("HRESULT", "D3DGetInputSignatureBlob");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppSignatureBlob", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DGetInputSignatureBlob");
    METHOD_BEGIN("HRESULT", "D3DGetOutputSignatureBlob");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppSignatureBlob", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DGetOutputSignatureBlob");
    METHOD_BEGIN("HRESULT", "D3DGetInputAndOutputSignatureBlob");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppSignatureBlob", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DGetInputAndOutputSignatureBlob");
    METHOD_BEGIN("HRESULT", "D3DStripShader");
    PARAM("LPCVOID", "LPCVOID", "pShaderBytecode", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "BytecodeLength");
    PARAM("SIZE_T", "SIZE_T", "BytecodeLength", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("UINT", "UINT", "uStripFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppStrippedBlob", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DStripShader");
    METHOD_BEGIN("HRESULT", "D3DGetBlobPart");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("D3D_BLOB_PART", "D3D_BLOB_PART", "Part", ParamAnnot::_IN_, 0, false, sizeof(D3D_BLOB_PART), sizeof(D3D_BLOB_PART), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppPart", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DGetBlobPart");
    METHOD_BEGIN("HRESULT", "D3DSetBlobPart");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("D3D_BLOB_PART", "D3D_BLOB_PART", "Part", ParamAnnot::_IN_, 0, false, sizeof(D3D_BLOB_PART), sizeof(D3D_BLOB_PART), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("LPCVOID", "LPCVOID", "pPart", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "PartSize");
    PARAM("SIZE_T", "SIZE_T", "PartSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppNewShader", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DSetBlobPart");
    METHOD_BEGIN("HRESULT", "D3DCreateBlob");
    PARAM("SIZE_T", "SIZE_T", "Size", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppBlob", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DCreateBlob");
    METHOD_BEGIN("HRESULT", "D3DCompressShaders");
    PARAM("UINT", "UINT", "uNumShaders", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("D3D_SHADER_DATA *", "D3D_SHADER_DATA", "pShaderData", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(D3D_SHADER_DATA *), sizeof(D3D_SHADER_DATA), "uNumShaders");
    PARAM("UINT", "UINT", "uFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppCompressedData", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DCompressShaders");
    METHOD_BEGIN("HRESULT", "D3DDecompressShaders");
    PARAM("LPCVOID", "LPCVOID", "pSrcData", ParamAnnot::_IN_ARRAY_, 0, false, sizeof(LPCVOID), sizeof(LPCVOID), "SrcDataSize");
    PARAM("SIZE_T", "SIZE_T", "SrcDataSize", ParamAnnot::_IN_, 0, false, sizeof(SIZE_T), sizeof(SIZE_T), "NOT_SET");
    PARAM("UINT", "UINT", "uNumShaders", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT", "UINT", "uStartIndex", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("UINT *", "UINT", "pIndices", ParamAnnot::_IN_ARRAY_, 1, false, sizeof(UINT *), sizeof(UINT), "uNumShaders");
    PARAM("UINT", "UINT", "uFlags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppShaders", ParamAnnot::_OUT_ARRAY_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "uNumShaders");
    PARAM("UINT *", "UINT", "pTotalShaders", ParamAnnot::_OUT_, 1, false, sizeof(UINT *), sizeof(UINT), "NOT_SET");
    METHOD_END("HRESULT", "D3DDecompressShaders");
    METHOD_BEGIN("HRESULT", "D3DDisassemble10Effect");
    PARAM("struct ID3D10Effect *", "ID3D10Effect", "pEffect", ParamAnnot::_IN_, 1, false, sizeof(struct ID3D10Effect *), sizeof(ID3D10Effect), "NOT_SET");
    PARAM("UINT", "UINT", "Flags", ParamAnnot::_IN_, 0, false, sizeof(UINT), sizeof(UINT), "NOT_SET");
    PARAM("ID3DBlob **", "ID3DBlob", "ppDisassembly", ParamAnnot::_OUT_, 2, false, sizeof(ID3DBlob **), sizeof(ID3DBlob), "NOT_SET");
    METHOD_END("HRESULT", "D3DDisassemble10Effect");
    CLASS_END("GLOBAL");
  }
} g_tableInit;
template<typename T> void HandleWrap(
  const IID & riid, 
  T ** ppvObject) {
  if(riid == __uuidof(IUnknown)) {
    *ppvObject = (T*)getWrapper<IUnknown, WrappedID3D12LibraryReflection>((IUnknown*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIObject)) {
    *ppvObject = (T*)getWrapper<IDXGIObject, WrappedIDXGIFactory5>((IDXGIObject*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDeviceSubObject)) {
    *ppvObject = (T*)getWrapper<IDXGIDeviceSubObject, WrappedIDXGISwapChain4>((IDXGIDeviceSubObject*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIResource)) {
    *ppvObject = (T*)getWrapper<IDXGIResource, WrappedIDXGIResource1>((IDXGIResource*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIKeyedMutex)) {
    *ppvObject = (T*)getWrapper<IDXGIKeyedMutex, WrappedIDXGIKeyedMutex>((IDXGIKeyedMutex*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISurface)) {
    *ppvObject = (T*)getWrapper<IDXGISurface, WrappedIDXGISurface2>((IDXGISurface*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISurface1)) {
    *ppvObject = (T*)getWrapper<IDXGISurface1, WrappedIDXGISurface2>((IDXGISurface1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIAdapter)) {
    *ppvObject = (T*)getWrapper<IDXGIAdapter, WrappedIDXGIAdapter3>((IDXGIAdapter*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutput)) {
    *ppvObject = (T*)getWrapper<IDXGIOutput, WrappedIDXGIOutput5>((IDXGIOutput*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISwapChain)) {
    *ppvObject = (T*)getWrapper<IDXGISwapChain, WrappedIDXGISwapChain4>((IDXGISwapChain*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactory)) {
    *ppvObject = (T*)getWrapper<IDXGIFactory, WrappedIDXGIFactory5>((IDXGIFactory*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDevice)) {
    *ppvObject = (T*)getWrapper<IDXGIDevice, WrappedIDXGIDevice4>((IDXGIDevice*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactory1)) {
    *ppvObject = (T*)getWrapper<IDXGIFactory1, WrappedIDXGIFactory5>((IDXGIFactory1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIAdapter1)) {
    *ppvObject = (T*)getWrapper<IDXGIAdapter1, WrappedIDXGIAdapter3>((IDXGIAdapter1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDevice1)) {
    *ppvObject = (T*)getWrapper<IDXGIDevice1, WrappedIDXGIDevice4>((IDXGIDevice1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D10Blob)) {
    *ppvObject = (T*)getWrapper<ID3D10Blob, WrappedID3D10Blob>((ID3D10Blob*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3DDestructionNotifier)) {
    *ppvObject = (T*)getWrapper<ID3DDestructionNotifier, WrappedID3DDestructionNotifier>((ID3DDestructionNotifier*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DeviceChild)) {
    *ppvObject = (T*)getWrapper<ID3D11DeviceChild, WrappedID3D11VideoContext3>((ID3D11DeviceChild*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DepthStencilState)) {
    *ppvObject = (T*)getWrapper<ID3D11DepthStencilState, WrappedID3D11DepthStencilState>((ID3D11DepthStencilState*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11BlendState)) {
    *ppvObject = (T*)getWrapper<ID3D11BlendState, WrappedID3D11BlendState1>((ID3D11BlendState*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RasterizerState)) {
    *ppvObject = (T*)getWrapper<ID3D11RasterizerState, WrappedID3D11RasterizerState2>((ID3D11RasterizerState*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Resource)) {
    *ppvObject = (T*)getWrapper<ID3D11Resource, WrappedID3D11Texture3D1>((ID3D11Resource*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Buffer)) {
    *ppvObject = (T*)getWrapper<ID3D11Buffer, WrappedID3D11Buffer>((ID3D11Buffer*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Texture1D)) {
    *ppvObject = (T*)getWrapper<ID3D11Texture1D, WrappedID3D11Texture1D>((ID3D11Texture1D*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Texture2D)) {
    *ppvObject = (T*)getWrapper<ID3D11Texture2D, WrappedID3D11Texture2D1>((ID3D11Texture2D*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Texture3D)) {
    *ppvObject = (T*)getWrapper<ID3D11Texture3D, WrappedID3D11Texture3D1>((ID3D11Texture3D*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11View)) {
    *ppvObject = (T*)getWrapper<ID3D11View, WrappedID3D11UnorderedAccessView1>((ID3D11View*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ShaderResourceView)) {
    *ppvObject = (T*)getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>((ID3D11ShaderResourceView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RenderTargetView)) {
    *ppvObject = (T*)getWrapper<ID3D11RenderTargetView, WrappedID3D11RenderTargetView1>((ID3D11RenderTargetView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DepthStencilView)) {
    *ppvObject = (T*)getWrapper<ID3D11DepthStencilView, WrappedID3D11DepthStencilView>((ID3D11DepthStencilView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11UnorderedAccessView)) {
    *ppvObject = (T*)getWrapper<ID3D11UnorderedAccessView, WrappedID3D11UnorderedAccessView1>((ID3D11UnorderedAccessView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VertexShader)) {
    *ppvObject = (T*)getWrapper<ID3D11VertexShader, WrappedID3D11VertexShader>((ID3D11VertexShader*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11HullShader)) {
    *ppvObject = (T*)getWrapper<ID3D11HullShader, WrappedID3D11HullShader>((ID3D11HullShader*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DomainShader)) {
    *ppvObject = (T*)getWrapper<ID3D11DomainShader, WrappedID3D11DomainShader>((ID3D11DomainShader*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11GeometryShader)) {
    *ppvObject = (T*)getWrapper<ID3D11GeometryShader, WrappedID3D11GeometryShader>((ID3D11GeometryShader*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11PixelShader)) {
    *ppvObject = (T*)getWrapper<ID3D11PixelShader, WrappedID3D11PixelShader>((ID3D11PixelShader*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ComputeShader)) {
    *ppvObject = (T*)getWrapper<ID3D11ComputeShader, WrappedID3D11ComputeShader>((ID3D11ComputeShader*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11InputLayout)) {
    *ppvObject = (T*)getWrapper<ID3D11InputLayout, WrappedID3D11InputLayout>((ID3D11InputLayout*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11SamplerState)) {
    *ppvObject = (T*)getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>((ID3D11SamplerState*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Asynchronous)) {
    *ppvObject = (T*)getWrapper<ID3D11Asynchronous, WrappedID3D11Query1>((ID3D11Asynchronous*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Query)) {
    *ppvObject = (T*)getWrapper<ID3D11Query, WrappedID3D11Query1>((ID3D11Query*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Predicate)) {
    *ppvObject = (T*)getWrapper<ID3D11Predicate, WrappedID3D11Predicate>((ID3D11Predicate*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Counter)) {
    *ppvObject = (T*)getWrapper<ID3D11Counter, WrappedID3D11Counter>((ID3D11Counter*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ClassInstance)) {
    *ppvObject = (T*)getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>((ID3D11ClassInstance*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ClassLinkage)) {
    *ppvObject = (T*)getWrapper<ID3D11ClassLinkage, WrappedID3D11ClassLinkage>((ID3D11ClassLinkage*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11CommandList)) {
    *ppvObject = (T*)getWrapper<ID3D11CommandList, WrappedID3D11CommandList>((ID3D11CommandList*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DeviceContext)) {
    *ppvObject = (T*)getWrapper<ID3D11DeviceContext, WrappedID3D11DeviceContext4>((ID3D11DeviceContext*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoDecoder)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoDecoder, WrappedID3D11VideoDecoder>((ID3D11VideoDecoder*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoProcessorEnumerator)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoProcessorEnumerator, WrappedID3D11VideoProcessorEnumerator1>((ID3D11VideoProcessorEnumerator*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoProcessor)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoProcessor, WrappedID3D11VideoProcessor>((ID3D11VideoProcessor*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11AuthenticatedChannel)) {
    *ppvObject = (T*)getWrapper<ID3D11AuthenticatedChannel, WrappedID3D11AuthenticatedChannel>((ID3D11AuthenticatedChannel*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11CryptoSession)) {
    *ppvObject = (T*)getWrapper<ID3D11CryptoSession, WrappedID3D11CryptoSession>((ID3D11CryptoSession*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoDecoderOutputView)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoDecoderOutputView, WrappedID3D11VideoDecoderOutputView>((ID3D11VideoDecoderOutputView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoProcessorInputView)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoProcessorInputView, WrappedID3D11VideoProcessorInputView>((ID3D11VideoProcessorInputView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoProcessorOutputView)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoProcessorOutputView, WrappedID3D11VideoProcessorOutputView>((ID3D11VideoProcessorOutputView*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoContext)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoContext, WrappedID3D11VideoContext3>((ID3D11VideoContext*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoDevice)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoDevice, WrappedID3D11VideoDevice2>((ID3D11VideoDevice*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Device)) {
    *ppvObject = (T*)getWrapper<ID3D11Device, WrappedID3D11Device5>((ID3D11Device*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Debug)) {
    *ppvObject = (T*)getWrapper<ID3D11Debug, WrappedID3D11Debug>((ID3D11Debug*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11SwitchToRef)) {
    *ppvObject = (T*)getWrapper<ID3D11SwitchToRef, WrappedID3D11SwitchToRef>((ID3D11SwitchToRef*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11TracingDevice)) {
    *ppvObject = (T*)getWrapper<ID3D11TracingDevice, WrappedID3D11TracingDevice>((ID3D11TracingDevice*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RefTrackingOptions)) {
    *ppvObject = (T*)getWrapper<ID3D11RefTrackingOptions, WrappedID3D11RefTrackingOptions>((ID3D11RefTrackingOptions*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RefDefaultTrackingOptions)) {
    *ppvObject = (T*)getWrapper<ID3D11RefDefaultTrackingOptions, WrappedID3D11RefDefaultTrackingOptions>((ID3D11RefDefaultTrackingOptions*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11InfoQueue)) {
    *ppvObject = (T*)getWrapper<ID3D11InfoQueue, WrappedID3D11InfoQueue>((ID3D11InfoQueue*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3DDeviceContextState)) {
    *ppvObject = (T*)getWrapper<ID3DDeviceContextState, WrappedID3DDeviceContextState>((ID3DDeviceContextState*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDisplayControl)) {
    *ppvObject = (T*)getWrapper<IDXGIDisplayControl, WrappedIDXGIDisplayControl>((IDXGIDisplayControl*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutputDuplication)) {
    *ppvObject = (T*)getWrapper<IDXGIOutputDuplication, WrappedIDXGIOutputDuplication>((IDXGIOutputDuplication*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISurface2)) {
    *ppvObject = (T*)getWrapper<IDXGISurface2, WrappedIDXGISurface2>((IDXGISurface2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIResource1)) {
    *ppvObject = (T*)getWrapper<IDXGIResource1, WrappedIDXGIResource1>((IDXGIResource1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDevice2)) {
    *ppvObject = (T*)getWrapper<IDXGIDevice2, WrappedIDXGIDevice4>((IDXGIDevice2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISwapChain1)) {
    *ppvObject = (T*)getWrapper<IDXGISwapChain1, WrappedIDXGISwapChain4>((IDXGISwapChain1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactory2)) {
    *ppvObject = (T*)getWrapper<IDXGIFactory2, WrappedIDXGIFactory5>((IDXGIFactory2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIAdapter2)) {
    *ppvObject = (T*)getWrapper<IDXGIAdapter2, WrappedIDXGIAdapter3>((IDXGIAdapter2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutput1)) {
    *ppvObject = (T*)getWrapper<IDXGIOutput1, WrappedIDXGIOutput5>((IDXGIOutput1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11BlendState1)) {
    *ppvObject = (T*)getWrapper<ID3D11BlendState1, WrappedID3D11BlendState1>((ID3D11BlendState1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RasterizerState1)) {
    *ppvObject = (T*)getWrapper<ID3D11RasterizerState1, WrappedID3D11RasterizerState2>((ID3D11RasterizerState1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DeviceContext1)) {
    *ppvObject = (T*)getWrapper<ID3D11DeviceContext1, WrappedID3D11DeviceContext4>((ID3D11DeviceContext1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoContext1)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoContext1, WrappedID3D11VideoContext3>((ID3D11VideoContext1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoDevice1)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoDevice1, WrappedID3D11VideoDevice2>((ID3D11VideoDevice1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoProcessorEnumerator1)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoProcessorEnumerator1, WrappedID3D11VideoProcessorEnumerator1>((ID3D11VideoProcessorEnumerator1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Device1)) {
    *ppvObject = (T*)getWrapper<ID3D11Device1, WrappedID3D11Device5>((ID3D11Device1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3DUserDefinedAnnotation)) {
    *ppvObject = (T*)getWrapper<ID3DUserDefinedAnnotation, WrappedID3DUserDefinedAnnotation>((ID3DUserDefinedAnnotation*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDevice3)) {
    *ppvObject = (T*)getWrapper<IDXGIDevice3, WrappedIDXGIDevice4>((IDXGIDevice3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISwapChain2)) {
    *ppvObject = (T*)getWrapper<IDXGISwapChain2, WrappedIDXGISwapChain4>((IDXGISwapChain2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutput2)) {
    *ppvObject = (T*)getWrapper<IDXGIOutput2, WrappedIDXGIOutput5>((IDXGIOutput2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactory3)) {
    *ppvObject = (T*)getWrapper<IDXGIFactory3, WrappedIDXGIFactory5>((IDXGIFactory3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDecodeSwapChain)) {
    *ppvObject = (T*)getWrapper<IDXGIDecodeSwapChain, WrappedIDXGIDecodeSwapChain>((IDXGIDecodeSwapChain*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactoryMedia)) {
    *ppvObject = (T*)getWrapper<IDXGIFactoryMedia, WrappedIDXGIFactoryMedia>((IDXGIFactoryMedia*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISwapChainMedia)) {
    *ppvObject = (T*)getWrapper<IDXGISwapChainMedia, WrappedIDXGISwapChainMedia>((IDXGISwapChainMedia*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutput3)) {
    *ppvObject = (T*)getWrapper<IDXGIOutput3, WrappedIDXGIOutput5>((IDXGIOutput3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DeviceContext2)) {
    *ppvObject = (T*)getWrapper<ID3D11DeviceContext2, WrappedID3D11DeviceContext4>((ID3D11DeviceContext2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Device2)) {
    *ppvObject = (T*)getWrapper<ID3D11Device2, WrappedID3D11Device5>((ID3D11Device2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Texture2D1)) {
    *ppvObject = (T*)getWrapper<ID3D11Texture2D1, WrappedID3D11Texture2D1>((ID3D11Texture2D1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Texture3D1)) {
    *ppvObject = (T*)getWrapper<ID3D11Texture3D1, WrappedID3D11Texture3D1>((ID3D11Texture3D1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RasterizerState2)) {
    *ppvObject = (T*)getWrapper<ID3D11RasterizerState2, WrappedID3D11RasterizerState2>((ID3D11RasterizerState2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ShaderResourceView1)) {
    *ppvObject = (T*)getWrapper<ID3D11ShaderResourceView1, WrappedID3D11ShaderResourceView1>((ID3D11ShaderResourceView1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11RenderTargetView1)) {
    *ppvObject = (T*)getWrapper<ID3D11RenderTargetView1, WrappedID3D11RenderTargetView1>((ID3D11RenderTargetView1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11UnorderedAccessView1)) {
    *ppvObject = (T*)getWrapper<ID3D11UnorderedAccessView1, WrappedID3D11UnorderedAccessView1>((ID3D11UnorderedAccessView1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Query1)) {
    *ppvObject = (T*)getWrapper<ID3D11Query1, WrappedID3D11Query1>((ID3D11Query1*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DeviceContext3)) {
    *ppvObject = (T*)getWrapper<ID3D11DeviceContext3, WrappedID3D11DeviceContext4>((ID3D11DeviceContext3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Fence)) {
    *ppvObject = (T*)getWrapper<ID3D11Fence, WrappedID3D11Fence>((ID3D11Fence*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11DeviceContext4)) {
    *ppvObject = (T*)getWrapper<ID3D11DeviceContext4, WrappedID3D11DeviceContext4>((ID3D11DeviceContext4*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Device3)) {
    *ppvObject = (T*)getWrapper<ID3D11Device3, WrappedID3D11Device5>((ID3D11Device3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISwapChain3)) {
    *ppvObject = (T*)getWrapper<IDXGISwapChain3, WrappedIDXGISwapChain4>((IDXGISwapChain3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutput4)) {
    *ppvObject = (T*)getWrapper<IDXGIOutput4, WrappedIDXGIOutput5>((IDXGIOutput4*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactory4)) {
    *ppvObject = (T*)getWrapper<IDXGIFactory4, WrappedIDXGIFactory5>((IDXGIFactory4*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIAdapter3)) {
    *ppvObject = (T*)getWrapper<IDXGIAdapter3, WrappedIDXGIAdapter3>((IDXGIAdapter3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIOutput5)) {
    *ppvObject = (T*)getWrapper<IDXGIOutput5, WrappedIDXGIOutput5>((IDXGIOutput5*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGISwapChain4)) {
    *ppvObject = (T*)getWrapper<IDXGISwapChain4, WrappedIDXGISwapChain4>((IDXGISwapChain4*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIDevice4)) {
    *ppvObject = (T*)getWrapper<IDXGIDevice4, WrappedIDXGIDevice4>((IDXGIDevice4*)*ppvObject);
    return;
  }
  if(riid == __uuidof(IDXGIFactory5)) {
    *ppvObject = (T*)getWrapper<IDXGIFactory5, WrappedIDXGIFactory5>((IDXGIFactory5*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Device4)) {
    *ppvObject = (T*)getWrapper<ID3D11Device4, WrappedID3D11Device5>((ID3D11Device4*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Device5)) {
    *ppvObject = (T*)getWrapper<ID3D11Device5, WrappedID3D11Device5>((ID3D11Device5*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Multithread)) {
    *ppvObject = (T*)getWrapper<ID3D11Multithread, WrappedID3D11Multithread>((ID3D11Multithread*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoContext2)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoContext2, WrappedID3D11VideoContext3>((ID3D11VideoContext2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoDevice2)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoDevice2, WrappedID3D11VideoDevice2>((ID3D11VideoDevice2*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11VideoContext3)) {
    *ppvObject = (T*)getWrapper<ID3D11VideoContext3, WrappedID3D11VideoContext3>((ID3D11VideoContext3*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ShaderReflectionType)) {
    *ppvObject = (T*)getWrapper<ID3D11ShaderReflectionType, WrappedID3D11ShaderReflectionType>((ID3D11ShaderReflectionType*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ShaderReflectionVariable)) {
    *ppvObject = (T*)getWrapper<ID3D11ShaderReflectionVariable, WrappedID3D11ShaderReflectionVariable>((ID3D11ShaderReflectionVariable*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ShaderReflectionConstantBuffer)) {
    *ppvObject = (T*)getWrapper<ID3D11ShaderReflectionConstantBuffer, WrappedID3D11ShaderReflectionConstantBuffer>((ID3D11ShaderReflectionConstantBuffer*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ShaderReflection)) {
    *ppvObject = (T*)getWrapper<ID3D11ShaderReflection, WrappedID3D11ShaderReflection>((ID3D11ShaderReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11LibraryReflection)) {
    *ppvObject = (T*)getWrapper<ID3D11LibraryReflection, WrappedID3D11LibraryReflection>((ID3D11LibraryReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11FunctionReflection)) {
    *ppvObject = (T*)getWrapper<ID3D11FunctionReflection, WrappedID3D11FunctionReflection>((ID3D11FunctionReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11FunctionParameterReflection)) {
    *ppvObject = (T*)getWrapper<ID3D11FunctionParameterReflection, WrappedID3D11FunctionParameterReflection>((ID3D11FunctionParameterReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Module)) {
    *ppvObject = (T*)getWrapper<ID3D11Module, WrappedID3D11Module>((ID3D11Module*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11ModuleInstance)) {
    *ppvObject = (T*)getWrapper<ID3D11ModuleInstance, WrappedID3D11ModuleInstance>((ID3D11ModuleInstance*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11Linker)) {
    *ppvObject = (T*)getWrapper<ID3D11Linker, WrappedID3D11Linker>((ID3D11Linker*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11LinkingNode)) {
    *ppvObject = (T*)getWrapper<ID3D11LinkingNode, WrappedID3D11LinkingNode>((ID3D11LinkingNode*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D11FunctionLinkingGraph)) {
    *ppvObject = (T*)getWrapper<ID3D11FunctionLinkingGraph, WrappedID3D11FunctionLinkingGraph>((ID3D11FunctionLinkingGraph*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12ShaderReflectionType)) {
    *ppvObject = (T*)getWrapper<ID3D12ShaderReflectionType, WrappedID3D12ShaderReflectionType>((ID3D12ShaderReflectionType*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12ShaderReflectionVariable)) {
    *ppvObject = (T*)getWrapper<ID3D12ShaderReflectionVariable, WrappedID3D12ShaderReflectionVariable>((ID3D12ShaderReflectionVariable*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12ShaderReflectionConstantBuffer)) {
    *ppvObject = (T*)getWrapper<ID3D12ShaderReflectionConstantBuffer, WrappedID3D12ShaderReflectionConstantBuffer>((ID3D12ShaderReflectionConstantBuffer*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12ShaderReflection)) {
    *ppvObject = (T*)getWrapper<ID3D12ShaderReflection, WrappedID3D12ShaderReflection>((ID3D12ShaderReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12LibraryReflection)) {
    *ppvObject = (T*)getWrapper<ID3D12LibraryReflection, WrappedID3D12LibraryReflection>((ID3D12LibraryReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12FunctionReflection)) {
    *ppvObject = (T*)getWrapper<ID3D12FunctionReflection, WrappedID3D12FunctionReflection>((ID3D12FunctionReflection*)*ppvObject);
    return;
  }
  if(riid == __uuidof(ID3D12FunctionParameterReflection)) {
    *ppvObject = (T*)getWrapper<ID3D12FunctionParameterReflection, WrappedID3D12FunctionParameterReflection>((ID3D12FunctionParameterReflection*)*ppvObject);
    return;
  }
  {
  }
}
#if 0
begin class IDXGIKeyedMutex
inherits:
  IDXGIDeviceSubObject
  IDXGIObject
  IUnknown
methods:
  AcquireSync
  ReleaseSync
end class
#endif
class WrappedIDXGIKeyedMutex : public IDXGIKeyedMutex {
private:
  IDXGIKeyedMutex *m_pIDXGIKeyedMutex;
  IDXGIDeviceSubObject *m_pIDXGIDeviceSubObject;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIKeyedMutex(T *pWrapped) {
    out() << "// [CREATE] IDXGIKeyedMutex(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIDeviceSubObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDeviceSubObject), (void **)&m_pIDXGIDeviceSubObject);
    if (!res) {
      m_pIDXGIDeviceSubObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDeviceSubObject;
    }
    m_pIDXGIKeyedMutex = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIKeyedMutex), (void **)&m_pIDXGIKeyedMutex);
    if (!res) {
      m_pIDXGIKeyedMutex->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIKeyedMutex);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIKeyedMutex)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIKeyedMutex;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIKeyedMutex() {
    out() << "// [DESTROY] IDXGIKeyedMutex(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject));
    m_pIDXGIDeviceSubObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIKeyedMutex));
    m_pIDXGIKeyedMutex = nullptr;
  }
  HRESULT __stdcall AcquireSync(
    UINT64 Key, 
    DWORD dwMilliseconds
  ) override;
  HRESULT __stdcall ReleaseSync(
    UINT64 Key
  ) override;
  HRESULT __stdcall GetDevice(
    const IID & riid, 
    void ** ppDevice
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D10Blob
inherits:
  IUnknown
methods:
  GetBufferPointer
  GetBufferSize
end class
#endif
class WrappedID3D10Blob : public ID3D10Blob {
private:
  ID3D10Blob *m_pID3D10Blob;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D10Blob(T *pWrapped) {
    out() << "// [CREATE] ID3D10Blob(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D10Blob = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D10Blob), (void **)&m_pID3D10Blob);
    if (!res) {
      m_pID3D10Blob->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D10Blob);
      wt[reinterpret_cast<size_t>((void*)m_pID3D10Blob)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D10Blob;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D10Blob() {
    out() << "// [DESTROY] ID3D10Blob(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D10Blob));
    m_pID3D10Blob = nullptr;
  }
  LPVOID __stdcall GetBufferPointer() override;
  SIZE_T __stdcall GetBufferSize() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3DDestructionNotifier
inherits:
  IUnknown
methods:
  RegisterDestructionCallback
  UnregisterDestructionCallback
end class
#endif
class WrappedID3DDestructionNotifier : public ID3DDestructionNotifier {
private:
  ID3DDestructionNotifier *m_pID3DDestructionNotifier;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3DDestructionNotifier(T *pWrapped) {
    out() << "// [CREATE] ID3DDestructionNotifier(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3DDestructionNotifier = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3DDestructionNotifier), (void **)&m_pID3DDestructionNotifier);
    if (!res) {
      m_pID3DDestructionNotifier->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3DDestructionNotifier);
      wt[reinterpret_cast<size_t>((void*)m_pID3DDestructionNotifier)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3DDestructionNotifier;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3DDestructionNotifier() {
    out() << "// [DESTROY] ID3DDestructionNotifier(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3DDestructionNotifier));
    m_pID3DDestructionNotifier = nullptr;
  }
  HRESULT __stdcall RegisterDestructionCallback(
    PFN_DESTRUCTION_CALLBACK callbackFn, 
    void * pData, 
    UINT * pCallbackID
  ) override;
  HRESULT __stdcall UnregisterDestructionCallback(
    UINT callbackID
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3DInclude
inherits:
methods:
  Open
  Close
end class
#endif
class WrappedID3DInclude : public ID3DInclude {
private:
  ID3DInclude *m_pID3DInclude;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3DInclude(T *pWrapped) {
    out() << "// [CREATE] ID3DInclude(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3DInclude = nullptr;
    m_pID3DInclude = (ID3DInclude*)pWrapped;
  }
  ~WrappedID3DInclude() {
    out() << "// [DESTROY] ID3DInclude(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3DInclude = nullptr;
  }
  HRESULT __stdcall Open(
    D3D_INCLUDE_TYPE IncludeType, 
    LPCSTR pFileName, 
    LPCVOID pParentData, 
    LPCVOID * ppData, 
    UINT * pBytes
  ) override;
  HRESULT __stdcall Close(
    LPCVOID pData
  ) override;
};
#if 0
begin class ID3D11DepthStencilState
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11DepthStencilState : public ID3D11DepthStencilState {
private:
  ID3D11DepthStencilState *m_pID3D11DepthStencilState;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11DepthStencilState(T *pWrapped) {
    out() << "// [CREATE] ID3D11DepthStencilState(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11DepthStencilState = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DepthStencilState), (void **)&m_pID3D11DepthStencilState);
    if (!res) {
      m_pID3D11DepthStencilState->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DepthStencilState);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DepthStencilState)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DepthStencilState;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11DepthStencilState() {
    out() << "// [DESTROY] ID3D11DepthStencilState(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DepthStencilState));
    m_pID3D11DepthStencilState = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_DEPTH_STENCIL_DESC * pDesc
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Buffer
inherits:
  ID3D11Resource
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11Buffer : public ID3D11Buffer {
private:
  ID3D11Buffer *m_pID3D11Buffer;
  ID3D11Resource *m_pID3D11Resource;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Buffer(T *pWrapped) {
    out() << "// [CREATE] ID3D11Buffer(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Resource = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Resource), (void **)&m_pID3D11Resource);
    if (!res) {
      m_pID3D11Resource->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Resource);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Resource)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Resource;
    }
    m_pID3D11Buffer = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Buffer), (void **)&m_pID3D11Buffer);
    if (!res) {
      m_pID3D11Buffer->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Buffer);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Buffer)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Buffer;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Buffer() {
    out() << "// [DESTROY] ID3D11Buffer(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Resource));
    m_pID3D11Resource = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Buffer));
    m_pID3D11Buffer = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_BUFFER_DESC * pDesc
  ) override;
  void __stdcall GetType(
    D3D11_RESOURCE_DIMENSION * pResourceDimension
  ) override;
  void __stdcall SetEvictionPriority(
    UINT EvictionPriority
  ) override;
  UINT __stdcall GetEvictionPriority() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Texture1D
inherits:
  ID3D11Resource
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11Texture1D : public ID3D11Texture1D {
private:
  ID3D11Texture1D *m_pID3D11Texture1D;
  ID3D11Resource *m_pID3D11Resource;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Texture1D(T *pWrapped) {
    out() << "// [CREATE] ID3D11Texture1D(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Resource = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Resource), (void **)&m_pID3D11Resource);
    if (!res) {
      m_pID3D11Resource->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Resource);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Resource)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Resource;
    }
    m_pID3D11Texture1D = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Texture1D), (void **)&m_pID3D11Texture1D);
    if (!res) {
      m_pID3D11Texture1D->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Texture1D);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Texture1D)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Texture1D;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Texture1D() {
    out() << "// [DESTROY] ID3D11Texture1D(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Resource));
    m_pID3D11Resource = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Texture1D));
    m_pID3D11Texture1D = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_TEXTURE1D_DESC * pDesc
  ) override;
  void __stdcall GetType(
    D3D11_RESOURCE_DIMENSION * pResourceDimension
  ) override;
  void __stdcall SetEvictionPriority(
    UINT EvictionPriority
  ) override;
  UINT __stdcall GetEvictionPriority() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11DepthStencilView
inherits:
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11DepthStencilView : public ID3D11DepthStencilView {
private:
  ID3D11DepthStencilView *m_pID3D11DepthStencilView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11DepthStencilView(T *pWrapped) {
    out() << "// [CREATE] ID3D11DepthStencilView(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11DepthStencilView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DepthStencilView), (void **)&m_pID3D11DepthStencilView);
    if (!res) {
      m_pID3D11DepthStencilView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DepthStencilView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DepthStencilView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DepthStencilView;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11DepthStencilView() {
    out() << "// [DESTROY] ID3D11DepthStencilView(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DepthStencilView));
    m_pID3D11DepthStencilView = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_DEPTH_STENCIL_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VertexShader
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11VertexShader : public ID3D11VertexShader {
private:
  ID3D11VertexShader *m_pID3D11VertexShader;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VertexShader(T *pWrapped) {
    out() << "// [CREATE] ID3D11VertexShader(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11VertexShader = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VertexShader), (void **)&m_pID3D11VertexShader);
    if (!res) {
      m_pID3D11VertexShader->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VertexShader);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VertexShader)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VertexShader;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VertexShader() {
    out() << "// [DESTROY] ID3D11VertexShader(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VertexShader));
    m_pID3D11VertexShader = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11HullShader
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11HullShader : public ID3D11HullShader {
private:
  ID3D11HullShader *m_pID3D11HullShader;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11HullShader(T *pWrapped) {
    out() << "// [CREATE] ID3D11HullShader(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11HullShader = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11HullShader), (void **)&m_pID3D11HullShader);
    if (!res) {
      m_pID3D11HullShader->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11HullShader);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11HullShader)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11HullShader;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11HullShader() {
    out() << "// [DESTROY] ID3D11HullShader(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11HullShader));
    m_pID3D11HullShader = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11DomainShader
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11DomainShader : public ID3D11DomainShader {
private:
  ID3D11DomainShader *m_pID3D11DomainShader;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11DomainShader(T *pWrapped) {
    out() << "// [CREATE] ID3D11DomainShader(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11DomainShader = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DomainShader), (void **)&m_pID3D11DomainShader);
    if (!res) {
      m_pID3D11DomainShader->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DomainShader);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DomainShader)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DomainShader;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11DomainShader() {
    out() << "// [DESTROY] ID3D11DomainShader(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DomainShader));
    m_pID3D11DomainShader = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11GeometryShader
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11GeometryShader : public ID3D11GeometryShader {
private:
  ID3D11GeometryShader *m_pID3D11GeometryShader;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11GeometryShader(T *pWrapped) {
    out() << "// [CREATE] ID3D11GeometryShader(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11GeometryShader = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11GeometryShader), (void **)&m_pID3D11GeometryShader);
    if (!res) {
      m_pID3D11GeometryShader->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11GeometryShader);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11GeometryShader)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11GeometryShader;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11GeometryShader() {
    out() << "// [DESTROY] ID3D11GeometryShader(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11GeometryShader));
    m_pID3D11GeometryShader = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11PixelShader
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11PixelShader : public ID3D11PixelShader {
private:
  ID3D11PixelShader *m_pID3D11PixelShader;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11PixelShader(T *pWrapped) {
    out() << "// [CREATE] ID3D11PixelShader(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11PixelShader = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11PixelShader), (void **)&m_pID3D11PixelShader);
    if (!res) {
      m_pID3D11PixelShader->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11PixelShader);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11PixelShader)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11PixelShader;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11PixelShader() {
    out() << "// [DESTROY] ID3D11PixelShader(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11PixelShader));
    m_pID3D11PixelShader = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11ComputeShader
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11ComputeShader : public ID3D11ComputeShader {
private:
  ID3D11ComputeShader *m_pID3D11ComputeShader;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11ComputeShader(T *pWrapped) {
    out() << "// [CREATE] ID3D11ComputeShader(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11ComputeShader = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ComputeShader), (void **)&m_pID3D11ComputeShader);
    if (!res) {
      m_pID3D11ComputeShader->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ComputeShader);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ComputeShader)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ComputeShader;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11ComputeShader() {
    out() << "// [DESTROY] ID3D11ComputeShader(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ComputeShader));
    m_pID3D11ComputeShader = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11InputLayout
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11InputLayout : public ID3D11InputLayout {
private:
  ID3D11InputLayout *m_pID3D11InputLayout;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11InputLayout(T *pWrapped) {
    out() << "// [CREATE] ID3D11InputLayout(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11InputLayout = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11InputLayout), (void **)&m_pID3D11InputLayout);
    if (!res) {
      m_pID3D11InputLayout->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11InputLayout);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11InputLayout)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11InputLayout;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11InputLayout() {
    out() << "// [DESTROY] ID3D11InputLayout(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11InputLayout));
    m_pID3D11InputLayout = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11SamplerState
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11SamplerState : public ID3D11SamplerState {
private:
  ID3D11SamplerState *m_pID3D11SamplerState;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11SamplerState(T *pWrapped) {
    out() << "// [CREATE] ID3D11SamplerState(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11SamplerState = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11SamplerState), (void **)&m_pID3D11SamplerState);
    if (!res) {
      m_pID3D11SamplerState->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11SamplerState);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11SamplerState)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11SamplerState;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11SamplerState() {
    out() << "// [DESTROY] ID3D11SamplerState(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11SamplerState));
    m_pID3D11SamplerState = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_SAMPLER_DESC * pDesc
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Predicate
inherits:
  ID3D11Query
  ID3D11Asynchronous
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3D11Predicate : public ID3D11Predicate {
private:
  ID3D11Predicate *m_pID3D11Predicate;
  ID3D11Query *m_pID3D11Query;
  ID3D11Asynchronous *m_pID3D11Asynchronous;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Predicate(T *pWrapped) {
    out() << "// [CREATE] ID3D11Predicate(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Asynchronous = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Asynchronous), (void **)&m_pID3D11Asynchronous);
    if (!res) {
      m_pID3D11Asynchronous->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Asynchronous;
    }
    m_pID3D11Query = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Query), (void **)&m_pID3D11Query);
    if (!res) {
      m_pID3D11Query->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Query);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Query)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Query;
    }
    m_pID3D11Predicate = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Predicate), (void **)&m_pID3D11Predicate);
    if (!res) {
      m_pID3D11Predicate->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Predicate);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Predicate)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Predicate;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Predicate() {
    out() << "// [DESTROY] ID3D11Predicate(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous));
    m_pID3D11Asynchronous = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Query));
    m_pID3D11Query = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Predicate));
    m_pID3D11Predicate = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_QUERY_DESC * pDesc
  ) override;
  UINT __stdcall GetDataSize() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Counter
inherits:
  ID3D11Asynchronous
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11Counter : public ID3D11Counter {
private:
  ID3D11Counter *m_pID3D11Counter;
  ID3D11Asynchronous *m_pID3D11Asynchronous;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Counter(T *pWrapped) {
    out() << "// [CREATE] ID3D11Counter(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Asynchronous = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Asynchronous), (void **)&m_pID3D11Asynchronous);
    if (!res) {
      m_pID3D11Asynchronous->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Asynchronous;
    }
    m_pID3D11Counter = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Counter), (void **)&m_pID3D11Counter);
    if (!res) {
      m_pID3D11Counter->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Counter);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Counter)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Counter;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Counter() {
    out() << "// [DESTROY] ID3D11Counter(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous));
    m_pID3D11Asynchronous = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Counter));
    m_pID3D11Counter = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_COUNTER_DESC * pDesc
  ) override;
  UINT __stdcall GetDataSize() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11ClassInstance
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetClassLinkage
  GetDesc
  GetInstanceName
  GetTypeName
end class
#endif
class WrappedID3D11ClassInstance : public ID3D11ClassInstance {
private:
  ID3D11ClassInstance *m_pID3D11ClassInstance;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11ClassInstance(T *pWrapped) {
    out() << "// [CREATE] ID3D11ClassInstance(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11ClassInstance = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ClassInstance), (void **)&m_pID3D11ClassInstance);
    if (!res) {
      m_pID3D11ClassInstance->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ClassInstance);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ClassInstance)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ClassInstance;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11ClassInstance() {
    out() << "// [DESTROY] ID3D11ClassInstance(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ClassInstance));
    m_pID3D11ClassInstance = nullptr;
  }
  void __stdcall GetClassLinkage(
    ID3D11ClassLinkage ** ppLinkage
  ) override;
  void __stdcall GetDesc(
    D3D11_CLASS_INSTANCE_DESC * pDesc
  ) override;
  void __stdcall GetInstanceName(
    LPSTR pInstanceName, 
    SIZE_T * pBufferLength
  ) override;
  void __stdcall GetTypeName(
    LPSTR pTypeName, 
    SIZE_T * pBufferLength
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11ClassLinkage
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetClassInstance
  CreateClassInstance
end class
#endif
class WrappedID3D11ClassLinkage : public ID3D11ClassLinkage {
private:
  ID3D11ClassLinkage *m_pID3D11ClassLinkage;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11ClassLinkage(T *pWrapped) {
    out() << "// [CREATE] ID3D11ClassLinkage(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11ClassLinkage = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ClassLinkage), (void **)&m_pID3D11ClassLinkage);
    if (!res) {
      m_pID3D11ClassLinkage->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ClassLinkage);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ClassLinkage)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ClassLinkage;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11ClassLinkage() {
    out() << "// [DESTROY] ID3D11ClassLinkage(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ClassLinkage));
    m_pID3D11ClassLinkage = nullptr;
  }
  HRESULT __stdcall GetClassInstance(
    LPCSTR pClassInstanceName, 
    UINT InstanceIndex, 
    ID3D11ClassInstance ** ppInstance
  ) override;
  HRESULT __stdcall CreateClassInstance(
    LPCSTR pClassTypeName, 
    UINT ConstantBufferOffset, 
    UINT ConstantVectorOffset, 
    UINT TextureOffset, 
    UINT SamplerOffset, 
    ID3D11ClassInstance ** ppInstance
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11CommandList
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetContextFlags
end class
#endif
class WrappedID3D11CommandList : public ID3D11CommandList {
private:
  ID3D11CommandList *m_pID3D11CommandList;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11CommandList(T *pWrapped) {
    out() << "// [CREATE] ID3D11CommandList(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11CommandList = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11CommandList), (void **)&m_pID3D11CommandList);
    if (!res) {
      m_pID3D11CommandList->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11CommandList);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11CommandList)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11CommandList;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11CommandList() {
    out() << "// [DESTROY] ID3D11CommandList(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11CommandList));
    m_pID3D11CommandList = nullptr;
  }
  UINT __stdcall GetContextFlags() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoDecoder
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetCreationParameters
  GetDriverHandle
end class
#endif
class WrappedID3D11VideoDecoder : public ID3D11VideoDecoder {
private:
  ID3D11VideoDecoder *m_pID3D11VideoDecoder;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoDecoder(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoDecoder(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11VideoDecoder = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoDecoder), (void **)&m_pID3D11VideoDecoder);
    if (!res) {
      m_pID3D11VideoDecoder->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoDecoder);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoDecoder)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoDecoder;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoDecoder() {
    out() << "// [DESTROY] ID3D11VideoDecoder(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoDecoder));
    m_pID3D11VideoDecoder = nullptr;
  }
  HRESULT __stdcall GetCreationParameters(
    D3D11_VIDEO_DECODER_DESC * pVideoDesc, 
    D3D11_VIDEO_DECODER_CONFIG * pConfig
  ) override;
  HRESULT __stdcall GetDriverHandle(
    HANDLE * pDriverHandle
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoProcessor
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetContentDesc
  GetRateConversionCaps
end class
#endif
class WrappedID3D11VideoProcessor : public ID3D11VideoProcessor {
private:
  ID3D11VideoProcessor *m_pID3D11VideoProcessor;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoProcessor(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoProcessor(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11VideoProcessor = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoProcessor), (void **)&m_pID3D11VideoProcessor);
    if (!res) {
      m_pID3D11VideoProcessor->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessor);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessor)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoProcessor;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoProcessor() {
    out() << "// [DESTROY] ID3D11VideoProcessor(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessor));
    m_pID3D11VideoProcessor = nullptr;
  }
  void __stdcall GetContentDesc(
    D3D11_VIDEO_PROCESSOR_CONTENT_DESC * pDesc
  ) override;
  void __stdcall GetRateConversionCaps(
    D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS * pCaps
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11AuthenticatedChannel
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetCertificateSize
  GetCertificate
  GetChannelHandle
end class
#endif
class WrappedID3D11AuthenticatedChannel : public ID3D11AuthenticatedChannel {
private:
  ID3D11AuthenticatedChannel *m_pID3D11AuthenticatedChannel;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11AuthenticatedChannel(T *pWrapped) {
    out() << "// [CREATE] ID3D11AuthenticatedChannel(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11AuthenticatedChannel = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11AuthenticatedChannel), (void **)&m_pID3D11AuthenticatedChannel);
    if (!res) {
      m_pID3D11AuthenticatedChannel->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11AuthenticatedChannel);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11AuthenticatedChannel)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11AuthenticatedChannel;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11AuthenticatedChannel() {
    out() << "// [DESTROY] ID3D11AuthenticatedChannel(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11AuthenticatedChannel));
    m_pID3D11AuthenticatedChannel = nullptr;
  }
  HRESULT __stdcall GetCertificateSize(
    UINT * pCertificateSize
  ) override;
  HRESULT __stdcall GetCertificate(
    UINT CertificateSize, 
    BYTE * pCertificate
  ) override;
  void __stdcall GetChannelHandle(
    HANDLE * pChannelHandle
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11CryptoSession
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  GetCryptoType
  GetDecoderProfile
  GetCertificateSize
  GetCertificate
  GetCryptoSessionHandle
end class
#endif
class WrappedID3D11CryptoSession : public ID3D11CryptoSession {
private:
  ID3D11CryptoSession *m_pID3D11CryptoSession;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11CryptoSession(T *pWrapped) {
    out() << "// [CREATE] ID3D11CryptoSession(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11CryptoSession = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11CryptoSession), (void **)&m_pID3D11CryptoSession);
    if (!res) {
      m_pID3D11CryptoSession->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11CryptoSession);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11CryptoSession)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11CryptoSession;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11CryptoSession() {
    out() << "// [DESTROY] ID3D11CryptoSession(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11CryptoSession));
    m_pID3D11CryptoSession = nullptr;
  }
  void __stdcall GetCryptoType(
    GUID * pCryptoType
  ) override;
  void __stdcall GetDecoderProfile(
    GUID * pDecoderProfile
  ) override;
  HRESULT __stdcall GetCertificateSize(
    UINT * pCertificateSize
  ) override;
  HRESULT __stdcall GetCertificate(
    UINT CertificateSize, 
    BYTE * pCertificate
  ) override;
  void __stdcall GetCryptoSessionHandle(
    HANDLE * pCryptoSessionHandle
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoDecoderOutputView
inherits:
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11VideoDecoderOutputView : public ID3D11VideoDecoderOutputView {
private:
  ID3D11VideoDecoderOutputView *m_pID3D11VideoDecoderOutputView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoDecoderOutputView(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoDecoderOutputView(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11VideoDecoderOutputView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoDecoderOutputView), (void **)&m_pID3D11VideoDecoderOutputView);
    if (!res) {
      m_pID3D11VideoDecoderOutputView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoDecoderOutputView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoDecoderOutputView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoDecoderOutputView;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoDecoderOutputView() {
    out() << "// [DESTROY] ID3D11VideoDecoderOutputView(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoDecoderOutputView));
    m_pID3D11VideoDecoderOutputView = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoProcessorInputView
inherits:
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11VideoProcessorInputView : public ID3D11VideoProcessorInputView {
private:
  ID3D11VideoProcessorInputView *m_pID3D11VideoProcessorInputView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoProcessorInputView(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoProcessorInputView(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11VideoProcessorInputView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoProcessorInputView), (void **)&m_pID3D11VideoProcessorInputView);
    if (!res) {
      m_pID3D11VideoProcessorInputView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorInputView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorInputView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoProcessorInputView;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoProcessorInputView() {
    out() << "// [DESTROY] ID3D11VideoProcessorInputView(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorInputView));
    m_pID3D11VideoProcessorInputView = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoProcessorOutputView
inherits:
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc
end class
#endif
class WrappedID3D11VideoProcessorOutputView : public ID3D11VideoProcessorOutputView {
private:
  ID3D11VideoProcessorOutputView *m_pID3D11VideoProcessorOutputView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoProcessorOutputView(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoProcessorOutputView(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11VideoProcessorOutputView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoProcessorOutputView), (void **)&m_pID3D11VideoProcessorOutputView);
    if (!res) {
      m_pID3D11VideoProcessorOutputView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorOutputView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorOutputView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoProcessorOutputView;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoProcessorOutputView() {
    out() << "// [DESTROY] ID3D11VideoProcessorOutputView(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorOutputView));
    m_pID3D11VideoProcessorOutputView = nullptr;
  }
  void __stdcall GetDesc(
    D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Debug
inherits:
  IUnknown
methods:
  SetFeatureMask
  GetFeatureMask
  SetPresentPerRenderOpDelay
  GetPresentPerRenderOpDelay
  SetSwapChain
  GetSwapChain
  ValidateContext
  ReportLiveDeviceObjects
  ValidateContextForDispatch
end class
#endif
class WrappedID3D11Debug : public ID3D11Debug {
private:
  ID3D11Debug *m_pID3D11Debug;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Debug(T *pWrapped) {
    out() << "// [CREATE] ID3D11Debug(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11Debug = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Debug), (void **)&m_pID3D11Debug);
    if (!res) {
      m_pID3D11Debug->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Debug);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Debug)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Debug;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Debug() {
    out() << "// [DESTROY] ID3D11Debug(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Debug));
    m_pID3D11Debug = nullptr;
  }
  HRESULT __stdcall SetFeatureMask(
    UINT Mask
  ) override;
  UINT __stdcall GetFeatureMask() override;
  HRESULT __stdcall SetPresentPerRenderOpDelay(
    UINT Milliseconds
  ) override;
  UINT __stdcall GetPresentPerRenderOpDelay() override;
  HRESULT __stdcall SetSwapChain(
    IDXGISwapChain * pSwapChain
  ) override;
  HRESULT __stdcall GetSwapChain(
    IDXGISwapChain ** ppSwapChain
  ) override;
  HRESULT __stdcall ValidateContext(
    ID3D11DeviceContext * pContext
  ) override;
  HRESULT __stdcall ReportLiveDeviceObjects(
    D3D11_RLDO_FLAGS Flags
  ) override;
  HRESULT __stdcall ValidateContextForDispatch(
    ID3D11DeviceContext * pContext
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11SwitchToRef
inherits:
  IUnknown
methods:
  SetUseRef
  GetUseRef
end class
#endif
class WrappedID3D11SwitchToRef : public ID3D11SwitchToRef {
private:
  ID3D11SwitchToRef *m_pID3D11SwitchToRef;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11SwitchToRef(T *pWrapped) {
    out() << "// [CREATE] ID3D11SwitchToRef(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11SwitchToRef = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11SwitchToRef), (void **)&m_pID3D11SwitchToRef);
    if (!res) {
      m_pID3D11SwitchToRef->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11SwitchToRef);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11SwitchToRef)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11SwitchToRef;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11SwitchToRef() {
    out() << "// [DESTROY] ID3D11SwitchToRef(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11SwitchToRef));
    m_pID3D11SwitchToRef = nullptr;
  }
  BOOL __stdcall SetUseRef(
    BOOL UseRef
  ) override;
  BOOL __stdcall GetUseRef() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11TracingDevice
inherits:
  IUnknown
methods:
  SetShaderTrackingOptionsByType
  SetShaderTrackingOptions
end class
#endif
class WrappedID3D11TracingDevice : public ID3D11TracingDevice {
private:
  ID3D11TracingDevice *m_pID3D11TracingDevice;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11TracingDevice(T *pWrapped) {
    out() << "// [CREATE] ID3D11TracingDevice(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11TracingDevice = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11TracingDevice), (void **)&m_pID3D11TracingDevice);
    if (!res) {
      m_pID3D11TracingDevice->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11TracingDevice);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11TracingDevice)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11TracingDevice;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11TracingDevice() {
    out() << "// [DESTROY] ID3D11TracingDevice(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11TracingDevice));
    m_pID3D11TracingDevice = nullptr;
  }
  HRESULT __stdcall SetShaderTrackingOptionsByType(
    UINT ResourceTypeFlags, 
    UINT Options
  ) override;
  HRESULT __stdcall SetShaderTrackingOptions(
    struct IUnknown * pShader, 
    UINT Options
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11RefTrackingOptions
inherits:
  IUnknown
methods:
  SetTrackingOptions
end class
#endif
class WrappedID3D11RefTrackingOptions : public ID3D11RefTrackingOptions {
private:
  ID3D11RefTrackingOptions *m_pID3D11RefTrackingOptions;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11RefTrackingOptions(T *pWrapped) {
    out() << "// [CREATE] ID3D11RefTrackingOptions(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11RefTrackingOptions = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RefTrackingOptions), (void **)&m_pID3D11RefTrackingOptions);
    if (!res) {
      m_pID3D11RefTrackingOptions->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RefTrackingOptions);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RefTrackingOptions)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RefTrackingOptions;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11RefTrackingOptions() {
    out() << "// [DESTROY] ID3D11RefTrackingOptions(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RefTrackingOptions));
    m_pID3D11RefTrackingOptions = nullptr;
  }
  HRESULT __stdcall SetTrackingOptions(
    UINT uOptions
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11RefDefaultTrackingOptions
inherits:
  IUnknown
methods:
  SetTrackingOptions
end class
#endif
class WrappedID3D11RefDefaultTrackingOptions : public ID3D11RefDefaultTrackingOptions {
private:
  ID3D11RefDefaultTrackingOptions *m_pID3D11RefDefaultTrackingOptions;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11RefDefaultTrackingOptions(T *pWrapped) {
    out() << "// [CREATE] ID3D11RefDefaultTrackingOptions(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11RefDefaultTrackingOptions = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RefDefaultTrackingOptions), (void **)&m_pID3D11RefDefaultTrackingOptions);
    if (!res) {
      m_pID3D11RefDefaultTrackingOptions->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RefDefaultTrackingOptions);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RefDefaultTrackingOptions)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RefDefaultTrackingOptions;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11RefDefaultTrackingOptions() {
    out() << "// [DESTROY] ID3D11RefDefaultTrackingOptions(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RefDefaultTrackingOptions));
    m_pID3D11RefDefaultTrackingOptions = nullptr;
  }
  HRESULT __stdcall SetTrackingOptions(
    UINT ResourceTypeFlags, 
    UINT Options
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11InfoQueue
inherits:
  IUnknown
methods:
  SetMessageCountLimit
  ClearStoredMessages
  GetMessageW
  GetNumMessagesAllowedByStorageFilter
  GetNumMessagesDeniedByStorageFilter
  GetNumStoredMessages
  GetNumStoredMessagesAllowedByRetrievalFilter
  GetNumMessagesDiscardedByMessageCountLimit
  GetMessageCountLimit
  AddStorageFilterEntries
  GetStorageFilter
  ClearStorageFilter
  PushEmptyStorageFilter
  PushCopyOfStorageFilter
  PushStorageFilter
  PopStorageFilter
  GetStorageFilterStackSize
  AddRetrievalFilterEntries
  GetRetrievalFilter
  ClearRetrievalFilter
  PushEmptyRetrievalFilter
  PushCopyOfRetrievalFilter
  PushRetrievalFilter
  PopRetrievalFilter
  GetRetrievalFilterStackSize
  AddMessage
  AddApplicationMessage
  SetBreakOnCategory
  SetBreakOnSeverity
  SetBreakOnID
  GetBreakOnCategory
  GetBreakOnSeverity
  GetBreakOnID
  SetMuteDebugOutput
  GetMuteDebugOutput
end class
#endif
class WrappedID3D11InfoQueue : public ID3D11InfoQueue {
private:
  ID3D11InfoQueue *m_pID3D11InfoQueue;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11InfoQueue(T *pWrapped) {
    out() << "// [CREATE] ID3D11InfoQueue(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11InfoQueue = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11InfoQueue), (void **)&m_pID3D11InfoQueue);
    if (!res) {
      m_pID3D11InfoQueue->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11InfoQueue);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11InfoQueue)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11InfoQueue;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11InfoQueue() {
    out() << "// [DESTROY] ID3D11InfoQueue(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11InfoQueue));
    m_pID3D11InfoQueue = nullptr;
  }
  HRESULT __stdcall SetMessageCountLimit(
    UINT64 MessageCountLimit
  ) override;
  void __stdcall ClearStoredMessages() override;
  HRESULT __stdcall GetMessageW(
    UINT64 MessageIndex, 
    D3D11_MESSAGE * pMessage, 
    SIZE_T * pMessageByteLength
  ) override;
  UINT64 __stdcall GetNumMessagesAllowedByStorageFilter() override;
  UINT64 __stdcall GetNumMessagesDeniedByStorageFilter() override;
  UINT64 __stdcall GetNumStoredMessages() override;
  UINT64 __stdcall GetNumStoredMessagesAllowedByRetrievalFilter() override;
  UINT64 __stdcall GetNumMessagesDiscardedByMessageCountLimit() override;
  UINT64 __stdcall GetMessageCountLimit() override;
  HRESULT __stdcall AddStorageFilterEntries(
    D3D11_INFO_QUEUE_FILTER * pFilter
  ) override;
  HRESULT __stdcall GetStorageFilter(
    D3D11_INFO_QUEUE_FILTER * pFilter, 
    SIZE_T * pFilterByteLength
  ) override;
  void __stdcall ClearStorageFilter() override;
  HRESULT __stdcall PushEmptyStorageFilter() override;
  HRESULT __stdcall PushCopyOfStorageFilter() override;
  HRESULT __stdcall PushStorageFilter(
    D3D11_INFO_QUEUE_FILTER * pFilter
  ) override;
  void __stdcall PopStorageFilter() override;
  UINT __stdcall GetStorageFilterStackSize() override;
  HRESULT __stdcall AddRetrievalFilterEntries(
    D3D11_INFO_QUEUE_FILTER * pFilter
  ) override;
  HRESULT __stdcall GetRetrievalFilter(
    D3D11_INFO_QUEUE_FILTER * pFilter, 
    SIZE_T * pFilterByteLength
  ) override;
  void __stdcall ClearRetrievalFilter() override;
  HRESULT __stdcall PushEmptyRetrievalFilter() override;
  HRESULT __stdcall PushCopyOfRetrievalFilter() override;
  HRESULT __stdcall PushRetrievalFilter(
    D3D11_INFO_QUEUE_FILTER * pFilter
  ) override;
  void __stdcall PopRetrievalFilter() override;
  UINT __stdcall GetRetrievalFilterStackSize() override;
  HRESULT __stdcall AddMessage(
    D3D11_MESSAGE_CATEGORY Category, 
    D3D11_MESSAGE_SEVERITY Severity, 
    D3D11_MESSAGE_ID ID, 
    LPCSTR pDescription
  ) override;
  HRESULT __stdcall AddApplicationMessage(
    D3D11_MESSAGE_SEVERITY Severity, 
    LPCSTR pDescription
  ) override;
  HRESULT __stdcall SetBreakOnCategory(
    D3D11_MESSAGE_CATEGORY Category, 
    BOOL bEnable
  ) override;
  HRESULT __stdcall SetBreakOnSeverity(
    D3D11_MESSAGE_SEVERITY Severity, 
    BOOL bEnable
  ) override;
  HRESULT __stdcall SetBreakOnID(
    D3D11_MESSAGE_ID ID, 
    BOOL bEnable
  ) override;
  BOOL __stdcall GetBreakOnCategory(
    D3D11_MESSAGE_CATEGORY Category
  ) override;
  BOOL __stdcall GetBreakOnSeverity(
    D3D11_MESSAGE_SEVERITY Severity
  ) override;
  BOOL __stdcall GetBreakOnID(
    D3D11_MESSAGE_ID ID
  ) override;
  void __stdcall SetMuteDebugOutput(
    BOOL bMute
  ) override;
  BOOL __stdcall GetMuteDebugOutput() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3DDeviceContextState
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
end class
#endif
class WrappedID3DDeviceContextState : public ID3DDeviceContextState {
private:
  ID3DDeviceContextState *m_pID3DDeviceContextState;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3DDeviceContextState(T *pWrapped) {
    out() << "// [CREATE] ID3DDeviceContextState(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3DDeviceContextState = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3DDeviceContextState), (void **)&m_pID3DDeviceContextState);
    if (!res) {
      m_pID3DDeviceContextState->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3DDeviceContextState);
      wt[reinterpret_cast<size_t>((void*)m_pID3DDeviceContextState)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3DDeviceContextState;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3DDeviceContextState() {
    out() << "// [DESTROY] ID3DDeviceContextState(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3DDeviceContextState));
    m_pID3DDeviceContextState = nullptr;
  }
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIDisplayControl
inherits:
  IUnknown
methods:
  IsStereoEnabled
  SetStereoEnabled
end class
#endif
class WrappedIDXGIDisplayControl : public IDXGIDisplayControl {
private:
  IDXGIDisplayControl *m_pIDXGIDisplayControl;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIDisplayControl(T *pWrapped) {
    out() << "// [CREATE] IDXGIDisplayControl(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIDisplayControl = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDisplayControl), (void **)&m_pIDXGIDisplayControl);
    if (!res) {
      m_pIDXGIDisplayControl->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDisplayControl);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDisplayControl)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDisplayControl;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIDisplayControl() {
    out() << "// [DESTROY] IDXGIDisplayControl(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDisplayControl));
    m_pIDXGIDisplayControl = nullptr;
  }
  BOOL __stdcall IsStereoEnabled() override;
  void __stdcall SetStereoEnabled(
    BOOL enabled
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIOutputDuplication
inherits:
  IDXGIObject
  IUnknown
methods:
  GetDesc
  AcquireNextFrame
  GetFrameDirtyRects
  GetFrameMoveRects
  GetFramePointerShape
  MapDesktopSurface
  UnMapDesktopSurface
  ReleaseFrame
end class
#endif
class WrappedIDXGIOutputDuplication : public IDXGIOutputDuplication {
private:
  IDXGIOutputDuplication *m_pIDXGIOutputDuplication;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIOutputDuplication(T *pWrapped) {
    out() << "// [CREATE] IDXGIOutputDuplication(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIOutputDuplication = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutputDuplication), (void **)&m_pIDXGIOutputDuplication);
    if (!res) {
      m_pIDXGIOutputDuplication->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutputDuplication);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutputDuplication)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutputDuplication;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIOutputDuplication() {
    out() << "// [DESTROY] IDXGIOutputDuplication(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutputDuplication));
    m_pIDXGIOutputDuplication = nullptr;
  }
  void __stdcall GetDesc(
    DXGI_OUTDUPL_DESC * pDesc
  ) override;
  HRESULT __stdcall AcquireNextFrame(
    UINT TimeoutInMilliseconds, 
    DXGI_OUTDUPL_FRAME_INFO * pFrameInfo, 
    IDXGIResource ** ppDesktopResource
  ) override;
  HRESULT __stdcall GetFrameDirtyRects(
    UINT DirtyRectsBufferSize, 
    RECT * pDirtyRectsBuffer, 
    UINT * pDirtyRectsBufferSizeRequired
  ) override;
  HRESULT __stdcall GetFrameMoveRects(
    UINT MoveRectsBufferSize, 
    DXGI_OUTDUPL_MOVE_RECT * pMoveRectBuffer, 
    UINT * pMoveRectsBufferSizeRequired
  ) override;
  HRESULT __stdcall GetFramePointerShape(
    UINT PointerShapeBufferSize, 
    void * pPointerShapeBuffer, 
    UINT * pPointerShapeBufferSizeRequired, 
    DXGI_OUTDUPL_POINTER_SHAPE_INFO * pPointerShapeInfo
  ) override;
  HRESULT __stdcall MapDesktopSurface(
    DXGI_MAPPED_RECT * pLockedRect
  ) override;
  HRESULT __stdcall UnMapDesktopSurface() override;
  HRESULT __stdcall ReleaseFrame() override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGISurface2
inherits:
  IDXGISurface1
  IDXGISurface
  IDXGIDeviceSubObject
  IDXGIObject
  IUnknown
methods:
  GetResource
end class
#endif
class WrappedIDXGISurface2 : public IDXGISurface2 {
private:
  IDXGISurface2 *m_pIDXGISurface2;
  IDXGISurface1 *m_pIDXGISurface1;
  IDXGISurface *m_pIDXGISurface;
  IDXGIDeviceSubObject *m_pIDXGIDeviceSubObject;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGISurface2(T *pWrapped) {
    out() << "// [CREATE] IDXGISurface2(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIDeviceSubObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDeviceSubObject), (void **)&m_pIDXGIDeviceSubObject);
    if (!res) {
      m_pIDXGIDeviceSubObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDeviceSubObject;
    }
    m_pIDXGISurface = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISurface), (void **)&m_pIDXGISurface);
    if (!res) {
      m_pIDXGISurface->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISurface);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISurface)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISurface;
    }
    m_pIDXGISurface1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISurface1), (void **)&m_pIDXGISurface1);
    if (!res) {
      m_pIDXGISurface1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISurface1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISurface1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISurface1;
    }
    m_pIDXGISurface2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISurface2), (void **)&m_pIDXGISurface2);
    if (!res) {
      m_pIDXGISurface2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISurface2);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISurface2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISurface2;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGISurface2() {
    out() << "// [DESTROY] IDXGISurface2(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject));
    m_pIDXGIDeviceSubObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISurface));
    m_pIDXGISurface = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISurface1));
    m_pIDXGISurface1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISurface2));
    m_pIDXGISurface2 = nullptr;
  }
  HRESULT __stdcall GetResource(
    const IID & riid, 
    void ** ppParentResource, 
    UINT * pSubresourceIndex
  ) override;
  HRESULT __stdcall GetDC(
    BOOL Discard, 
    HDC * phdc
  ) override;
  HRESULT __stdcall ReleaseDC(
    RECT * pDirtyRect
  ) override;
  HRESULT __stdcall GetDesc(
    DXGI_SURFACE_DESC * pDesc
  ) override;
  HRESULT __stdcall Map(
    DXGI_MAPPED_RECT * pLockedRect, 
    UINT MapFlags
  ) override;
  HRESULT __stdcall Unmap() override;
  HRESULT __stdcall GetDevice(
    const IID & riid, 
    void ** ppDevice
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIResource1
inherits:
  IDXGIResource
  IDXGIDeviceSubObject
  IDXGIObject
  IUnknown
methods:
  CreateSubresourceSurface
  CreateSharedHandle
end class
#endif
class WrappedIDXGIResource1 : public IDXGIResource1 {
private:
  IDXGIResource1 *m_pIDXGIResource1;
  IDXGIResource *m_pIDXGIResource;
  IDXGIDeviceSubObject *m_pIDXGIDeviceSubObject;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIResource1(T *pWrapped) {
    out() << "// [CREATE] IDXGIResource1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIDeviceSubObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDeviceSubObject), (void **)&m_pIDXGIDeviceSubObject);
    if (!res) {
      m_pIDXGIDeviceSubObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDeviceSubObject;
    }
    m_pIDXGIResource = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIResource), (void **)&m_pIDXGIResource);
    if (!res) {
      m_pIDXGIResource->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIResource);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIResource)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIResource;
    }
    m_pIDXGIResource1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIResource1), (void **)&m_pIDXGIResource1);
    if (!res) {
      m_pIDXGIResource1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIResource1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIResource1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIResource1;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIResource1() {
    out() << "// [DESTROY] IDXGIResource1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject));
    m_pIDXGIDeviceSubObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIResource));
    m_pIDXGIResource = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIResource1));
    m_pIDXGIResource1 = nullptr;
  }
  HRESULT __stdcall CreateSubresourceSurface(
    UINT index, 
    IDXGISurface2 ** ppSurface
  ) override;
  HRESULT __stdcall CreateSharedHandle(
    const SECURITY_ATTRIBUTES * pAttributes, 
    DWORD dwAccess, 
    LPCWSTR lpName, 
    HANDLE * pHandle
  ) override;
  HRESULT __stdcall GetSharedHandle(
    HANDLE * pSharedHandle
  ) override;
  HRESULT __stdcall GetUsage(
    DXGI_USAGE * pUsage
  ) override;
  HRESULT __stdcall SetEvictionPriority(
    UINT EvictionPriority
  ) override;
  HRESULT __stdcall GetEvictionPriority(
    UINT * pEvictionPriority
  ) override;
  HRESULT __stdcall GetDevice(
    const IID & riid, 
    void ** ppDevice
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11BlendState1
inherits:
  ID3D11BlendState
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11BlendState1 : public ID3D11BlendState1 {
private:
  ID3D11BlendState1 *m_pID3D11BlendState1;
  ID3D11BlendState *m_pID3D11BlendState;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11BlendState1(T *pWrapped) {
    out() << "// [CREATE] ID3D11BlendState1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11BlendState = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11BlendState), (void **)&m_pID3D11BlendState);
    if (!res) {
      m_pID3D11BlendState->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11BlendState);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11BlendState)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11BlendState;
    }
    m_pID3D11BlendState1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11BlendState1), (void **)&m_pID3D11BlendState1);
    if (!res) {
      m_pID3D11BlendState1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11BlendState1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11BlendState1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11BlendState1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11BlendState1() {
    out() << "// [DESTROY] ID3D11BlendState1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11BlendState));
    m_pID3D11BlendState = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11BlendState1));
    m_pID3D11BlendState1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_BLEND_DESC1 * pDesc
  ) override;
  void __stdcall GetDesc(
    D3D11_BLEND_DESC * pDesc
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoProcessorEnumerator1
inherits:
  ID3D11VideoProcessorEnumerator
  ID3D11DeviceChild
  IUnknown
methods:
  CheckVideoProcessorFormatConversion
end class
#endif
class WrappedID3D11VideoProcessorEnumerator1 : public ID3D11VideoProcessorEnumerator1 {
private:
  ID3D11VideoProcessorEnumerator1 *m_pID3D11VideoProcessorEnumerator1;
  ID3D11VideoProcessorEnumerator *m_pID3D11VideoProcessorEnumerator;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoProcessorEnumerator1(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoProcessorEnumerator1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11VideoProcessorEnumerator = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoProcessorEnumerator), (void **)&m_pID3D11VideoProcessorEnumerator);
    if (!res) {
      m_pID3D11VideoProcessorEnumerator->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorEnumerator);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorEnumerator)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoProcessorEnumerator;
    }
    m_pID3D11VideoProcessorEnumerator1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoProcessorEnumerator1), (void **)&m_pID3D11VideoProcessorEnumerator1);
    if (!res) {
      m_pID3D11VideoProcessorEnumerator1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorEnumerator1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorEnumerator1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoProcessorEnumerator1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoProcessorEnumerator1() {
    out() << "// [DESTROY] ID3D11VideoProcessorEnumerator1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorEnumerator));
    m_pID3D11VideoProcessorEnumerator = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoProcessorEnumerator1));
    m_pID3D11VideoProcessorEnumerator1 = nullptr;
  }
  HRESULT __stdcall CheckVideoProcessorFormatConversion(
    DXGI_FORMAT InputFormat, 
    DXGI_COLOR_SPACE_TYPE InputColorSpace, 
    DXGI_FORMAT OutputFormat, 
    DXGI_COLOR_SPACE_TYPE OutputColorSpace, 
    BOOL * pSupported
  ) override;
  HRESULT __stdcall GetVideoProcessorContentDesc(
    D3D11_VIDEO_PROCESSOR_CONTENT_DESC * pContentDesc
  ) override;
  HRESULT __stdcall CheckVideoProcessorFormat(
    DXGI_FORMAT Format, 
    UINT * pFlags
  ) override;
  HRESULT __stdcall GetVideoProcessorCaps(
    D3D11_VIDEO_PROCESSOR_CAPS * pCaps
  ) override;
  HRESULT __stdcall GetVideoProcessorRateConversionCaps(
    UINT TypeIndex, 
    D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS * pCaps
  ) override;
  HRESULT __stdcall GetVideoProcessorCustomRate(
    UINT TypeIndex, 
    UINT CustomRateIndex, 
    D3D11_VIDEO_PROCESSOR_CUSTOM_RATE * pRate
  ) override;
  HRESULT __stdcall GetVideoProcessorFilterRange(
    D3D11_VIDEO_PROCESSOR_FILTER Filter, 
    D3D11_VIDEO_PROCESSOR_FILTER_RANGE * pRange
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3DUserDefinedAnnotation
inherits:
  IUnknown
methods:
  BeginEvent
  EndEvent
  SetMarker
  GetStatus
end class
#endif
class WrappedID3DUserDefinedAnnotation : public ID3DUserDefinedAnnotation {
private:
  ID3DUserDefinedAnnotation *m_pID3DUserDefinedAnnotation;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3DUserDefinedAnnotation(T *pWrapped) {
    out() << "// [CREATE] ID3DUserDefinedAnnotation(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3DUserDefinedAnnotation = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3DUserDefinedAnnotation), (void **)&m_pID3DUserDefinedAnnotation);
    if (!res) {
      m_pID3DUserDefinedAnnotation->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3DUserDefinedAnnotation);
      wt[reinterpret_cast<size_t>((void*)m_pID3DUserDefinedAnnotation)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3DUserDefinedAnnotation;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3DUserDefinedAnnotation() {
    out() << "// [DESTROY] ID3DUserDefinedAnnotation(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3DUserDefinedAnnotation));
    m_pID3DUserDefinedAnnotation = nullptr;
  }
  INT __stdcall BeginEvent(
    LPCWSTR Name
  ) override;
  INT __stdcall EndEvent() override;
  void __stdcall SetMarker(
    LPCWSTR Name
  ) override;
  BOOL __stdcall GetStatus() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIDecodeSwapChain
inherits:
  IUnknown
methods:
  PresentBuffer
  SetSourceRect
  SetTargetRect
  SetDestSize
  GetSourceRect
  GetTargetRect
  GetDestSize
  SetColorSpace
  GetColorSpace
end class
#endif
class WrappedIDXGIDecodeSwapChain : public IDXGIDecodeSwapChain {
private:
  IDXGIDecodeSwapChain *m_pIDXGIDecodeSwapChain;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIDecodeSwapChain(T *pWrapped) {
    out() << "// [CREATE] IDXGIDecodeSwapChain(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIDecodeSwapChain = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDecodeSwapChain), (void **)&m_pIDXGIDecodeSwapChain);
    if (!res) {
      m_pIDXGIDecodeSwapChain->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDecodeSwapChain);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDecodeSwapChain)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDecodeSwapChain;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIDecodeSwapChain() {
    out() << "// [DESTROY] IDXGIDecodeSwapChain(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDecodeSwapChain));
    m_pIDXGIDecodeSwapChain = nullptr;
  }
  HRESULT __stdcall PresentBuffer(
    UINT BufferToPresent, 
    UINT SyncInterval, 
    UINT Flags
  ) override;
  HRESULT __stdcall SetSourceRect(
    const RECT * pRect
  ) override;
  HRESULT __stdcall SetTargetRect(
    const RECT * pRect
  ) override;
  HRESULT __stdcall SetDestSize(
    UINT Width, 
    UINT Height
  ) override;
  HRESULT __stdcall GetSourceRect(
    RECT * pRect
  ) override;
  HRESULT __stdcall GetTargetRect(
    RECT * pRect
  ) override;
  HRESULT __stdcall GetDestSize(
    UINT * pWidth, 
    UINT * pHeight
  ) override;
  HRESULT __stdcall SetColorSpace(
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS ColorSpace
  ) override;
  DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS __stdcall GetColorSpace() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIFactoryMedia
inherits:
  IUnknown
methods:
  CreateSwapChainForCompositionSurfaceHandle
  CreateDecodeSwapChainForCompositionSurfaceHandle
end class
#endif
class WrappedIDXGIFactoryMedia : public IDXGIFactoryMedia {
private:
  IDXGIFactoryMedia *m_pIDXGIFactoryMedia;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIFactoryMedia(T *pWrapped) {
    out() << "// [CREATE] IDXGIFactoryMedia(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIFactoryMedia = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactoryMedia), (void **)&m_pIDXGIFactoryMedia);
    if (!res) {
      m_pIDXGIFactoryMedia->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactoryMedia);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactoryMedia)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactoryMedia;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIFactoryMedia() {
    out() << "// [DESTROY] IDXGIFactoryMedia(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactoryMedia));
    m_pIDXGIFactoryMedia = nullptr;
  }
  HRESULT __stdcall CreateSwapChainForCompositionSurfaceHandle(
    struct IUnknown * pDevice, 
    HANDLE hSurface, 
    const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
    IDXGIOutput * pRestrictToOutput, 
    IDXGISwapChain1 ** ppSwapChain
  ) override;
  HRESULT __stdcall CreateDecodeSwapChainForCompositionSurfaceHandle(
    struct IUnknown * pDevice, 
    HANDLE hSurface, 
    DXGI_DECODE_SWAP_CHAIN_DESC * pDesc, 
    IDXGIResource * pYuvDecodeBuffers, 
    IDXGIOutput * pRestrictToOutput, 
    IDXGIDecodeSwapChain ** ppSwapChain
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGISwapChainMedia
inherits:
  IUnknown
methods:
  GetFrameStatisticsMedia
  SetPresentDuration
  CheckPresentDurationSupport
end class
#endif
class WrappedIDXGISwapChainMedia : public IDXGISwapChainMedia {
private:
  IDXGISwapChainMedia *m_pIDXGISwapChainMedia;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGISwapChainMedia(T *pWrapped) {
    out() << "// [CREATE] IDXGISwapChainMedia(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGISwapChainMedia = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISwapChainMedia), (void **)&m_pIDXGISwapChainMedia);
    if (!res) {
      m_pIDXGISwapChainMedia->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISwapChainMedia);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISwapChainMedia)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISwapChainMedia;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGISwapChainMedia() {
    out() << "// [DESTROY] IDXGISwapChainMedia(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISwapChainMedia));
    m_pIDXGISwapChainMedia = nullptr;
  }
  HRESULT __stdcall GetFrameStatisticsMedia(
    DXGI_FRAME_STATISTICS_MEDIA * pStats
  ) override;
  HRESULT __stdcall SetPresentDuration(
    UINT Duration
  ) override;
  HRESULT __stdcall CheckPresentDurationSupport(
    UINT DesiredPresentDuration, 
    UINT * pClosestSmallerPresentDuration, 
    UINT * pClosestLargerPresentDuration
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Texture2D1
inherits:
  ID3D11Texture2D
  ID3D11Resource
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11Texture2D1 : public ID3D11Texture2D1 {
private:
  ID3D11Texture2D1 *m_pID3D11Texture2D1;
  ID3D11Texture2D *m_pID3D11Texture2D;
  ID3D11Resource *m_pID3D11Resource;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Texture2D1(T *pWrapped) {
    out() << "// [CREATE] ID3D11Texture2D1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Resource = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Resource), (void **)&m_pID3D11Resource);
    if (!res) {
      m_pID3D11Resource->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Resource);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Resource)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Resource;
    }
    m_pID3D11Texture2D = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Texture2D), (void **)&m_pID3D11Texture2D);
    if (!res) {
      m_pID3D11Texture2D->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Texture2D);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Texture2D)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Texture2D;
    }
    m_pID3D11Texture2D1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Texture2D1), (void **)&m_pID3D11Texture2D1);
    if (!res) {
      m_pID3D11Texture2D1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Texture2D1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Texture2D1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Texture2D1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Texture2D1() {
    out() << "// [DESTROY] ID3D11Texture2D1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Resource));
    m_pID3D11Resource = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Texture2D));
    m_pID3D11Texture2D = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Texture2D1));
    m_pID3D11Texture2D1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_TEXTURE2D_DESC1 * pDesc
  ) override;
  void __stdcall GetDesc(
    D3D11_TEXTURE2D_DESC * pDesc
  ) override;
  void __stdcall GetType(
    D3D11_RESOURCE_DIMENSION * pResourceDimension
  ) override;
  void __stdcall SetEvictionPriority(
    UINT EvictionPriority
  ) override;
  UINT __stdcall GetEvictionPriority() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Texture3D1
inherits:
  ID3D11Texture3D
  ID3D11Resource
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11Texture3D1 : public ID3D11Texture3D1 {
private:
  ID3D11Texture3D1 *m_pID3D11Texture3D1;
  ID3D11Texture3D *m_pID3D11Texture3D;
  ID3D11Resource *m_pID3D11Resource;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Texture3D1(T *pWrapped) {
    out() << "// [CREATE] ID3D11Texture3D1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Resource = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Resource), (void **)&m_pID3D11Resource);
    if (!res) {
      m_pID3D11Resource->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Resource);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Resource)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Resource;
    }
    m_pID3D11Texture3D = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Texture3D), (void **)&m_pID3D11Texture3D);
    if (!res) {
      m_pID3D11Texture3D->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Texture3D);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Texture3D)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Texture3D;
    }
    m_pID3D11Texture3D1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Texture3D1), (void **)&m_pID3D11Texture3D1);
    if (!res) {
      m_pID3D11Texture3D1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Texture3D1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Texture3D1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Texture3D1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Texture3D1() {
    out() << "// [DESTROY] ID3D11Texture3D1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Resource));
    m_pID3D11Resource = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Texture3D));
    m_pID3D11Texture3D = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Texture3D1));
    m_pID3D11Texture3D1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_TEXTURE3D_DESC1 * pDesc
  ) override;
  void __stdcall GetDesc(
    D3D11_TEXTURE3D_DESC * pDesc
  ) override;
  void __stdcall GetType(
    D3D11_RESOURCE_DIMENSION * pResourceDimension
  ) override;
  void __stdcall SetEvictionPriority(
    UINT EvictionPriority
  ) override;
  UINT __stdcall GetEvictionPriority() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11RasterizerState2
inherits:
  ID3D11RasterizerState1
  ID3D11RasterizerState
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc2
end class
#endif
class WrappedID3D11RasterizerState2 : public ID3D11RasterizerState2 {
private:
  ID3D11RasterizerState2 *m_pID3D11RasterizerState2;
  ID3D11RasterizerState1 *m_pID3D11RasterizerState1;
  ID3D11RasterizerState *m_pID3D11RasterizerState;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11RasterizerState2(T *pWrapped) {
    out() << "// [CREATE] ID3D11RasterizerState2(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11RasterizerState = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RasterizerState), (void **)&m_pID3D11RasterizerState);
    if (!res) {
      m_pID3D11RasterizerState->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RasterizerState;
    }
    m_pID3D11RasterizerState1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RasterizerState1), (void **)&m_pID3D11RasterizerState1);
    if (!res) {
      m_pID3D11RasterizerState1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RasterizerState1;
    }
    m_pID3D11RasterizerState2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RasterizerState2), (void **)&m_pID3D11RasterizerState2);
    if (!res) {
      m_pID3D11RasterizerState2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState2);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RasterizerState2;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11RasterizerState2() {
    out() << "// [DESTROY] ID3D11RasterizerState2(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState));
    m_pID3D11RasterizerState = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState1));
    m_pID3D11RasterizerState1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RasterizerState2));
    m_pID3D11RasterizerState2 = nullptr;
  }
  void __stdcall GetDesc2(
    D3D11_RASTERIZER_DESC2 * pDesc
  ) override;
  void __stdcall GetDesc1(
    D3D11_RASTERIZER_DESC1 * pDesc
  ) override;
  void __stdcall GetDesc(
    D3D11_RASTERIZER_DESC * pDesc
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11ShaderResourceView1
inherits:
  ID3D11ShaderResourceView
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11ShaderResourceView1 : public ID3D11ShaderResourceView1 {
private:
  ID3D11ShaderResourceView1 *m_pID3D11ShaderResourceView1;
  ID3D11ShaderResourceView *m_pID3D11ShaderResourceView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11ShaderResourceView1(T *pWrapped) {
    out() << "// [CREATE] ID3D11ShaderResourceView1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11ShaderResourceView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ShaderResourceView), (void **)&m_pID3D11ShaderResourceView);
    if (!res) {
      m_pID3D11ShaderResourceView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ShaderResourceView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ShaderResourceView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ShaderResourceView;
    }
    m_pID3D11ShaderResourceView1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ShaderResourceView1), (void **)&m_pID3D11ShaderResourceView1);
    if (!res) {
      m_pID3D11ShaderResourceView1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ShaderResourceView1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ShaderResourceView1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ShaderResourceView1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11ShaderResourceView1() {
    out() << "// [DESTROY] ID3D11ShaderResourceView1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ShaderResourceView));
    m_pID3D11ShaderResourceView = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ShaderResourceView1));
    m_pID3D11ShaderResourceView1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_SHADER_RESOURCE_VIEW_DESC1 * pDesc1
  ) override;
  void __stdcall GetDesc(
    D3D11_SHADER_RESOURCE_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11RenderTargetView1
inherits:
  ID3D11RenderTargetView
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11RenderTargetView1 : public ID3D11RenderTargetView1 {
private:
  ID3D11RenderTargetView1 *m_pID3D11RenderTargetView1;
  ID3D11RenderTargetView *m_pID3D11RenderTargetView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11RenderTargetView1(T *pWrapped) {
    out() << "// [CREATE] ID3D11RenderTargetView1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11RenderTargetView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RenderTargetView), (void **)&m_pID3D11RenderTargetView);
    if (!res) {
      m_pID3D11RenderTargetView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RenderTargetView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RenderTargetView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RenderTargetView;
    }
    m_pID3D11RenderTargetView1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11RenderTargetView1), (void **)&m_pID3D11RenderTargetView1);
    if (!res) {
      m_pID3D11RenderTargetView1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11RenderTargetView1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11RenderTargetView1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11RenderTargetView1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11RenderTargetView1() {
    out() << "// [DESTROY] ID3D11RenderTargetView1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RenderTargetView));
    m_pID3D11RenderTargetView = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11RenderTargetView1));
    m_pID3D11RenderTargetView1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_RENDER_TARGET_VIEW_DESC1 * pDesc1
  ) override;
  void __stdcall GetDesc(
    D3D11_RENDER_TARGET_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11UnorderedAccessView1
inherits:
  ID3D11UnorderedAccessView
  ID3D11View
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11UnorderedAccessView1 : public ID3D11UnorderedAccessView1 {
private:
  ID3D11UnorderedAccessView1 *m_pID3D11UnorderedAccessView1;
  ID3D11UnorderedAccessView *m_pID3D11UnorderedAccessView;
  ID3D11View *m_pID3D11View;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11UnorderedAccessView1(T *pWrapped) {
    out() << "// [CREATE] ID3D11UnorderedAccessView1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11View = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11View), (void **)&m_pID3D11View);
    if (!res) {
      m_pID3D11View->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11View);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11View)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11View;
    }
    m_pID3D11UnorderedAccessView = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11UnorderedAccessView), (void **)&m_pID3D11UnorderedAccessView);
    if (!res) {
      m_pID3D11UnorderedAccessView->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11UnorderedAccessView);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11UnorderedAccessView)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11UnorderedAccessView;
    }
    m_pID3D11UnorderedAccessView1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11UnorderedAccessView1), (void **)&m_pID3D11UnorderedAccessView1);
    if (!res) {
      m_pID3D11UnorderedAccessView1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11UnorderedAccessView1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11UnorderedAccessView1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11UnorderedAccessView1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11UnorderedAccessView1() {
    out() << "// [DESTROY] ID3D11UnorderedAccessView1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11View));
    m_pID3D11View = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11UnorderedAccessView));
    m_pID3D11UnorderedAccessView = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11UnorderedAccessView1));
    m_pID3D11UnorderedAccessView1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_UNORDERED_ACCESS_VIEW_DESC1 * pDesc1
  ) override;
  void __stdcall GetDesc(
    D3D11_UNORDERED_ACCESS_VIEW_DESC * pDesc
  ) override;
  void __stdcall GetResource(
    ID3D11Resource ** ppResource
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Query1
inherits:
  ID3D11Query
  ID3D11Asynchronous
  ID3D11DeviceChild
  IUnknown
methods:
  GetDesc1
end class
#endif
class WrappedID3D11Query1 : public ID3D11Query1 {
private:
  ID3D11Query1 *m_pID3D11Query1;
  ID3D11Query *m_pID3D11Query;
  ID3D11Asynchronous *m_pID3D11Asynchronous;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Query1(T *pWrapped) {
    out() << "// [CREATE] ID3D11Query1(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Asynchronous = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Asynchronous), (void **)&m_pID3D11Asynchronous);
    if (!res) {
      m_pID3D11Asynchronous->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Asynchronous;
    }
    m_pID3D11Query = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Query), (void **)&m_pID3D11Query);
    if (!res) {
      m_pID3D11Query->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Query);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Query)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Query;
    }
    m_pID3D11Query1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Query1), (void **)&m_pID3D11Query1);
    if (!res) {
      m_pID3D11Query1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Query1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Query1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Query1;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Query1() {
    out() << "// [DESTROY] ID3D11Query1(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Asynchronous));
    m_pID3D11Asynchronous = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Query));
    m_pID3D11Query = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Query1));
    m_pID3D11Query1 = nullptr;
  }
  void __stdcall GetDesc1(
    D3D11_QUERY_DESC1 * pDesc1
  ) override;
  void __stdcall GetDesc(
    D3D11_QUERY_DESC * pDesc
  ) override;
  UINT __stdcall GetDataSize() override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Fence
inherits:
  ID3D11DeviceChild
  IUnknown
methods:
  CreateSharedHandle
  GetCompletedValue
  SetEventOnCompletion
end class
#endif
class WrappedID3D11Fence : public ID3D11Fence {
private:
  ID3D11Fence *m_pID3D11Fence;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Fence(T *pWrapped) {
    out() << "// [CREATE] ID3D11Fence(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11Fence = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Fence), (void **)&m_pID3D11Fence);
    if (!res) {
      m_pID3D11Fence->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Fence);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Fence)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Fence;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Fence() {
    out() << "// [DESTROY] ID3D11Fence(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Fence));
    m_pID3D11Fence = nullptr;
  }
  HRESULT __stdcall CreateSharedHandle(
    const SECURITY_ATTRIBUTES * pAttributes, 
    DWORD dwAccess, 
    LPCWSTR lpName, 
    HANDLE * pHandle
  ) override;
  UINT64 __stdcall GetCompletedValue() override;
  HRESULT __stdcall SetEventOnCompletion(
    UINT64 Value, 
    HANDLE hEvent
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11DeviceContext4
inherits:
  ID3D11DeviceContext3
  ID3D11DeviceContext2
  ID3D11DeviceContext1
  ID3D11DeviceContext
  ID3D11DeviceChild
  IUnknown
methods:
  Signal
  Wait
end class
#endif
class WrappedID3D11DeviceContext4 : public ID3D11DeviceContext4 {
private:
  ID3D11DeviceContext4 *m_pID3D11DeviceContext4;
  ID3D11DeviceContext3 *m_pID3D11DeviceContext3;
  ID3D11DeviceContext2 *m_pID3D11DeviceContext2;
  ID3D11DeviceContext1 *m_pID3D11DeviceContext1;
  ID3D11DeviceContext *m_pID3D11DeviceContext;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11DeviceContext4(T *pWrapped) {
    out() << "// [CREATE] ID3D11DeviceContext4(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11DeviceContext = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceContext), (void **)&m_pID3D11DeviceContext);
    if (!res) {
      m_pID3D11DeviceContext->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceContext;
    }
    m_pID3D11DeviceContext1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceContext1), (void **)&m_pID3D11DeviceContext1);
    if (!res) {
      m_pID3D11DeviceContext1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceContext1;
    }
    m_pID3D11DeviceContext2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceContext2), (void **)&m_pID3D11DeviceContext2);
    if (!res) {
      m_pID3D11DeviceContext2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext2);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceContext2;
    }
    m_pID3D11DeviceContext3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceContext3), (void **)&m_pID3D11DeviceContext3);
    if (!res) {
      m_pID3D11DeviceContext3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext3);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceContext3;
    }
    m_pID3D11DeviceContext4 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceContext4), (void **)&m_pID3D11DeviceContext4);
    if (!res) {
      m_pID3D11DeviceContext4->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext4);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext4)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceContext4;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11DeviceContext4() {
    out() << "// [DESTROY] ID3D11DeviceContext4(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext));
    m_pID3D11DeviceContext = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext1));
    m_pID3D11DeviceContext1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext2));
    m_pID3D11DeviceContext2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext3));
    m_pID3D11DeviceContext3 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceContext4));
    m_pID3D11DeviceContext4 = nullptr;
  }
  HRESULT __stdcall Signal(
    ID3D11Fence * pFence, 
    UINT64 Value
  ) override;
  HRESULT __stdcall Wait(
    ID3D11Fence * pFence, 
    UINT64 Value
  ) override;
  void __stdcall Flush1(
    D3D11_CONTEXT_TYPE ContextType, 
    HANDLE hEvent
  ) override;
  void __stdcall SetHardwareProtectionState(
    BOOL HwProtectionEnable
  ) override;
  void __stdcall GetHardwareProtectionState(
    BOOL * pHwProtectionEnable
  ) override;
  HRESULT __stdcall UpdateTileMappings(
    ID3D11Resource * pTiledResource, 
    UINT NumTiledResourceRegions, 
    const D3D11_TILED_RESOURCE_COORDINATE * pTiledResourceRegionStartCoordinates, 
    const D3D11_TILE_REGION_SIZE * pTiledResourceRegionSizes, 
    ID3D11Buffer * pTilePool, 
    UINT NumRanges, 
    const UINT * pRangeFlags, 
    const UINT * pTilePoolStartOffsets, 
    const UINT * pRangeTileCounts, 
    UINT Flags
  ) override;
  HRESULT __stdcall CopyTileMappings(
    ID3D11Resource * pDestTiledResource, 
    const D3D11_TILED_RESOURCE_COORDINATE * pDestRegionStartCoordinate, 
    ID3D11Resource * pSourceTiledResource, 
    const D3D11_TILED_RESOURCE_COORDINATE * pSourceRegionStartCoordinate, 
    const D3D11_TILE_REGION_SIZE * pTileRegionSize, 
    UINT Flags
  ) override;
  void __stdcall CopyTiles(
    ID3D11Resource * pTiledResource, 
    const D3D11_TILED_RESOURCE_COORDINATE * pTileRegionStartCoordinate, 
    const D3D11_TILE_REGION_SIZE * pTileRegionSize, 
    ID3D11Buffer * pBuffer, 
    UINT64 BufferStartOffsetInBytes, 
    UINT Flags
  ) override;
  void __stdcall UpdateTiles(
    ID3D11Resource * pDestTiledResource, 
    const D3D11_TILED_RESOURCE_COORDINATE * pDestTileRegionStartCoordinate, 
    const D3D11_TILE_REGION_SIZE * pDestTileRegionSize, 
    const void * pSourceTileData, 
    UINT Flags
  ) override;
  HRESULT __stdcall ResizeTilePool(
    ID3D11Buffer * pTilePool, 
    UINT64 NewSizeInBytes
  ) override;
  void __stdcall TiledResourceBarrier(
    struct ID3D11DeviceChild * pTiledResourceOrViewAccessBeforeBarrier, 
    struct ID3D11DeviceChild * pTiledResourceOrViewAccessAfterBarrier
  ) override;
  BOOL __stdcall IsAnnotationEnabled() override;
  void __stdcall SetMarkerInt(
    LPCWSTR pLabel, 
    INT Data
  ) override;
  void __stdcall BeginEventInt(
    LPCWSTR pLabel, 
    INT Data
  ) override;
  void __stdcall EndEvent() override;
  void __stdcall CopySubresourceRegion1(
    ID3D11Resource * pDstResource, 
    UINT DstSubresource, 
    UINT DstX, 
    UINT DstY, 
    UINT DstZ, 
    ID3D11Resource * pSrcResource, 
    UINT SrcSubresource, 
    const D3D11_BOX * pSrcBox, 
    UINT CopyFlags
  ) override;
  void __stdcall UpdateSubresource1(
    ID3D11Resource * pDstResource, 
    UINT DstSubresource, 
    const D3D11_BOX * pDstBox, 
    const void * pSrcData, 
    UINT SrcRowPitch, 
    UINT SrcDepthPitch, 
    UINT CopyFlags
  ) override;
  void __stdcall DiscardResource(
    ID3D11Resource * pResource
  ) override;
  void __stdcall DiscardView(
    ID3D11View * pResourceView
  ) override;
  void __stdcall VSSetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers, 
    const UINT * pFirstConstant, 
    const UINT * pNumConstants
  ) override;
  void __stdcall HSSetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers, 
    const UINT * pFirstConstant, 
    const UINT * pNumConstants
  ) override;
  void __stdcall DSSetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers, 
    const UINT * pFirstConstant, 
    const UINT * pNumConstants
  ) override;
  void __stdcall GSSetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers, 
    const UINT * pFirstConstant, 
    const UINT * pNumConstants
  ) override;
  void __stdcall PSSetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers, 
    const UINT * pFirstConstant, 
    const UINT * pNumConstants
  ) override;
  void __stdcall CSSetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers, 
    const UINT * pFirstConstant, 
    const UINT * pNumConstants
  ) override;
  void __stdcall VSGetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers, 
    UINT * pFirstConstant, 
    UINT * pNumConstants
  ) override;
  void __stdcall HSGetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers, 
    UINT * pFirstConstant, 
    UINT * pNumConstants
  ) override;
  void __stdcall DSGetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers, 
    UINT * pFirstConstant, 
    UINT * pNumConstants
  ) override;
  void __stdcall GSGetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers, 
    UINT * pFirstConstant, 
    UINT * pNumConstants
  ) override;
  void __stdcall PSGetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers, 
    UINT * pFirstConstant, 
    UINT * pNumConstants
  ) override;
  void __stdcall CSGetConstantBuffers1(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers, 
    UINT * pFirstConstant, 
    UINT * pNumConstants
  ) override;
  void __stdcall SwapDeviceContextState(
    ID3DDeviceContextState * pState, 
    ID3DDeviceContextState ** ppPreviousState
  ) override;
  void __stdcall ClearView(
    ID3D11View * pView, 
    const FLOAT * Color, 
    const D3D11_RECT * pRect, 
    UINT NumRects
  ) override;
  void __stdcall DiscardView1(
    ID3D11View * pResourceView, 
    const D3D11_RECT * pRects, 
    UINT NumRects
  ) override;
  void __stdcall VSSetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers
  ) override;
  void __stdcall PSSetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView *const * ppShaderResourceViews
  ) override;
  void __stdcall PSSetShader(
    ID3D11PixelShader * pPixelShader, 
    ID3D11ClassInstance *const * ppClassInstances, 
    UINT NumClassInstances
  ) override;
  void __stdcall PSSetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState *const * ppSamplers
  ) override;
  void __stdcall VSSetShader(
    ID3D11VertexShader * pVertexShader, 
    ID3D11ClassInstance *const * ppClassInstances, 
    UINT NumClassInstances
  ) override;
  void __stdcall DrawIndexed(
    UINT IndexCount, 
    UINT StartIndexLocation, 
    INT BaseVertexLocation
  ) override;
  void __stdcall Draw(
    UINT VertexCount, 
    UINT StartVertexLocation
  ) override;
  HRESULT __stdcall Map(
    ID3D11Resource * pResource, 
    UINT Subresource, 
    D3D11_MAP MapType, 
    UINT MapFlags, 
    D3D11_MAPPED_SUBRESOURCE * pMappedResource
  ) override;
  void __stdcall Unmap(
    ID3D11Resource * pResource, 
    UINT Subresource
  ) override;
  void __stdcall PSSetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers
  ) override;
  void __stdcall IASetInputLayout(
    ID3D11InputLayout * pInputLayout
  ) override;
  void __stdcall IASetVertexBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppVertexBuffers, 
    const UINT * pStrides, 
    const UINT * pOffsets
  ) override;
  void __stdcall IASetIndexBuffer(
    ID3D11Buffer * pIndexBuffer, 
    DXGI_FORMAT Format, 
    UINT Offset
  ) override;
  void __stdcall DrawIndexedInstanced(
    UINT IndexCountPerInstance, 
    UINT InstanceCount, 
    UINT StartIndexLocation, 
    INT BaseVertexLocation, 
    UINT StartInstanceLocation
  ) override;
  void __stdcall DrawInstanced(
    UINT VertexCountPerInstance, 
    UINT InstanceCount, 
    UINT StartVertexLocation, 
    UINT StartInstanceLocation
  ) override;
  void __stdcall GSSetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers
  ) override;
  void __stdcall GSSetShader(
    ID3D11GeometryShader * pShader, 
    ID3D11ClassInstance *const * ppClassInstances, 
    UINT NumClassInstances
  ) override;
  void __stdcall IASetPrimitiveTopology(
    D3D11_PRIMITIVE_TOPOLOGY Topology
  ) override;
  void __stdcall VSSetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView *const * ppShaderResourceViews
  ) override;
  void __stdcall VSSetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState *const * ppSamplers
  ) override;
  void __stdcall Begin(
    ID3D11Asynchronous * pAsync
  ) override;
  void __stdcall End(
    ID3D11Asynchronous * pAsync
  ) override;
  HRESULT __stdcall GetData(
    ID3D11Asynchronous * pAsync, 
    void * pData, 
    UINT DataSize, 
    UINT GetDataFlags
  ) override;
  void __stdcall SetPredication(
    ID3D11Predicate * pPredicate, 
    BOOL PredicateValue
  ) override;
  void __stdcall GSSetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView *const * ppShaderResourceViews
  ) override;
  void __stdcall GSSetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState *const * ppSamplers
  ) override;
  void __stdcall OMSetRenderTargets(
    UINT NumViews, 
    ID3D11RenderTargetView *const * ppRenderTargetViews, 
    ID3D11DepthStencilView * pDepthStencilView
  ) override;
  void __stdcall OMSetRenderTargetsAndUnorderedAccessViews(
    UINT NumRTVs, 
    ID3D11RenderTargetView *const * ppRenderTargetViews, 
    ID3D11DepthStencilView * pDepthStencilView, 
    UINT UAVStartSlot, 
    UINT NumUAVs, 
    ID3D11UnorderedAccessView *const * ppUnorderedAccessViews, 
    const UINT * pUAVInitialCounts
  ) override;
  void __stdcall OMSetBlendState(
    ID3D11BlendState * pBlendState, 
    const FLOAT * BlendFactor, 
    UINT SampleMask
  ) override;
  void __stdcall OMSetDepthStencilState(
    ID3D11DepthStencilState * pDepthStencilState, 
    UINT StencilRef
  ) override;
  void __stdcall SOSetTargets(
    UINT NumBuffers, 
    ID3D11Buffer *const * ppSOTargets, 
    const UINT * pOffsets
  ) override;
  void __stdcall DrawAuto() override;
  void __stdcall DrawIndexedInstancedIndirect(
    ID3D11Buffer * pBufferForArgs, 
    UINT AlignedByteOffsetForArgs
  ) override;
  void __stdcall DrawInstancedIndirect(
    ID3D11Buffer * pBufferForArgs, 
    UINT AlignedByteOffsetForArgs
  ) override;
  void __stdcall Dispatch(
    UINT ThreadGroupCountX, 
    UINT ThreadGroupCountY, 
    UINT ThreadGroupCountZ
  ) override;
  void __stdcall DispatchIndirect(
    ID3D11Buffer * pBufferForArgs, 
    UINT AlignedByteOffsetForArgs
  ) override;
  void __stdcall RSSetState(
    ID3D11RasterizerState * pRasterizerState
  ) override;
  void __stdcall RSSetViewports(
    UINT NumViewports, 
    const D3D11_VIEWPORT * pViewports
  ) override;
  void __stdcall RSSetScissorRects(
    UINT NumRects, 
    const D3D11_RECT * pRects
  ) override;
  void __stdcall CopySubresourceRegion(
    ID3D11Resource * pDstResource, 
    UINT DstSubresource, 
    UINT DstX, 
    UINT DstY, 
    UINT DstZ, 
    ID3D11Resource * pSrcResource, 
    UINT SrcSubresource, 
    const D3D11_BOX * pSrcBox
  ) override;
  void __stdcall CopyResource(
    ID3D11Resource * pDstResource, 
    ID3D11Resource * pSrcResource
  ) override;
  void __stdcall UpdateSubresource(
    ID3D11Resource * pDstResource, 
    UINT DstSubresource, 
    const D3D11_BOX * pDstBox, 
    const void * pSrcData, 
    UINT SrcRowPitch, 
    UINT SrcDepthPitch
  ) override;
  void __stdcall CopyStructureCount(
    ID3D11Buffer * pDstBuffer, 
    UINT DstAlignedByteOffset, 
    ID3D11UnorderedAccessView * pSrcView
  ) override;
  void __stdcall ClearRenderTargetView(
    ID3D11RenderTargetView * pRenderTargetView, 
    const FLOAT * ColorRGBA
  ) override;
  void __stdcall ClearUnorderedAccessViewUint(
    ID3D11UnorderedAccessView * pUnorderedAccessView, 
    const UINT * Values
  ) override;
  void __stdcall ClearUnorderedAccessViewFloat(
    ID3D11UnorderedAccessView * pUnorderedAccessView, 
    const FLOAT * Values
  ) override;
  void __stdcall ClearDepthStencilView(
    ID3D11DepthStencilView * pDepthStencilView, 
    UINT ClearFlags, 
    FLOAT Depth, 
    UINT8 Stencil
  ) override;
  void __stdcall GenerateMips(
    ID3D11ShaderResourceView * pShaderResourceView
  ) override;
  void __stdcall SetResourceMinLOD(
    ID3D11Resource * pResource, 
    FLOAT MinLOD
  ) override;
  FLOAT __stdcall GetResourceMinLOD(
    ID3D11Resource * pResource
  ) override;
  void __stdcall ResolveSubresource(
    ID3D11Resource * pDstResource, 
    UINT DstSubresource, 
    ID3D11Resource * pSrcResource, 
    UINT SrcSubresource, 
    DXGI_FORMAT Format
  ) override;
  void __stdcall ExecuteCommandList(
    ID3D11CommandList * pCommandList, 
    BOOL RestoreContextState
  ) override;
  void __stdcall HSSetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView *const * ppShaderResourceViews
  ) override;
  void __stdcall HSSetShader(
    ID3D11HullShader * pHullShader, 
    ID3D11ClassInstance *const * ppClassInstances, 
    UINT NumClassInstances
  ) override;
  void __stdcall HSSetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState *const * ppSamplers
  ) override;
  void __stdcall HSSetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers
  ) override;
  void __stdcall DSSetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView *const * ppShaderResourceViews
  ) override;
  void __stdcall DSSetShader(
    ID3D11DomainShader * pDomainShader, 
    ID3D11ClassInstance *const * ppClassInstances, 
    UINT NumClassInstances
  ) override;
  void __stdcall DSSetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState *const * ppSamplers
  ) override;
  void __stdcall DSSetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers
  ) override;
  void __stdcall CSSetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView *const * ppShaderResourceViews
  ) override;
  void __stdcall CSSetUnorderedAccessViews(
    UINT StartSlot, 
    UINT NumUAVs, 
    ID3D11UnorderedAccessView *const * ppUnorderedAccessViews, 
    const UINT * pUAVInitialCounts
  ) override;
  void __stdcall CSSetShader(
    ID3D11ComputeShader * pComputeShader, 
    ID3D11ClassInstance *const * ppClassInstances, 
    UINT NumClassInstances
  ) override;
  void __stdcall CSSetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState *const * ppSamplers
  ) override;
  void __stdcall CSSetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer *const * ppConstantBuffers
  ) override;
  void __stdcall VSGetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers
  ) override;
  void __stdcall PSGetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView ** ppShaderResourceViews
  ) override;
  void __stdcall PSGetShader(
    ID3D11PixelShader ** ppPixelShader, 
    ID3D11ClassInstance ** ppClassInstances, 
    UINT * pNumClassInstances
  ) override;
  void __stdcall PSGetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState ** ppSamplers
  ) override;
  void __stdcall VSGetShader(
    ID3D11VertexShader ** ppVertexShader, 
    ID3D11ClassInstance ** ppClassInstances, 
    UINT * pNumClassInstances
  ) override;
  void __stdcall PSGetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers
  ) override;
  void __stdcall IAGetInputLayout(
    ID3D11InputLayout ** ppInputLayout
  ) override;
  void __stdcall IAGetVertexBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppVertexBuffers, 
    UINT * pStrides, 
    UINT * pOffsets
  ) override;
  void __stdcall IAGetIndexBuffer(
    ID3D11Buffer ** pIndexBuffer, 
    DXGI_FORMAT * Format, 
    UINT * Offset
  ) override;
  void __stdcall GSGetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers
  ) override;
  void __stdcall GSGetShader(
    ID3D11GeometryShader ** ppGeometryShader, 
    ID3D11ClassInstance ** ppClassInstances, 
    UINT * pNumClassInstances
  ) override;
  void __stdcall IAGetPrimitiveTopology(
    D3D11_PRIMITIVE_TOPOLOGY * pTopology
  ) override;
  void __stdcall VSGetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView ** ppShaderResourceViews
  ) override;
  void __stdcall VSGetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState ** ppSamplers
  ) override;
  void __stdcall GetPredication(
    ID3D11Predicate ** ppPredicate, 
    BOOL * pPredicateValue
  ) override;
  void __stdcall GSGetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView ** ppShaderResourceViews
  ) override;
  void __stdcall GSGetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState ** ppSamplers
  ) override;
  void __stdcall OMGetRenderTargets(
    UINT NumViews, 
    ID3D11RenderTargetView ** ppRenderTargetViews, 
    ID3D11DepthStencilView ** ppDepthStencilView
  ) override;
  void __stdcall OMGetRenderTargetsAndUnorderedAccessViews(
    UINT NumRTVs, 
    ID3D11RenderTargetView ** ppRenderTargetViews, 
    ID3D11DepthStencilView ** ppDepthStencilView, 
    UINT UAVStartSlot, 
    UINT NumUAVs, 
    ID3D11UnorderedAccessView ** ppUnorderedAccessViews
  ) override;
  void __stdcall OMGetBlendState(
    ID3D11BlendState ** ppBlendState, 
    FLOAT * BlendFactor, 
    UINT * pSampleMask
  ) override;
  void __stdcall OMGetDepthStencilState(
    ID3D11DepthStencilState ** ppDepthStencilState, 
    UINT * pStencilRef
  ) override;
  void __stdcall SOGetTargets(
    UINT NumBuffers, 
    ID3D11Buffer ** ppSOTargets
  ) override;
  void __stdcall RSGetState(
    ID3D11RasterizerState ** ppRasterizerState
  ) override;
  void __stdcall RSGetViewports(
    UINT * pNumViewports, 
    D3D11_VIEWPORT * pViewports
  ) override;
  void __stdcall RSGetScissorRects(
    UINT * pNumRects, 
    D3D11_RECT * pRects
  ) override;
  void __stdcall HSGetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView ** ppShaderResourceViews
  ) override;
  void __stdcall HSGetShader(
    ID3D11HullShader ** ppHullShader, 
    ID3D11ClassInstance ** ppClassInstances, 
    UINT * pNumClassInstances
  ) override;
  void __stdcall HSGetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState ** ppSamplers
  ) override;
  void __stdcall HSGetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers
  ) override;
  void __stdcall DSGetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView ** ppShaderResourceViews
  ) override;
  void __stdcall DSGetShader(
    ID3D11DomainShader ** ppDomainShader, 
    ID3D11ClassInstance ** ppClassInstances, 
    UINT * pNumClassInstances
  ) override;
  void __stdcall DSGetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState ** ppSamplers
  ) override;
  void __stdcall DSGetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers
  ) override;
  void __stdcall CSGetShaderResources(
    UINT StartSlot, 
    UINT NumViews, 
    ID3D11ShaderResourceView ** ppShaderResourceViews
  ) override;
  void __stdcall CSGetUnorderedAccessViews(
    UINT StartSlot, 
    UINT NumUAVs, 
    ID3D11UnorderedAccessView ** ppUnorderedAccessViews
  ) override;
  void __stdcall CSGetShader(
    ID3D11ComputeShader ** ppComputeShader, 
    ID3D11ClassInstance ** ppClassInstances, 
    UINT * pNumClassInstances
  ) override;
  void __stdcall CSGetSamplers(
    UINT StartSlot, 
    UINT NumSamplers, 
    ID3D11SamplerState ** ppSamplers
  ) override;
  void __stdcall CSGetConstantBuffers(
    UINT StartSlot, 
    UINT NumBuffers, 
    ID3D11Buffer ** ppConstantBuffers
  ) override;
  void __stdcall ClearState() override;
  void __stdcall Flush() override;
  D3D11_DEVICE_CONTEXT_TYPE __stdcall GetType() override;
  UINT __stdcall GetContextFlags() override;
  HRESULT __stdcall FinishCommandList(
    BOOL RestoreDeferredContextState, 
    ID3D11CommandList ** ppCommandList
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIAdapter3
inherits:
  IDXGIAdapter2
  IDXGIAdapter1
  IDXGIAdapter
  IDXGIObject
  IUnknown
methods:
  RegisterHardwareContentProtectionTeardownStatusEvent
  UnregisterHardwareContentProtectionTeardownStatus
  QueryVideoMemoryInfo
  SetVideoMemoryReservation
  RegisterVideoMemoryBudgetChangeNotificationEvent
  UnregisterVideoMemoryBudgetChangeNotification
end class
#endif
class WrappedIDXGIAdapter3 : public IDXGIAdapter3 {
private:
  IDXGIAdapter3 *m_pIDXGIAdapter3;
  IDXGIAdapter2 *m_pIDXGIAdapter2;
  IDXGIAdapter1 *m_pIDXGIAdapter1;
  IDXGIAdapter *m_pIDXGIAdapter;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIAdapter3(T *pWrapped) {
    out() << "// [CREATE] IDXGIAdapter3(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIAdapter = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIAdapter), (void **)&m_pIDXGIAdapter);
    if (!res) {
      m_pIDXGIAdapter->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIAdapter);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIAdapter)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIAdapter;
    }
    m_pIDXGIAdapter1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIAdapter1), (void **)&m_pIDXGIAdapter1);
    if (!res) {
      m_pIDXGIAdapter1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIAdapter1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIAdapter1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIAdapter1;
    }
    m_pIDXGIAdapter2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIAdapter2), (void **)&m_pIDXGIAdapter2);
    if (!res) {
      m_pIDXGIAdapter2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIAdapter2);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIAdapter2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIAdapter2;
    }
    m_pIDXGIAdapter3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIAdapter3), (void **)&m_pIDXGIAdapter3);
    if (!res) {
      m_pIDXGIAdapter3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIAdapter3);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIAdapter3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIAdapter3;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIAdapter3() {
    out() << "// [DESTROY] IDXGIAdapter3(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIAdapter));
    m_pIDXGIAdapter = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIAdapter1));
    m_pIDXGIAdapter1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIAdapter2));
    m_pIDXGIAdapter2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIAdapter3));
    m_pIDXGIAdapter3 = nullptr;
  }
  HRESULT __stdcall RegisterHardwareContentProtectionTeardownStatusEvent(
    HANDLE hEvent, 
    DWORD * pdwCookie
  ) override;
  void __stdcall UnregisterHardwareContentProtectionTeardownStatus(
    DWORD dwCookie
  ) override;
  HRESULT __stdcall QueryVideoMemoryInfo(
    UINT NodeIndex, 
    DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup, 
    DXGI_QUERY_VIDEO_MEMORY_INFO * pVideoMemoryInfo
  ) override;
  HRESULT __stdcall SetVideoMemoryReservation(
    UINT NodeIndex, 
    DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup, 
    UINT64 Reservation
  ) override;
  HRESULT __stdcall RegisterVideoMemoryBudgetChangeNotificationEvent(
    HANDLE hEvent, 
    DWORD * pdwCookie
  ) override;
  void __stdcall UnregisterVideoMemoryBudgetChangeNotification(
    DWORD dwCookie
  ) override;
  HRESULT __stdcall GetDesc2(
    DXGI_ADAPTER_DESC2 * pDesc
  ) override;
  HRESULT __stdcall GetDesc1(
    DXGI_ADAPTER_DESC1 * pDesc
  ) override;
  HRESULT __stdcall EnumOutputs(
    UINT Output, 
    IDXGIOutput ** ppOutput
  ) override;
  HRESULT __stdcall GetDesc(
    DXGI_ADAPTER_DESC * pDesc
  ) override;
  HRESULT __stdcall CheckInterfaceSupport(
    const GUID & InterfaceName, 
    LARGE_INTEGER * pUMDVersion
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIOutput5
inherits:
  IDXGIOutput4
  IDXGIOutput3
  IDXGIOutput2
  IDXGIOutput1
  IDXGIOutput
  IDXGIObject
  IUnknown
methods:
  DuplicateOutput1
end class
#endif
class WrappedIDXGIOutput5 : public IDXGIOutput5 {
private:
  IDXGIOutput5 *m_pIDXGIOutput5;
  IDXGIOutput4 *m_pIDXGIOutput4;
  IDXGIOutput3 *m_pIDXGIOutput3;
  IDXGIOutput2 *m_pIDXGIOutput2;
  IDXGIOutput1 *m_pIDXGIOutput1;
  IDXGIOutput *m_pIDXGIOutput;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIOutput5(T *pWrapped) {
    out() << "// [CREATE] IDXGIOutput5(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIOutput = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutput), (void **)&m_pIDXGIOutput);
    if (!res) {
      m_pIDXGIOutput->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutput);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutput)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutput;
    }
    m_pIDXGIOutput1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutput1), (void **)&m_pIDXGIOutput1);
    if (!res) {
      m_pIDXGIOutput1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutput1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutput1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutput1;
    }
    m_pIDXGIOutput2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutput2), (void **)&m_pIDXGIOutput2);
    if (!res) {
      m_pIDXGIOutput2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutput2);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutput2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutput2;
    }
    m_pIDXGIOutput3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutput3), (void **)&m_pIDXGIOutput3);
    if (!res) {
      m_pIDXGIOutput3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutput3);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutput3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutput3;
    }
    m_pIDXGIOutput4 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutput4), (void **)&m_pIDXGIOutput4);
    if (!res) {
      m_pIDXGIOutput4->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutput4);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutput4)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutput4;
    }
    m_pIDXGIOutput5 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIOutput5), (void **)&m_pIDXGIOutput5);
    if (!res) {
      m_pIDXGIOutput5->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIOutput5);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIOutput5)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIOutput5;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIOutput5() {
    out() << "// [DESTROY] IDXGIOutput5(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutput));
    m_pIDXGIOutput = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutput1));
    m_pIDXGIOutput1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutput2));
    m_pIDXGIOutput2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutput3));
    m_pIDXGIOutput3 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutput4));
    m_pIDXGIOutput4 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIOutput5));
    m_pIDXGIOutput5 = nullptr;
  }
  HRESULT __stdcall DuplicateOutput1(
    struct IUnknown * pDevice, 
    UINT Flags, 
    UINT SupportedFormatsCount, 
    const DXGI_FORMAT * pSupportedFormats, 
    IDXGIOutputDuplication ** ppOutputDuplication
  ) override;
  HRESULT __stdcall CheckOverlayColorSpaceSupport(
    DXGI_FORMAT Format, 
    DXGI_COLOR_SPACE_TYPE ColorSpace, 
    struct IUnknown * pConcernedDevice, 
    UINT * pFlags
  ) override;
  HRESULT __stdcall CheckOverlaySupport(
    DXGI_FORMAT EnumFormat, 
    struct IUnknown * pConcernedDevice, 
    UINT * pFlags
  ) override;
  BOOL __stdcall SupportsOverlays() override;
  HRESULT __stdcall GetDisplayModeList1(
    DXGI_FORMAT EnumFormat, 
    UINT Flags, 
    UINT * pNumModes, 
    DXGI_MODE_DESC1 * pDesc
  ) override;
  HRESULT __stdcall FindClosestMatchingMode1(
    const DXGI_MODE_DESC1 * pModeToMatch, 
    DXGI_MODE_DESC1 * pClosestMatch, 
    struct IUnknown * pConcernedDevice
  ) override;
  HRESULT __stdcall GetDisplaySurfaceData1(
    IDXGIResource * pDestination
  ) override;
  HRESULT __stdcall DuplicateOutput(
    struct IUnknown * pDevice, 
    IDXGIOutputDuplication ** ppOutputDuplication
  ) override;
  HRESULT __stdcall GetDesc(
    DXGI_OUTPUT_DESC * pDesc
  ) override;
  HRESULT __stdcall GetDisplayModeList(
    DXGI_FORMAT EnumFormat, 
    UINT Flags, 
    UINT * pNumModes, 
    DXGI_MODE_DESC * pDesc
  ) override;
  HRESULT __stdcall FindClosestMatchingMode(
    const DXGI_MODE_DESC * pModeToMatch, 
    DXGI_MODE_DESC * pClosestMatch, 
    struct IUnknown * pConcernedDevice
  ) override;
  HRESULT __stdcall WaitForVBlank() override;
  HRESULT __stdcall TakeOwnership(
    struct IUnknown * pDevice, 
    BOOL Exclusive
  ) override;
  void __stdcall ReleaseOwnership() override;
  HRESULT __stdcall GetGammaControlCapabilities(
    DXGI_GAMMA_CONTROL_CAPABILITIES * pGammaCaps
  ) override;
  HRESULT __stdcall SetGammaControl(
    const DXGI_GAMMA_CONTROL * pArray
  ) override;
  HRESULT __stdcall GetGammaControl(
    DXGI_GAMMA_CONTROL * pArray
  ) override;
  HRESULT __stdcall SetDisplaySurface(
    IDXGISurface * pScanoutSurface
  ) override;
  HRESULT __stdcall GetDisplaySurfaceData(
    IDXGISurface * pDestination
  ) override;
  HRESULT __stdcall GetFrameStatistics(
    DXGI_FRAME_STATISTICS * pStats
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGISwapChain4
inherits:
  IDXGISwapChain3
  IDXGISwapChain2
  IDXGISwapChain1
  IDXGISwapChain
  IDXGIDeviceSubObject
  IDXGIObject
  IUnknown
methods:
  SetHDRMetaData
end class
#endif
class WrappedIDXGISwapChain4 : public IDXGISwapChain4 {
private:
  IDXGISwapChain4 *m_pIDXGISwapChain4;
  IDXGISwapChain3 *m_pIDXGISwapChain3;
  IDXGISwapChain2 *m_pIDXGISwapChain2;
  IDXGISwapChain1 *m_pIDXGISwapChain1;
  IDXGISwapChain *m_pIDXGISwapChain;
  IDXGIDeviceSubObject *m_pIDXGIDeviceSubObject;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGISwapChain4(T *pWrapped) {
    out() << "// [CREATE] IDXGISwapChain4(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIDeviceSubObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDeviceSubObject), (void **)&m_pIDXGIDeviceSubObject);
    if (!res) {
      m_pIDXGIDeviceSubObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDeviceSubObject;
    }
    m_pIDXGISwapChain = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISwapChain), (void **)&m_pIDXGISwapChain);
    if (!res) {
      m_pIDXGISwapChain->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISwapChain);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISwapChain)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISwapChain;
    }
    m_pIDXGISwapChain1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISwapChain1), (void **)&m_pIDXGISwapChain1);
    if (!res) {
      m_pIDXGISwapChain1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISwapChain1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISwapChain1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISwapChain1;
    }
    m_pIDXGISwapChain2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISwapChain2), (void **)&m_pIDXGISwapChain2);
    if (!res) {
      m_pIDXGISwapChain2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISwapChain2);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISwapChain2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISwapChain2;
    }
    m_pIDXGISwapChain3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISwapChain3), (void **)&m_pIDXGISwapChain3);
    if (!res) {
      m_pIDXGISwapChain3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISwapChain3);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISwapChain3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISwapChain3;
    }
    m_pIDXGISwapChain4 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGISwapChain4), (void **)&m_pIDXGISwapChain4);
    if (!res) {
      m_pIDXGISwapChain4->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGISwapChain4);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGISwapChain4)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGISwapChain4;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGISwapChain4() {
    out() << "// [DESTROY] IDXGISwapChain4(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDeviceSubObject));
    m_pIDXGIDeviceSubObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISwapChain));
    m_pIDXGISwapChain = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISwapChain1));
    m_pIDXGISwapChain1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISwapChain2));
    m_pIDXGISwapChain2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISwapChain3));
    m_pIDXGISwapChain3 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGISwapChain4));
    m_pIDXGISwapChain4 = nullptr;
  }
  HRESULT __stdcall SetHDRMetaData(
    DXGI_HDR_METADATA_TYPE Type, 
    UINT Size, 
    void * pMetaData
  ) override;
  UINT __stdcall GetCurrentBackBufferIndex() override;
  HRESULT __stdcall CheckColorSpaceSupport(
    DXGI_COLOR_SPACE_TYPE ColorSpace, 
    UINT * pColorSpaceSupport
  ) override;
  HRESULT __stdcall SetColorSpace1(
    DXGI_COLOR_SPACE_TYPE ColorSpace
  ) override;
  HRESULT __stdcall ResizeBuffers1(
    UINT BufferCount, 
    UINT Width, 
    UINT Height, 
    DXGI_FORMAT Format, 
    UINT SwapChainFlags, 
    const UINT * pCreationNodeMask, 
    struct IUnknown *const * ppPresentQueue
  ) override;
  HRESULT __stdcall SetSourceSize(
    UINT Width, 
    UINT Height
  ) override;
  HRESULT __stdcall GetSourceSize(
    UINT * pWidth, 
    UINT * pHeight
  ) override;
  HRESULT __stdcall SetMaximumFrameLatency(
    UINT MaxLatency
  ) override;
  HRESULT __stdcall GetMaximumFrameLatency(
    UINT * pMaxLatency
  ) override;
  HANDLE __stdcall GetFrameLatencyWaitableObject() override;
  HRESULT __stdcall SetMatrixTransform(
    const DXGI_MATRIX_3X2_F * pMatrix
  ) override;
  HRESULT __stdcall GetMatrixTransform(
    DXGI_MATRIX_3X2_F * pMatrix
  ) override;
  HRESULT __stdcall GetDesc1(
    DXGI_SWAP_CHAIN_DESC1 * pDesc
  ) override;
  HRESULT __stdcall GetFullscreenDesc(
    DXGI_SWAP_CHAIN_FULLSCREEN_DESC * pDesc
  ) override;
  HRESULT __stdcall GetHwnd(
    HWND * pHwnd
  ) override;
  HRESULT __stdcall GetCoreWindow(
    const IID & refiid, 
    void ** ppUnk
  ) override;
  HRESULT __stdcall Present1(
    UINT SyncInterval, 
    UINT PresentFlags, 
    const DXGI_PRESENT_PARAMETERS * pPresentParameters
  ) override;
  BOOL __stdcall IsTemporaryMonoSupported() override;
  HRESULT __stdcall GetRestrictToOutput(
    IDXGIOutput ** ppRestrictToOutput
  ) override;
  HRESULT __stdcall SetBackgroundColor(
    const DXGI_RGBA * pColor
  ) override;
  HRESULT __stdcall GetBackgroundColor(
    DXGI_RGBA * pColor
  ) override;
  HRESULT __stdcall SetRotation(
    DXGI_MODE_ROTATION Rotation
  ) override;
  HRESULT __stdcall GetRotation(
    DXGI_MODE_ROTATION * pRotation
  ) override;
  HRESULT __stdcall Present(
    UINT SyncInterval, 
    UINT Flags
  ) override;
  HRESULT __stdcall GetBuffer(
    UINT Buffer, 
    const IID & riid, 
    void ** ppSurface
  ) override;
  HRESULT __stdcall SetFullscreenState(
    BOOL Fullscreen, 
    IDXGIOutput * pTarget
  ) override;
  HRESULT __stdcall GetFullscreenState(
    BOOL * pFullscreen, 
    IDXGIOutput ** ppTarget
  ) override;
  HRESULT __stdcall GetDesc(
    DXGI_SWAP_CHAIN_DESC * pDesc
  ) override;
  HRESULT __stdcall ResizeBuffers(
    UINT BufferCount, 
    UINT Width, 
    UINT Height, 
    DXGI_FORMAT NewFormat, 
    UINT SwapChainFlags
  ) override;
  HRESULT __stdcall ResizeTarget(
    const DXGI_MODE_DESC * pNewTargetParameters
  ) override;
  HRESULT __stdcall GetContainingOutput(
    IDXGIOutput ** ppOutput
  ) override;
  HRESULT __stdcall GetFrameStatistics(
    DXGI_FRAME_STATISTICS * pStats
  ) override;
  HRESULT __stdcall GetLastPresentCount(
    UINT * pLastPresentCount
  ) override;
  HRESULT __stdcall GetDevice(
    const IID & riid, 
    void ** ppDevice
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIDevice4
inherits:
  IDXGIDevice3
  IDXGIDevice2
  IDXGIDevice1
  IDXGIDevice
  IDXGIObject
  IUnknown
methods:
  OfferResources1
  ReclaimResources1
end class
#endif
class WrappedIDXGIDevice4 : public IDXGIDevice4 {
private:
  IDXGIDevice4 *m_pIDXGIDevice4;
  IDXGIDevice3 *m_pIDXGIDevice3;
  IDXGIDevice2 *m_pIDXGIDevice2;
  IDXGIDevice1 *m_pIDXGIDevice1;
  IDXGIDevice *m_pIDXGIDevice;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIDevice4(T *pWrapped) {
    out() << "// [CREATE] IDXGIDevice4(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIDevice = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDevice), (void **)&m_pIDXGIDevice);
    if (!res) {
      m_pIDXGIDevice->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDevice);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDevice)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDevice;
    }
    m_pIDXGIDevice1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDevice1), (void **)&m_pIDXGIDevice1);
    if (!res) {
      m_pIDXGIDevice1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDevice1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDevice1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDevice1;
    }
    m_pIDXGIDevice2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDevice2), (void **)&m_pIDXGIDevice2);
    if (!res) {
      m_pIDXGIDevice2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDevice2);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDevice2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDevice2;
    }
    m_pIDXGIDevice3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDevice3), (void **)&m_pIDXGIDevice3);
    if (!res) {
      m_pIDXGIDevice3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDevice3);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDevice3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDevice3;
    }
    m_pIDXGIDevice4 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIDevice4), (void **)&m_pIDXGIDevice4);
    if (!res) {
      m_pIDXGIDevice4->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIDevice4);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIDevice4)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIDevice4;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIDevice4() {
    out() << "// [DESTROY] IDXGIDevice4(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDevice));
    m_pIDXGIDevice = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDevice1));
    m_pIDXGIDevice1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDevice2));
    m_pIDXGIDevice2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDevice3));
    m_pIDXGIDevice3 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIDevice4));
    m_pIDXGIDevice4 = nullptr;
  }
  HRESULT __stdcall OfferResources1(
    UINT NumResources, 
    IDXGIResource *const * ppResources, 
    DXGI_OFFER_RESOURCE_PRIORITY Priority, 
    UINT Flags
  ) override;
  HRESULT __stdcall ReclaimResources1(
    UINT NumResources, 
    IDXGIResource *const * ppResources, 
    DXGI_RECLAIM_RESOURCE_RESULTS * pResults
  ) override;
  void __stdcall Trim() override;
  HRESULT __stdcall OfferResources(
    UINT NumResources, 
    IDXGIResource *const * ppResources, 
    DXGI_OFFER_RESOURCE_PRIORITY Priority
  ) override;
  HRESULT __stdcall ReclaimResources(
    UINT NumResources, 
    IDXGIResource *const * ppResources, 
    BOOL * pDiscarded
  ) override;
  HRESULT __stdcall EnqueueSetEvent(
    HANDLE hEvent
  ) override;
  HRESULT __stdcall SetMaximumFrameLatency(
    UINT MaxLatency
  ) override;
  HRESULT __stdcall GetMaximumFrameLatency(
    UINT * pMaxLatency
  ) override;
  HRESULT __stdcall GetAdapter(
    IDXGIAdapter ** pAdapter
  ) override;
  HRESULT __stdcall CreateSurface(
    const DXGI_SURFACE_DESC * pDesc, 
    UINT NumSurfaces, 
    DXGI_USAGE Usage, 
    const DXGI_SHARED_RESOURCE * pSharedResource, 
    IDXGISurface ** ppSurface
  ) override;
  HRESULT __stdcall QueryResourceResidency(
    struct IUnknown *const * ppResources, 
    DXGI_RESIDENCY * pResidencyStatus, 
    UINT NumResources
  ) override;
  HRESULT __stdcall SetGPUThreadPriority(
    INT Priority
  ) override;
  HRESULT __stdcall GetGPUThreadPriority(
    INT * pPriority
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class IDXGIFactory5
inherits:
  IDXGIFactory4
  IDXGIFactory3
  IDXGIFactory2
  IDXGIFactory1
  IDXGIFactory
  IDXGIObject
  IUnknown
methods:
  CheckFeatureSupport
end class
#endif
class WrappedIDXGIFactory5 : public IDXGIFactory5 {
private:
  IDXGIFactory5 *m_pIDXGIFactory5;
  IDXGIFactory4 *m_pIDXGIFactory4;
  IDXGIFactory3 *m_pIDXGIFactory3;
  IDXGIFactory2 *m_pIDXGIFactory2;
  IDXGIFactory1 *m_pIDXGIFactory1;
  IDXGIFactory *m_pIDXGIFactory;
  IDXGIObject *m_pIDXGIObject;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedIDXGIFactory5(T *pWrapped) {
    out() << "// [CREATE] IDXGIFactory5(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pIDXGIObject = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIObject), (void **)&m_pIDXGIObject);
    if (!res) {
      m_pIDXGIObject->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIObject);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIObject)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIObject;
    }
    m_pIDXGIFactory = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactory), (void **)&m_pIDXGIFactory);
    if (!res) {
      m_pIDXGIFactory->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactory);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactory)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactory;
    }
    m_pIDXGIFactory1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactory1), (void **)&m_pIDXGIFactory1);
    if (!res) {
      m_pIDXGIFactory1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactory1);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactory1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactory1;
    }
    m_pIDXGIFactory2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactory2), (void **)&m_pIDXGIFactory2);
    if (!res) {
      m_pIDXGIFactory2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactory2);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactory2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactory2;
    }
    m_pIDXGIFactory3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactory3), (void **)&m_pIDXGIFactory3);
    if (!res) {
      m_pIDXGIFactory3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactory3);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactory3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactory3;
    }
    m_pIDXGIFactory4 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactory4), (void **)&m_pIDXGIFactory4);
    if (!res) {
      m_pIDXGIFactory4->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactory4);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactory4)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactory4;
    }
    m_pIDXGIFactory5 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IDXGIFactory5), (void **)&m_pIDXGIFactory5);
    if (!res) {
      m_pIDXGIFactory5->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIDXGIFactory5);
      wt[reinterpret_cast<size_t>((void*)m_pIDXGIFactory5)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIDXGIFactory5;
    }
      m_pMain->AddRef();
  }
  ~WrappedIDXGIFactory5() {
    out() << "// [DESTROY] IDXGIFactory5(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIObject));
    m_pIDXGIObject = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactory));
    m_pIDXGIFactory = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactory1));
    m_pIDXGIFactory1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactory2));
    m_pIDXGIFactory2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactory3));
    m_pIDXGIFactory3 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactory4));
    m_pIDXGIFactory4 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pIDXGIFactory5));
    m_pIDXGIFactory5 = nullptr;
  }
  HRESULT __stdcall CheckFeatureSupport(
    DXGI_FEATURE Feature, 
    void * pFeatureSupportData, 
    UINT FeatureSupportDataSize
  ) override;
  HRESULT __stdcall EnumAdapterByLuid(
    LUID AdapterLuid, 
    const IID & riid, 
    void ** ppvAdapter
  ) override;
  HRESULT __stdcall EnumWarpAdapter(
    const IID & riid, 
    void ** ppvAdapter
  ) override;
  UINT __stdcall GetCreationFlags() override;
  BOOL __stdcall IsWindowedStereoEnabled() override;
  HRESULT __stdcall CreateSwapChainForHwnd(
    struct IUnknown * pDevice, 
    HWND hWnd, 
    const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
    const DXGI_SWAP_CHAIN_FULLSCREEN_DESC * pFullscreenDesc, 
    IDXGIOutput * pRestrictToOutput, 
    IDXGISwapChain1 ** ppSwapChain
  ) override;
  HRESULT __stdcall CreateSwapChainForCoreWindow(
    struct IUnknown * pDevice, 
    struct IUnknown * pWindow, 
    const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
    IDXGIOutput * pRestrictToOutput, 
    IDXGISwapChain1 ** ppSwapChain
  ) override;
  HRESULT __stdcall GetSharedResourceAdapterLuid(
    HANDLE hResource, 
    LUID * pLuid
  ) override;
  HRESULT __stdcall RegisterStereoStatusWindow(
    HWND WindowHandle, 
    UINT wMsg, 
    DWORD * pdwCookie
  ) override;
  HRESULT __stdcall RegisterStereoStatusEvent(
    HANDLE hEvent, 
    DWORD * pdwCookie
  ) override;
  void __stdcall UnregisterStereoStatus(
    DWORD dwCookie
  ) override;
  HRESULT __stdcall RegisterOcclusionStatusWindow(
    HWND WindowHandle, 
    UINT wMsg, 
    DWORD * pdwCookie
  ) override;
  HRESULT __stdcall RegisterOcclusionStatusEvent(
    HANDLE hEvent, 
    DWORD * pdwCookie
  ) override;
  void __stdcall UnregisterOcclusionStatus(
    DWORD dwCookie
  ) override;
  HRESULT __stdcall CreateSwapChainForComposition(
    struct IUnknown * pDevice, 
    const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
    IDXGIOutput * pRestrictToOutput, 
    IDXGISwapChain1 ** ppSwapChain
  ) override;
  HRESULT __stdcall EnumAdapters1(
    UINT Adapter, 
    IDXGIAdapter1 ** ppAdapter
  ) override;
  BOOL __stdcall IsCurrent() override;
  HRESULT __stdcall EnumAdapters(
    UINT Adapter, 
    IDXGIAdapter ** ppAdapter
  ) override;
  HRESULT __stdcall MakeWindowAssociation(
    HWND WindowHandle, 
    UINT Flags
  ) override;
  HRESULT __stdcall GetWindowAssociation(
    HWND * pWindowHandle
  ) override;
  HRESULT __stdcall CreateSwapChain(
    struct IUnknown * pDevice, 
    DXGI_SWAP_CHAIN_DESC * pDesc, 
    IDXGISwapChain ** ppSwapChain
  ) override;
  HRESULT __stdcall CreateSoftwareAdapter(
    HMODULE Module, 
    IDXGIAdapter ** ppAdapter
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & Name, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & Name, 
    const struct IUnknown * pUnknown
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & Name, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetParent(
    const IID & riid, 
    void ** ppParent
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Device5
inherits:
  ID3D11Device4
  ID3D11Device3
  ID3D11Device2
  ID3D11Device1
  ID3D11Device
  IUnknown
methods:
  OpenSharedFence
  CreateFence
end class
#endif
class WrappedID3D11Device5 : public ID3D11Device5 {
private:
  ID3D11Device5 *m_pID3D11Device5;
  ID3D11Device4 *m_pID3D11Device4;
  ID3D11Device3 *m_pID3D11Device3;
  ID3D11Device2 *m_pID3D11Device2;
  ID3D11Device1 *m_pID3D11Device1;
  ID3D11Device *m_pID3D11Device;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Device5(T *pWrapped) {
    out() << "// [CREATE] ID3D11Device5(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11Device = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Device), (void **)&m_pID3D11Device);
    if (!res) {
      m_pID3D11Device->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Device);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Device)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Device;
    }
    m_pID3D11Device1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Device1), (void **)&m_pID3D11Device1);
    if (!res) {
      m_pID3D11Device1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Device1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Device1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Device1;
    }
    m_pID3D11Device2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Device2), (void **)&m_pID3D11Device2);
    if (!res) {
      m_pID3D11Device2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Device2);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Device2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Device2;
    }
    m_pID3D11Device3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Device3), (void **)&m_pID3D11Device3);
    if (!res) {
      m_pID3D11Device3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Device3);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Device3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Device3;
    }
    m_pID3D11Device4 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Device4), (void **)&m_pID3D11Device4);
    if (!res) {
      m_pID3D11Device4->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Device4);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Device4)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Device4;
    }
    m_pID3D11Device5 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Device5), (void **)&m_pID3D11Device5);
    if (!res) {
      m_pID3D11Device5->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Device5);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Device5)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Device5;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Device5() {
    out() << "// [DESTROY] ID3D11Device5(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Device));
    m_pID3D11Device = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Device1));
    m_pID3D11Device1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Device2));
    m_pID3D11Device2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Device3));
    m_pID3D11Device3 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Device4));
    m_pID3D11Device4 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Device5));
    m_pID3D11Device5 = nullptr;
  }
  HRESULT __stdcall OpenSharedFence(
    HANDLE hFence, 
    const IID & ReturnedInterface, 
    void ** ppFence
  ) override;
  HRESULT __stdcall CreateFence(
    UINT64 InitialValue, 
    D3D11_FENCE_FLAG Flags, 
    const IID & ReturnedInterface, 
    void ** ppFence
  ) override;
  HRESULT __stdcall RegisterDeviceRemovedEvent(
    HANDLE hEvent, 
    DWORD * pdwCookie
  ) override;
  void __stdcall UnregisterDeviceRemoved(
    DWORD dwCookie
  ) override;
  HRESULT __stdcall CreateTexture2D1(
    const D3D11_TEXTURE2D_DESC1 * pDesc1, 
    const D3D11_SUBRESOURCE_DATA * pInitialData, 
    ID3D11Texture2D1 ** ppTexture2D
  ) override;
  HRESULT __stdcall CreateTexture3D1(
    const D3D11_TEXTURE3D_DESC1 * pDesc1, 
    const D3D11_SUBRESOURCE_DATA * pInitialData, 
    ID3D11Texture3D1 ** ppTexture3D
  ) override;
  HRESULT __stdcall CreateRasterizerState2(
    const D3D11_RASTERIZER_DESC2 * pRasterizerDesc, 
    ID3D11RasterizerState2 ** ppRasterizerState
  ) override;
  HRESULT __stdcall CreateShaderResourceView1(
    ID3D11Resource * pResource, 
    const D3D11_SHADER_RESOURCE_VIEW_DESC1 * pDesc1, 
    ID3D11ShaderResourceView1 ** ppSRView1
  ) override;
  HRESULT __stdcall CreateUnorderedAccessView1(
    ID3D11Resource * pResource, 
    const D3D11_UNORDERED_ACCESS_VIEW_DESC1 * pDesc1, 
    ID3D11UnorderedAccessView1 ** ppUAView1
  ) override;
  HRESULT __stdcall CreateRenderTargetView1(
    ID3D11Resource * pResource, 
    const D3D11_RENDER_TARGET_VIEW_DESC1 * pDesc1, 
    ID3D11RenderTargetView1 ** ppRTView1
  ) override;
  HRESULT __stdcall CreateQuery1(
    const D3D11_QUERY_DESC1 * pQueryDesc1, 
    ID3D11Query1 ** ppQuery1
  ) override;
  void __stdcall GetImmediateContext3(
    ID3D11DeviceContext3 ** ppImmediateContext
  ) override;
  HRESULT __stdcall CreateDeferredContext3(
    UINT ContextFlags, 
    ID3D11DeviceContext3 ** ppDeferredContext
  ) override;
  void __stdcall WriteToSubresource(
    ID3D11Resource * pDstResource, 
    UINT DstSubresource, 
    const D3D11_BOX * pDstBox, 
    const void * pSrcData, 
    UINT SrcRowPitch, 
    UINT SrcDepthPitch
  ) override;
  void __stdcall ReadFromSubresource(
    void * pDstData, 
    UINT DstRowPitch, 
    UINT DstDepthPitch, 
    ID3D11Resource * pSrcResource, 
    UINT SrcSubresource, 
    const D3D11_BOX * pSrcBox
  ) override;
  void __stdcall GetImmediateContext2(
    ID3D11DeviceContext2 ** ppImmediateContext
  ) override;
  HRESULT __stdcall CreateDeferredContext2(
    UINT ContextFlags, 
    ID3D11DeviceContext2 ** ppDeferredContext
  ) override;
  void __stdcall GetResourceTiling(
    ID3D11Resource * pTiledResource, 
    UINT * pNumTilesForEntireResource, 
    D3D11_PACKED_MIP_DESC * pPackedMipDesc, 
    D3D11_TILE_SHAPE * pStandardTileShapeForNonPackedMips, 
    UINT * pNumSubresourceTilings, 
    UINT FirstSubresourceTilingToGet, 
    D3D11_SUBRESOURCE_TILING * pSubresourceTilingsForNonPackedMips
  ) override;
  HRESULT __stdcall CheckMultisampleQualityLevels1(
    DXGI_FORMAT Format, 
    UINT SampleCount, 
    UINT Flags, 
    UINT * pNumQualityLevels
  ) override;
  void __stdcall GetImmediateContext1(
    ID3D11DeviceContext1 ** ppImmediateContext
  ) override;
  HRESULT __stdcall CreateDeferredContext1(
    UINT ContextFlags, 
    ID3D11DeviceContext1 ** ppDeferredContext
  ) override;
  HRESULT __stdcall CreateBlendState1(
    const D3D11_BLEND_DESC1 * pBlendStateDesc, 
    ID3D11BlendState1 ** ppBlendState
  ) override;
  HRESULT __stdcall CreateRasterizerState1(
    const D3D11_RASTERIZER_DESC1 * pRasterizerDesc, 
    ID3D11RasterizerState1 ** ppRasterizerState
  ) override;
  HRESULT __stdcall CreateDeviceContextState(
    UINT Flags, 
    const D3D_FEATURE_LEVEL * pFeatureLevels, 
    UINT FeatureLevels, 
    UINT SDKVersion, 
    const IID & EmulatedInterface, 
    D3D_FEATURE_LEVEL * pChosenFeatureLevel, 
    ID3DDeviceContextState ** ppContextState
  ) override;
  HRESULT __stdcall OpenSharedResource1(
    HANDLE hResource, 
    const IID & returnedInterface, 
    void ** ppResource
  ) override;
  HRESULT __stdcall OpenSharedResourceByName(
    LPCWSTR lpName, 
    DWORD dwDesiredAccess, 
    const IID & returnedInterface, 
    void ** ppResource
  ) override;
  HRESULT __stdcall CreateBuffer(
    const D3D11_BUFFER_DESC * pDesc, 
    const D3D11_SUBRESOURCE_DATA * pInitialData, 
    ID3D11Buffer ** ppBuffer
  ) override;
  HRESULT __stdcall CreateTexture1D(
    const D3D11_TEXTURE1D_DESC * pDesc, 
    const D3D11_SUBRESOURCE_DATA * pInitialData, 
    ID3D11Texture1D ** ppTexture1D
  ) override;
  HRESULT __stdcall CreateTexture2D(
    const D3D11_TEXTURE2D_DESC * pDesc, 
    const D3D11_SUBRESOURCE_DATA * pInitialData, 
    ID3D11Texture2D ** ppTexture2D
  ) override;
  HRESULT __stdcall CreateTexture3D(
    const D3D11_TEXTURE3D_DESC * pDesc, 
    const D3D11_SUBRESOURCE_DATA * pInitialData, 
    ID3D11Texture3D ** ppTexture3D
  ) override;
  HRESULT __stdcall CreateShaderResourceView(
    ID3D11Resource * pResource, 
    const D3D11_SHADER_RESOURCE_VIEW_DESC * pDesc, 
    ID3D11ShaderResourceView ** ppSRView
  ) override;
  HRESULT __stdcall CreateUnorderedAccessView(
    ID3D11Resource * pResource, 
    const D3D11_UNORDERED_ACCESS_VIEW_DESC * pDesc, 
    ID3D11UnorderedAccessView ** ppUAView
  ) override;
  HRESULT __stdcall CreateRenderTargetView(
    ID3D11Resource * pResource, 
    const D3D11_RENDER_TARGET_VIEW_DESC * pDesc, 
    ID3D11RenderTargetView ** ppRTView
  ) override;
  HRESULT __stdcall CreateDepthStencilView(
    ID3D11Resource * pResource, 
    const D3D11_DEPTH_STENCIL_VIEW_DESC * pDesc, 
    ID3D11DepthStencilView ** ppDepthStencilView
  ) override;
  HRESULT __stdcall CreateInputLayout(
    const D3D11_INPUT_ELEMENT_DESC * pInputElementDescs, 
    UINT NumElements, 
    const void * pShaderBytecodeWithInputSignature, 
    SIZE_T BytecodeLength, 
    ID3D11InputLayout ** ppInputLayout
  ) override;
  HRESULT __stdcall CreateVertexShader(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11VertexShader ** ppVertexShader
  ) override;
  HRESULT __stdcall CreateGeometryShader(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11GeometryShader ** ppGeometryShader
  ) override;
  HRESULT __stdcall CreateGeometryShaderWithStreamOutput(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    const D3D11_SO_DECLARATION_ENTRY * pSODeclaration, 
    UINT NumEntries, 
    const UINT * pBufferStrides, 
    UINT NumStrides, 
    UINT RasterizedStream, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11GeometryShader ** ppGeometryShader
  ) override;
  HRESULT __stdcall CreatePixelShader(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11PixelShader ** ppPixelShader
  ) override;
  HRESULT __stdcall CreateHullShader(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11HullShader ** ppHullShader
  ) override;
  HRESULT __stdcall CreateDomainShader(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11DomainShader ** ppDomainShader
  ) override;
  HRESULT __stdcall CreateComputeShader(
    const void * pShaderBytecode, 
    SIZE_T BytecodeLength, 
    ID3D11ClassLinkage * pClassLinkage, 
    ID3D11ComputeShader ** ppComputeShader
  ) override;
  HRESULT __stdcall CreateClassLinkage(
    ID3D11ClassLinkage ** ppLinkage
  ) override;
  HRESULT __stdcall CreateBlendState(
    const D3D11_BLEND_DESC * pBlendStateDesc, 
    ID3D11BlendState ** ppBlendState
  ) override;
  HRESULT __stdcall CreateDepthStencilState(
    const D3D11_DEPTH_STENCIL_DESC * pDepthStencilDesc, 
    ID3D11DepthStencilState ** ppDepthStencilState
  ) override;
  HRESULT __stdcall CreateRasterizerState(
    const D3D11_RASTERIZER_DESC * pRasterizerDesc, 
    ID3D11RasterizerState ** ppRasterizerState
  ) override;
  HRESULT __stdcall CreateSamplerState(
    const D3D11_SAMPLER_DESC * pSamplerDesc, 
    ID3D11SamplerState ** ppSamplerState
  ) override;
  HRESULT __stdcall CreateQuery(
    const D3D11_QUERY_DESC * pQueryDesc, 
    ID3D11Query ** ppQuery
  ) override;
  HRESULT __stdcall CreatePredicate(
    const D3D11_QUERY_DESC * pPredicateDesc, 
    ID3D11Predicate ** ppPredicate
  ) override;
  HRESULT __stdcall CreateCounter(
    const D3D11_COUNTER_DESC * pCounterDesc, 
    ID3D11Counter ** ppCounter
  ) override;
  HRESULT __stdcall CreateDeferredContext(
    UINT ContextFlags, 
    ID3D11DeviceContext ** ppDeferredContext
  ) override;
  HRESULT __stdcall OpenSharedResource(
    HANDLE hResource, 
    const IID & ReturnedInterface, 
    void ** ppResource
  ) override;
  HRESULT __stdcall CheckFormatSupport(
    DXGI_FORMAT Format, 
    UINT * pFormatSupport
  ) override;
  HRESULT __stdcall CheckMultisampleQualityLevels(
    DXGI_FORMAT Format, 
    UINT SampleCount, 
    UINT * pNumQualityLevels
  ) override;
  void __stdcall CheckCounterInfo(
    D3D11_COUNTER_INFO * pCounterInfo
  ) override;
  HRESULT __stdcall CheckCounter(
    const D3D11_COUNTER_DESC * pDesc, 
    D3D11_COUNTER_TYPE * pType, 
    UINT * pActiveCounters, 
    LPSTR szName, 
    UINT * pNameLength, 
    LPSTR szUnits, 
    UINT * pUnitsLength, 
    LPSTR szDescription, 
    UINT * pDescriptionLength
  ) override;
  HRESULT __stdcall CheckFeatureSupport(
    D3D11_FEATURE Feature, 
    void * pFeatureSupportData, 
    UINT FeatureSupportDataSize
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  D3D_FEATURE_LEVEL __stdcall GetFeatureLevel() override;
  UINT __stdcall GetCreationFlags() override;
  HRESULT __stdcall GetDeviceRemovedReason() override;
  void __stdcall GetImmediateContext(
    ID3D11DeviceContext ** ppImmediateContext
  ) override;
  HRESULT __stdcall SetExceptionMode(
    UINT RaiseFlags
  ) override;
  UINT __stdcall GetExceptionMode() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11Multithread
inherits:
  IUnknown
methods:
  Enter
  Leave
  SetMultithreadProtected
  GetMultithreadProtected
end class
#endif
class WrappedID3D11Multithread : public ID3D11Multithread {
private:
  ID3D11Multithread *m_pID3D11Multithread;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Multithread(T *pWrapped) {
    out() << "// [CREATE] ID3D11Multithread(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11Multithread = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Multithread), (void **)&m_pID3D11Multithread);
    if (!res) {
      m_pID3D11Multithread->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Multithread);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Multithread)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Multithread;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Multithread() {
    out() << "// [DESTROY] ID3D11Multithread(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Multithread));
    m_pID3D11Multithread = nullptr;
  }
  void __stdcall Enter() override;
  void __stdcall Leave() override;
  BOOL __stdcall SetMultithreadProtected(
    BOOL bMTProtect
  ) override;
  BOOL __stdcall GetMultithreadProtected() override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoDevice2
inherits:
  ID3D11VideoDevice1
  ID3D11VideoDevice
  IUnknown
methods:
  CheckFeatureSupport
  NegotiateCryptoSessionKeyExchangeMT
end class
#endif
class WrappedID3D11VideoDevice2 : public ID3D11VideoDevice2 {
private:
  ID3D11VideoDevice2 *m_pID3D11VideoDevice2;
  ID3D11VideoDevice1 *m_pID3D11VideoDevice1;
  ID3D11VideoDevice *m_pID3D11VideoDevice;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoDevice2(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoDevice2(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11VideoDevice = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoDevice), (void **)&m_pID3D11VideoDevice);
    if (!res) {
      m_pID3D11VideoDevice->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoDevice;
    }
    m_pID3D11VideoDevice1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoDevice1), (void **)&m_pID3D11VideoDevice1);
    if (!res) {
      m_pID3D11VideoDevice1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoDevice1;
    }
    m_pID3D11VideoDevice2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoDevice2), (void **)&m_pID3D11VideoDevice2);
    if (!res) {
      m_pID3D11VideoDevice2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice2);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoDevice2;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoDevice2() {
    out() << "// [DESTROY] ID3D11VideoDevice2(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice));
    m_pID3D11VideoDevice = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice1));
    m_pID3D11VideoDevice1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoDevice2));
    m_pID3D11VideoDevice2 = nullptr;
  }
  HRESULT __stdcall CheckFeatureSupport(
    D3D11_FEATURE_VIDEO Feature, 
    void * pFeatureSupportData, 
    UINT FeatureSupportDataSize
  ) override;
  HRESULT __stdcall NegotiateCryptoSessionKeyExchangeMT(
    ID3D11CryptoSession * pCryptoSession, 
    D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS flags, 
    UINT DataSize, 
    void * pData
  ) override;
  HRESULT __stdcall GetCryptoSessionPrivateDataSize(
    const GUID * pCryptoType, 
    const GUID * pDecoderProfile, 
    const GUID * pKeyExchangeType, 
    UINT * pPrivateInputSize, 
    UINT * pPrivateOutputSize
  ) override;
  HRESULT __stdcall GetVideoDecoderCaps(
    const GUID * pDecoderProfile, 
    UINT SampleWidth, 
    UINT SampleHeight, 
    const DXGI_RATIONAL * pFrameRate, 
    UINT BitRate, 
    const GUID * pCryptoType, 
    UINT * pDecoderCaps
  ) override;
  HRESULT __stdcall CheckVideoDecoderDownsampling(
    const D3D11_VIDEO_DECODER_DESC * pInputDesc, 
    DXGI_COLOR_SPACE_TYPE InputColorSpace, 
    const D3D11_VIDEO_DECODER_CONFIG * pInputConfig, 
    const DXGI_RATIONAL * pFrameRate, 
    const D3D11_VIDEO_SAMPLE_DESC * pOutputDesc, 
    BOOL * pSupported, 
    BOOL * pRealTimeHint
  ) override;
  HRESULT __stdcall RecommendVideoDecoderDownsampleParameters(
    const D3D11_VIDEO_DECODER_DESC * pInputDesc, 
    DXGI_COLOR_SPACE_TYPE InputColorSpace, 
    const D3D11_VIDEO_DECODER_CONFIG * pInputConfig, 
    const DXGI_RATIONAL * pFrameRate, 
    D3D11_VIDEO_SAMPLE_DESC * pRecommendedOutputDesc
  ) override;
  HRESULT __stdcall CreateVideoDecoder(
    const D3D11_VIDEO_DECODER_DESC * pVideoDesc, 
    const D3D11_VIDEO_DECODER_CONFIG * pConfig, 
    ID3D11VideoDecoder ** ppDecoder
  ) override;
  HRESULT __stdcall CreateVideoProcessor(
    ID3D11VideoProcessorEnumerator * pEnum, 
    UINT RateConversionIndex, 
    ID3D11VideoProcessor ** ppVideoProcessor
  ) override;
  HRESULT __stdcall CreateAuthenticatedChannel(
    D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType, 
    ID3D11AuthenticatedChannel ** ppAuthenticatedChannel
  ) override;
  HRESULT __stdcall CreateCryptoSession(
    const GUID * pCryptoType, 
    const GUID * pDecoderProfile, 
    const GUID * pKeyExchangeType, 
    ID3D11CryptoSession ** ppCryptoSession
  ) override;
  HRESULT __stdcall CreateVideoDecoderOutputView(
    ID3D11Resource * pResource, 
    const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC * pDesc, 
    ID3D11VideoDecoderOutputView ** ppVDOVView
  ) override;
  HRESULT __stdcall CreateVideoProcessorInputView(
    ID3D11Resource * pResource, 
    ID3D11VideoProcessorEnumerator * pEnum, 
    const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC * pDesc, 
    ID3D11VideoProcessorInputView ** ppVPIView
  ) override;
  HRESULT __stdcall CreateVideoProcessorOutputView(
    ID3D11Resource * pResource, 
    ID3D11VideoProcessorEnumerator * pEnum, 
    const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC * pDesc, 
    ID3D11VideoProcessorOutputView ** ppVPOView
  ) override;
  HRESULT __stdcall CreateVideoProcessorEnumerator(
    const D3D11_VIDEO_PROCESSOR_CONTENT_DESC * pDesc, 
    ID3D11VideoProcessorEnumerator ** ppEnum
  ) override;
  UINT __stdcall GetVideoDecoderProfileCount() override;
  HRESULT __stdcall GetVideoDecoderProfile(
    UINT Index, 
    GUID * pDecoderProfile
  ) override;
  HRESULT __stdcall CheckVideoDecoderFormat(
    const GUID * pDecoderProfile, 
    DXGI_FORMAT Format, 
    BOOL * pSupported
  ) override;
  HRESULT __stdcall GetVideoDecoderConfigCount(
    const D3D11_VIDEO_DECODER_DESC * pDesc, 
    UINT * pCount
  ) override;
  HRESULT __stdcall GetVideoDecoderConfig(
    const D3D11_VIDEO_DECODER_DESC * pDesc, 
    UINT Index, 
    D3D11_VIDEO_DECODER_CONFIG * pConfig
  ) override;
  HRESULT __stdcall GetContentProtectionCaps(
    const GUID * pCryptoType, 
    const GUID * pDecoderProfile, 
    D3D11_VIDEO_CONTENT_PROTECTION_CAPS * pCaps
  ) override;
  HRESULT __stdcall CheckCryptoKeyExchange(
    const GUID * pCryptoType, 
    const GUID * pDecoderProfile, 
    UINT Index, 
    GUID * pKeyExchangeType
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11VideoContext3
inherits:
  ID3D11VideoContext2
  ID3D11VideoContext1
  ID3D11VideoContext
  ID3D11DeviceChild
  IUnknown
methods:
  DecoderBeginFrame1
  SubmitDecoderBuffers2
end class
#endif
class WrappedID3D11VideoContext3 : public ID3D11VideoContext3 {
private:
  ID3D11VideoContext3 *m_pID3D11VideoContext3;
  ID3D11VideoContext2 *m_pID3D11VideoContext2;
  ID3D11VideoContext1 *m_pID3D11VideoContext1;
  ID3D11VideoContext *m_pID3D11VideoContext;
  ID3D11DeviceChild *m_pID3D11DeviceChild;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11VideoContext3(T *pWrapped) {
    out() << "// [CREATE] ID3D11VideoContext3(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11DeviceChild = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11DeviceChild), (void **)&m_pID3D11DeviceChild);
    if (!res) {
      m_pID3D11DeviceChild->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11DeviceChild;
    }
    m_pID3D11VideoContext = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoContext), (void **)&m_pID3D11VideoContext);
    if (!res) {
      m_pID3D11VideoContext->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoContext);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoContext)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoContext;
    }
    m_pID3D11VideoContext1 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoContext1), (void **)&m_pID3D11VideoContext1);
    if (!res) {
      m_pID3D11VideoContext1->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoContext1);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoContext1)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoContext1;
    }
    m_pID3D11VideoContext2 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoContext2), (void **)&m_pID3D11VideoContext2);
    if (!res) {
      m_pID3D11VideoContext2->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoContext2);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoContext2)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoContext2;
    }
    m_pID3D11VideoContext3 = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11VideoContext3), (void **)&m_pID3D11VideoContext3);
    if (!res) {
      m_pID3D11VideoContext3->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11VideoContext3);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11VideoContext3)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11VideoContext3;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11VideoContext3() {
    out() << "// [DESTROY] ID3D11VideoContext3(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11DeviceChild));
    m_pID3D11DeviceChild = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoContext));
    m_pID3D11VideoContext = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoContext1));
    m_pID3D11VideoContext1 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoContext2));
    m_pID3D11VideoContext2 = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11VideoContext3));
    m_pID3D11VideoContext3 = nullptr;
  }
  HRESULT __stdcall DecoderBeginFrame1(
    ID3D11VideoDecoder * pDecoder, 
    ID3D11VideoDecoderOutputView * pView, 
    UINT ContentKeySize, 
    const void * pContentKey, 
    UINT NumComponentHistograms, 
    const UINT * pHistogramOffsets, 
    ID3D11Buffer *const * ppHistogramBuffers
  ) override;
  HRESULT __stdcall SubmitDecoderBuffers2(
    ID3D11VideoDecoder * pDecoder, 
    UINT NumBuffers, 
    const D3D11_VIDEO_DECODER_BUFFER_DESC2 * pBufferDesc
  ) override;
  void __stdcall VideoProcessorSetOutputHDRMetaData(
    ID3D11VideoProcessor * pVideoProcessor, 
    DXGI_HDR_METADATA_TYPE Type, 
    UINT Size, 
    const void * pHDRMetaData
  ) override;
  void __stdcall VideoProcessorGetOutputHDRMetaData(
    ID3D11VideoProcessor * pVideoProcessor, 
    DXGI_HDR_METADATA_TYPE * pType, 
    UINT Size, 
    void * pMetaData
  ) override;
  void __stdcall VideoProcessorSetStreamHDRMetaData(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    DXGI_HDR_METADATA_TYPE Type, 
    UINT Size, 
    const void * pHDRMetaData
  ) override;
  void __stdcall VideoProcessorGetStreamHDRMetaData(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    DXGI_HDR_METADATA_TYPE * pType, 
    UINT Size, 
    void * pMetaData
  ) override;
  HRESULT __stdcall SubmitDecoderBuffers1(
    ID3D11VideoDecoder * pDecoder, 
    UINT NumBuffers, 
    const D3D11_VIDEO_DECODER_BUFFER_DESC1 * pBufferDesc
  ) override;
  HRESULT __stdcall GetDataForNewHardwareKey(
    ID3D11CryptoSession * pCryptoSession, 
    UINT PrivateInputSize, 
    const void * pPrivatInputData, 
    UINT64 * pPrivateOutputData
  ) override;
  HRESULT __stdcall CheckCryptoSessionStatus(
    ID3D11CryptoSession * pCryptoSession, 
    D3D11_CRYPTO_SESSION_STATUS * pStatus
  ) override;
  HRESULT __stdcall DecoderEnableDownsampling(
    ID3D11VideoDecoder * pDecoder, 
    DXGI_COLOR_SPACE_TYPE InputColorSpace, 
    const D3D11_VIDEO_SAMPLE_DESC * pOutputDesc, 
    UINT ReferenceFrameCount
  ) override;
  HRESULT __stdcall DecoderUpdateDownsampling(
    ID3D11VideoDecoder * pDecoder, 
    const D3D11_VIDEO_SAMPLE_DESC * pOutputDesc
  ) override;
  void __stdcall VideoProcessorSetOutputColorSpace1(
    ID3D11VideoProcessor * pVideoProcessor, 
    DXGI_COLOR_SPACE_TYPE ColorSpace
  ) override;
  void __stdcall VideoProcessorSetOutputShaderUsage(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL ShaderUsage
  ) override;
  void __stdcall VideoProcessorGetOutputColorSpace1(
    ID3D11VideoProcessor * pVideoProcessor, 
    DXGI_COLOR_SPACE_TYPE * pColorSpace
  ) override;
  void __stdcall VideoProcessorGetOutputShaderUsage(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL * pShaderUsage
  ) override;
  void __stdcall VideoProcessorSetStreamColorSpace1(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    DXGI_COLOR_SPACE_TYPE ColorSpace
  ) override;
  void __stdcall VideoProcessorSetStreamMirror(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    BOOL FlipHorizontal, 
    BOOL FlipVertical
  ) override;
  void __stdcall VideoProcessorGetStreamColorSpace1(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    DXGI_COLOR_SPACE_TYPE * pColorSpace
  ) override;
  void __stdcall VideoProcessorGetStreamMirror(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnable, 
    BOOL * pFlipHorizontal, 
    BOOL * pFlipVertical
  ) override;
  HRESULT __stdcall VideoProcessorGetBehaviorHints(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT OutputWidth, 
    UINT OutputHeight, 
    DXGI_FORMAT OutputFormat, 
    UINT StreamCount, 
    const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT * pStreams, 
    UINT * pBehaviorHints
  ) override;
  HRESULT __stdcall GetDecoderBuffer(
    ID3D11VideoDecoder * pDecoder, 
    D3D11_VIDEO_DECODER_BUFFER_TYPE Type, 
    UINT * pBufferSize, 
    void ** ppBuffer
  ) override;
  HRESULT __stdcall ReleaseDecoderBuffer(
    ID3D11VideoDecoder * pDecoder, 
    D3D11_VIDEO_DECODER_BUFFER_TYPE Type
  ) override;
  HRESULT __stdcall DecoderBeginFrame(
    ID3D11VideoDecoder * pDecoder, 
    ID3D11VideoDecoderOutputView * pView, 
    UINT ContentKeySize, 
    const void * pContentKey
  ) override;
  HRESULT __stdcall DecoderEndFrame(
    ID3D11VideoDecoder * pDecoder
  ) override;
  HRESULT __stdcall SubmitDecoderBuffers(
    ID3D11VideoDecoder * pDecoder, 
    UINT NumBuffers, 
    const D3D11_VIDEO_DECODER_BUFFER_DESC * pBufferDesc
  ) override;
  APP_DEPRECATED_HRESULT __stdcall DecoderExtension(
    ID3D11VideoDecoder * pDecoder, 
    const D3D11_VIDEO_DECODER_EXTENSION * pExtensionData
  ) override;
  void __stdcall VideoProcessorSetOutputTargetRect(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL Enable, 
    const RECT * pRect
  ) override;
  void __stdcall VideoProcessorSetOutputBackgroundColor(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL YCbCr, 
    const D3D11_VIDEO_COLOR * pColor
  ) override;
  void __stdcall VideoProcessorSetOutputColorSpace(
    ID3D11VideoProcessor * pVideoProcessor, 
    const D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
  ) override;
  void __stdcall VideoProcessorSetOutputAlphaFillMode(
    ID3D11VideoProcessor * pVideoProcessor, 
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE AlphaFillMode, 
    UINT StreamIndex
  ) override;
  void __stdcall VideoProcessorSetOutputConstriction(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL Enable, 
    SIZE Size
  ) override;
  void __stdcall VideoProcessorSetOutputStereoMode(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL Enable
  ) override;
  APP_DEPRECATED_HRESULT __stdcall VideoProcessorSetOutputExtension(
    ID3D11VideoProcessor * pVideoProcessor, 
    const GUID * pExtensionGuid, 
    UINT DataSize, 
    void * pData
  ) override;
  void __stdcall VideoProcessorGetOutputTargetRect(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL * Enabled, 
    RECT * pRect
  ) override;
  void __stdcall VideoProcessorGetOutputBackgroundColor(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL * pYCbCr, 
    D3D11_VIDEO_COLOR * pColor
  ) override;
  void __stdcall VideoProcessorGetOutputColorSpace(
    ID3D11VideoProcessor * pVideoProcessor, 
    D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
  ) override;
  void __stdcall VideoProcessorGetOutputAlphaFillMode(
    ID3D11VideoProcessor * pVideoProcessor, 
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE * pAlphaFillMode, 
    UINT * pStreamIndex
  ) override;
  void __stdcall VideoProcessorGetOutputConstriction(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL * pEnabled, 
    SIZE * pSize
  ) override;
  void __stdcall VideoProcessorGetOutputStereoMode(
    ID3D11VideoProcessor * pVideoProcessor, 
    BOOL * pEnabled
  ) override;
  APP_DEPRECATED_HRESULT __stdcall VideoProcessorGetOutputExtension(
    ID3D11VideoProcessor * pVideoProcessor, 
    const GUID * pExtensionGuid, 
    UINT DataSize, 
    void * pData
  ) override;
  void __stdcall VideoProcessorSetStreamFrameFormat(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_FRAME_FORMAT FrameFormat
  ) override;
  void __stdcall VideoProcessorSetStreamColorSpace(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    const D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
  ) override;
  void __stdcall VideoProcessorSetStreamOutputRate(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE OutputRate, 
    BOOL RepeatFrame, 
    const DXGI_RATIONAL * pCustomRate
  ) override;
  void __stdcall VideoProcessorSetStreamSourceRect(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    const RECT * pRect
  ) override;
  void __stdcall VideoProcessorSetStreamDestRect(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    const RECT * pRect
  ) override;
  void __stdcall VideoProcessorSetStreamAlpha(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    FLOAT Alpha
  ) override;
  void __stdcall VideoProcessorSetStreamPalette(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    UINT Count, 
    const UINT * pEntries
  ) override;
  void __stdcall VideoProcessorSetStreamPixelAspectRatio(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    const DXGI_RATIONAL * pSourceAspectRatio, 
    const DXGI_RATIONAL * pDestinationAspectRatio
  ) override;
  void __stdcall VideoProcessorSetStreamLumaKey(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    FLOAT Lower, 
    FLOAT Upper
  ) override;
  void __stdcall VideoProcessorSetStreamStereoFormat(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT Format, 
    BOOL LeftViewFrame0, 
    BOOL BaseViewFrame0, 
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE FlipMode, 
    int MonoOffset
  ) override;
  void __stdcall VideoProcessorSetStreamAutoProcessingMode(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable
  ) override;
  void __stdcall VideoProcessorSetStreamFilter(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_PROCESSOR_FILTER Filter, 
    BOOL Enable, 
    int Level
  ) override;
  APP_DEPRECATED_HRESULT __stdcall VideoProcessorSetStreamExtension(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    const GUID * pExtensionGuid, 
    UINT DataSize, 
    void * pData
  ) override;
  void __stdcall VideoProcessorGetStreamFrameFormat(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_FRAME_FORMAT * pFrameFormat
  ) override;
  void __stdcall VideoProcessorGetStreamColorSpace(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
  ) override;
  void __stdcall VideoProcessorGetStreamOutputRate(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE * pOutputRate, 
    BOOL * pRepeatFrame, 
    DXGI_RATIONAL * pCustomRate
  ) override;
  void __stdcall VideoProcessorGetStreamSourceRect(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnabled, 
    RECT * pRect
  ) override;
  void __stdcall VideoProcessorGetStreamDestRect(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnabled, 
    RECT * pRect
  ) override;
  void __stdcall VideoProcessorGetStreamAlpha(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnabled, 
    FLOAT * pAlpha
  ) override;
  void __stdcall VideoProcessorGetStreamPalette(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    UINT Count, 
    UINT * pEntries
  ) override;
  void __stdcall VideoProcessorGetStreamPixelAspectRatio(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnabled, 
    DXGI_RATIONAL * pSourceAspectRatio, 
    DXGI_RATIONAL * pDestinationAspectRatio
  ) override;
  void __stdcall VideoProcessorGetStreamLumaKey(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnabled, 
    FLOAT * pLower, 
    FLOAT * pUpper
  ) override;
  void __stdcall VideoProcessorGetStreamStereoFormat(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnable, 
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT * pFormat, 
    BOOL * pLeftViewFrame0, 
    BOOL * pBaseViewFrame0, 
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE * pFlipMode, 
    int * MonoOffset
  ) override;
  void __stdcall VideoProcessorGetStreamAutoProcessingMode(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnabled
  ) override;
  void __stdcall VideoProcessorGetStreamFilter(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    D3D11_VIDEO_PROCESSOR_FILTER Filter, 
    BOOL * pEnabled, 
    int * pLevel
  ) override;
  APP_DEPRECATED_HRESULT __stdcall VideoProcessorGetStreamExtension(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    const GUID * pExtensionGuid, 
    UINT DataSize, 
    void * pData
  ) override;
  HRESULT __stdcall VideoProcessorBlt(
    ID3D11VideoProcessor * pVideoProcessor, 
    ID3D11VideoProcessorOutputView * pView, 
    UINT OutputFrame, 
    UINT StreamCount, 
    const D3D11_VIDEO_PROCESSOR_STREAM * pStreams
  ) override;
  HRESULT __stdcall NegotiateCryptoSessionKeyExchange(
    ID3D11CryptoSession * pCryptoSession, 
    UINT DataSize, 
    void * pData
  ) override;
  void __stdcall EncryptionBlt(
    ID3D11CryptoSession * pCryptoSession, 
    ID3D11Texture2D * pSrcSurface, 
    ID3D11Texture2D * pDstSurface, 
    UINT IVSize, 
    void * pIV
  ) override;
  void __stdcall DecryptionBlt(
    ID3D11CryptoSession * pCryptoSession, 
    ID3D11Texture2D * pSrcSurface, 
    ID3D11Texture2D * pDstSurface, 
    D3D11_ENCRYPTED_BLOCK_INFO * pEncryptedBlockInfo, 
    UINT ContentKeySize, 
    const void * pContentKey, 
    UINT IVSize, 
    void * pIV
  ) override;
  void __stdcall StartSessionKeyRefresh(
    ID3D11CryptoSession * pCryptoSession, 
    UINT RandomNumberSize, 
    void * pRandomNumber
  ) override;
  void __stdcall FinishSessionKeyRefresh(
    ID3D11CryptoSession * pCryptoSession
  ) override;
  HRESULT __stdcall GetEncryptionBltKey(
    ID3D11CryptoSession * pCryptoSession, 
    UINT KeySize, 
    void * pReadbackKey
  ) override;
  HRESULT __stdcall NegotiateAuthenticatedChannelKeyExchange(
    ID3D11AuthenticatedChannel * pChannel, 
    UINT DataSize, 
    void * pData
  ) override;
  HRESULT __stdcall QueryAuthenticatedChannel(
    ID3D11AuthenticatedChannel * pChannel, 
    UINT InputSize, 
    const void * pInput, 
    UINT OutputSize, 
    void * pOutput
  ) override;
  HRESULT __stdcall ConfigureAuthenticatedChannel(
    ID3D11AuthenticatedChannel * pChannel, 
    UINT InputSize, 
    const void * pInput, 
    D3D11_AUTHENTICATED_CONFIGURE_OUTPUT * pOutput
  ) override;
  void __stdcall VideoProcessorSetStreamRotation(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL Enable, 
    D3D11_VIDEO_PROCESSOR_ROTATION Rotation
  ) override;
  void __stdcall VideoProcessorGetStreamRotation(
    ID3D11VideoProcessor * pVideoProcessor, 
    UINT StreamIndex, 
    BOOL * pEnable, 
    D3D11_VIDEO_PROCESSOR_ROTATION * pRotation
  ) override;
  void __stdcall GetDevice(
    ID3D11Device ** ppDevice
  ) override;
  HRESULT __stdcall GetPrivateData(
    const GUID & guid, 
    UINT * pDataSize, 
    void * pData
  ) override;
  HRESULT __stdcall SetPrivateData(
    const GUID & guid, 
    UINT DataSize, 
    const void * pData
  ) override;
  HRESULT __stdcall SetPrivateDataInterface(
    const GUID & guid, 
    const struct IUnknown * pData
  ) override;
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11ShaderReflectionType
inherits:
methods:
  GetDesc
  GetMemberTypeByIndex
  GetMemberTypeByName
  GetMemberTypeName
  IsEqual
  GetSubType
  GetBaseClass
  GetNumInterfaces
  GetInterfaceByIndex
  IsOfType
  ImplementsInterface
end class
#endif
class WrappedID3D11ShaderReflectionType : public ID3D11ShaderReflectionType {
private:
  ID3D11ShaderReflectionType *m_pID3D11ShaderReflectionType;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D11ShaderReflectionType(T *pWrapped) {
    out() << "// [CREATE] ID3D11ShaderReflectionType(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D11ShaderReflectionType = nullptr;
    m_pID3D11ShaderReflectionType = (ID3D11ShaderReflectionType*)pWrapped;
  }
  ~WrappedID3D11ShaderReflectionType() {
    out() << "// [DESTROY] ID3D11ShaderReflectionType(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D11ShaderReflectionType = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D11_SHADER_TYPE_DESC * pDesc
  ) override;
  struct ID3D11ShaderReflectionType * __stdcall GetMemberTypeByIndex(
    UINT Index
  ) override;
  struct ID3D11ShaderReflectionType * __stdcall GetMemberTypeByName(
    LPCSTR Name
  ) override;
  LPCSTR __stdcall GetMemberTypeName(
    UINT Index
  ) override;
  HRESULT __stdcall IsEqual(
    struct ID3D11ShaderReflectionType * pType
  ) override;
  struct ID3D11ShaderReflectionType * __stdcall GetSubType() override;
  struct ID3D11ShaderReflectionType * __stdcall GetBaseClass() override;
  UINT __stdcall GetNumInterfaces() override;
  struct ID3D11ShaderReflectionType * __stdcall GetInterfaceByIndex(
    UINT uIndex
  ) override;
  HRESULT __stdcall IsOfType(
    struct ID3D11ShaderReflectionType * pType
  ) override;
  HRESULT __stdcall ImplementsInterface(
    struct ID3D11ShaderReflectionType * pBase
  ) override;
};
#if 0
begin class ID3D11ShaderReflectionVariable
inherits:
methods:
  GetDesc
  GetType
  GetBuffer
  GetInterfaceSlot
end class
#endif
class WrappedID3D11ShaderReflectionVariable : public ID3D11ShaderReflectionVariable {
private:
  ID3D11ShaderReflectionVariable *m_pID3D11ShaderReflectionVariable;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D11ShaderReflectionVariable(T *pWrapped) {
    out() << "// [CREATE] ID3D11ShaderReflectionVariable(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D11ShaderReflectionVariable = nullptr;
    m_pID3D11ShaderReflectionVariable = (ID3D11ShaderReflectionVariable*)pWrapped;
  }
  ~WrappedID3D11ShaderReflectionVariable() {
    out() << "// [DESTROY] ID3D11ShaderReflectionVariable(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D11ShaderReflectionVariable = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D11_SHADER_VARIABLE_DESC * pDesc
  ) override;
  ID3D11ShaderReflectionType * __stdcall GetType() override;
  ID3D11ShaderReflectionConstantBuffer * __stdcall GetBuffer() override;
  UINT __stdcall GetInterfaceSlot(
    UINT uArrayIndex
  ) override;
};
#if 0
begin class ID3D11ShaderReflectionConstantBuffer
inherits:
methods:
  GetDesc
  GetVariableByIndex
  GetVariableByName
end class
#endif
class WrappedID3D11ShaderReflectionConstantBuffer : public ID3D11ShaderReflectionConstantBuffer {
private:
  ID3D11ShaderReflectionConstantBuffer *m_pID3D11ShaderReflectionConstantBuffer;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D11ShaderReflectionConstantBuffer(T *pWrapped) {
    out() << "// [CREATE] ID3D11ShaderReflectionConstantBuffer(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D11ShaderReflectionConstantBuffer = nullptr;
    m_pID3D11ShaderReflectionConstantBuffer = (ID3D11ShaderReflectionConstantBuffer*)pWrapped;
  }
  ~WrappedID3D11ShaderReflectionConstantBuffer() {
    out() << "// [DESTROY] ID3D11ShaderReflectionConstantBuffer(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D11ShaderReflectionConstantBuffer = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D11_SHADER_BUFFER_DESC * pDesc
  ) override;
  ID3D11ShaderReflectionVariable * __stdcall GetVariableByIndex(
    UINT Index
  ) override;
  ID3D11ShaderReflectionVariable * __stdcall GetVariableByName(
    LPCSTR Name
  ) override;
};
#if 0
begin class ID3D11ShaderReflection
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  GetDesc
  GetConstantBufferByIndex
  GetConstantBufferByName
  GetResourceBindingDesc
  GetInputParameterDesc
  GetOutputParameterDesc
  GetPatchConstantParameterDesc
  GetVariableByName
  GetResourceBindingDescByName
  GetMovInstructionCount
  GetMovcInstructionCount
  GetConversionInstructionCount
  GetBitwiseInstructionCount
  GetGSInputPrimitive
  IsSampleFrequencyShader
  GetNumInterfaceSlots
  GetMinFeatureLevel
  GetThreadGroupSize
  GetRequiresFlags
end class
#endif
class WrappedID3D11ShaderReflection : public ID3D11ShaderReflection {
private:
  ID3D11ShaderReflection *m_pID3D11ShaderReflection;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11ShaderReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D11ShaderReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11ShaderReflection = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ShaderReflection), (void **)&m_pID3D11ShaderReflection);
    if (!res) {
      m_pID3D11ShaderReflection->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ShaderReflection);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ShaderReflection)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ShaderReflection;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11ShaderReflection() {
    out() << "// [DESTROY] ID3D11ShaderReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ShaderReflection));
    m_pID3D11ShaderReflection = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall GetDesc(
    D3D11_SHADER_DESC * pDesc
  ) override;
  ID3D11ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByIndex(
    UINT Index
  ) override;
  ID3D11ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDesc(
    UINT ResourceIndex, 
    D3D11_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  HRESULT __stdcall GetInputParameterDesc(
    UINT ParameterIndex, 
    D3D11_SIGNATURE_PARAMETER_DESC * pDesc
  ) override;
  HRESULT __stdcall GetOutputParameterDesc(
    UINT ParameterIndex, 
    D3D11_SIGNATURE_PARAMETER_DESC * pDesc
  ) override;
  HRESULT __stdcall GetPatchConstantParameterDesc(
    UINT ParameterIndex, 
    D3D11_SIGNATURE_PARAMETER_DESC * pDesc
  ) override;
  ID3D11ShaderReflectionVariable * __stdcall GetVariableByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDescByName(
    LPCSTR Name, 
    D3D11_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  UINT __stdcall GetMovInstructionCount() override;
  UINT __stdcall GetMovcInstructionCount() override;
  UINT __stdcall GetConversionInstructionCount() override;
  UINT __stdcall GetBitwiseInstructionCount() override;
  D3D_PRIMITIVE __stdcall GetGSInputPrimitive() override;
  BOOL __stdcall IsSampleFrequencyShader() override;
  UINT __stdcall GetNumInterfaceSlots() override;
  HRESULT __stdcall GetMinFeatureLevel(
    enum D3D_FEATURE_LEVEL * pLevel
  ) override;
  UINT __stdcall GetThreadGroupSize(
    UINT * pSizeX, 
    UINT * pSizeY, 
    UINT * pSizeZ
  ) override;
  UINT64 __stdcall GetRequiresFlags() override;
};
#if 0
begin class ID3D11LibraryReflection
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  GetDesc
  GetFunctionByIndex
end class
#endif
class WrappedID3D11LibraryReflection : public ID3D11LibraryReflection {
private:
  ID3D11LibraryReflection *m_pID3D11LibraryReflection;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11LibraryReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D11LibraryReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11LibraryReflection = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11LibraryReflection), (void **)&m_pID3D11LibraryReflection);
    if (!res) {
      m_pID3D11LibraryReflection->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11LibraryReflection);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11LibraryReflection)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11LibraryReflection;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11LibraryReflection() {
    out() << "// [DESTROY] ID3D11LibraryReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11LibraryReflection));
    m_pID3D11LibraryReflection = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall GetDesc(
    D3D11_LIBRARY_DESC * pDesc
  ) override;
  ID3D11FunctionReflection * __stdcall GetFunctionByIndex(
    INT FunctionIndex
  ) override;
};
#if 0
begin class ID3D11FunctionReflection
inherits:
methods:
  GetDesc
  GetConstantBufferByIndex
  GetConstantBufferByName
  GetResourceBindingDesc
  GetVariableByName
  GetResourceBindingDescByName
  GetFunctionParameter
end class
#endif
class WrappedID3D11FunctionReflection : public ID3D11FunctionReflection {
private:
  ID3D11FunctionReflection *m_pID3D11FunctionReflection;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D11FunctionReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D11FunctionReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D11FunctionReflection = nullptr;
    m_pID3D11FunctionReflection = (ID3D11FunctionReflection*)pWrapped;
  }
  ~WrappedID3D11FunctionReflection() {
    out() << "// [DESTROY] ID3D11FunctionReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D11FunctionReflection = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D11_FUNCTION_DESC * pDesc
  ) override;
  ID3D11ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByIndex(
    UINT BufferIndex
  ) override;
  ID3D11ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDesc(
    UINT ResourceIndex, 
    D3D11_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  ID3D11ShaderReflectionVariable * __stdcall GetVariableByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDescByName(
    LPCSTR Name, 
    D3D11_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  ID3D11FunctionParameterReflection * __stdcall GetFunctionParameter(
    INT ParameterIndex
  ) override;
};
#if 0
begin class ID3D11FunctionParameterReflection
inherits:
methods:
  GetDesc
end class
#endif
class WrappedID3D11FunctionParameterReflection : public ID3D11FunctionParameterReflection {
private:
  ID3D11FunctionParameterReflection *m_pID3D11FunctionParameterReflection;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D11FunctionParameterReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D11FunctionParameterReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D11FunctionParameterReflection = nullptr;
    m_pID3D11FunctionParameterReflection = (ID3D11FunctionParameterReflection*)pWrapped;
  }
  ~WrappedID3D11FunctionParameterReflection() {
    out() << "// [DESTROY] ID3D11FunctionParameterReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D11FunctionParameterReflection = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D11_PARAMETER_DESC * pDesc
  ) override;
};
#if 0
begin class ID3D11Module
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  CreateInstance
end class
#endif
class WrappedID3D11Module : public ID3D11Module {
private:
  ID3D11Module *m_pID3D11Module;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Module(T *pWrapped) {
    out() << "// [CREATE] ID3D11Module(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11Module = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Module), (void **)&m_pID3D11Module);
    if (!res) {
      m_pID3D11Module->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Module);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Module)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Module;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Module() {
    out() << "// [DESTROY] ID3D11Module(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Module));
    m_pID3D11Module = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall CreateInstance(
    LPCSTR pNamespace, 
    struct ID3D11ModuleInstance ** ppModuleInstance
  ) override;
};
#if 0
begin class ID3D11ModuleInstance
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  BindConstantBuffer
  BindConstantBufferByName
  BindResource
  BindResourceByName
  BindSampler
  BindSamplerByName
  BindUnorderedAccessView
  BindUnorderedAccessViewByName
  BindResourceAsUnorderedAccessView
  BindResourceAsUnorderedAccessViewByName
end class
#endif
class WrappedID3D11ModuleInstance : public ID3D11ModuleInstance {
private:
  ID3D11ModuleInstance *m_pID3D11ModuleInstance;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11ModuleInstance(T *pWrapped) {
    out() << "// [CREATE] ID3D11ModuleInstance(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11ModuleInstance = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11ModuleInstance), (void **)&m_pID3D11ModuleInstance);
    if (!res) {
      m_pID3D11ModuleInstance->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11ModuleInstance);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11ModuleInstance)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11ModuleInstance;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11ModuleInstance() {
    out() << "// [DESTROY] ID3D11ModuleInstance(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11ModuleInstance));
    m_pID3D11ModuleInstance = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall BindConstantBuffer(
    UINT uSrcSlot, 
    UINT uDstSlot, 
    UINT cbDstOffset
  ) override;
  HRESULT __stdcall BindConstantBufferByName(
    LPCSTR pName, 
    UINT uDstSlot, 
    UINT cbDstOffset
  ) override;
  HRESULT __stdcall BindResource(
    UINT uSrcSlot, 
    UINT uDstSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindResourceByName(
    LPCSTR pName, 
    UINT uDstSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindSampler(
    UINT uSrcSlot, 
    UINT uDstSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindSamplerByName(
    LPCSTR pName, 
    UINT uDstSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindUnorderedAccessView(
    UINT uSrcSlot, 
    UINT uDstSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindUnorderedAccessViewByName(
    LPCSTR pName, 
    UINT uDstSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindResourceAsUnorderedAccessView(
    UINT uSrcSrvSlot, 
    UINT uDstUavSlot, 
    UINT uCount
  ) override;
  HRESULT __stdcall BindResourceAsUnorderedAccessViewByName(
    LPCSTR pSrvName, 
    UINT uDstUavSlot, 
    UINT uCount
  ) override;
};
#if 0
begin class ID3D11Linker
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  Link
  UseLibrary
  AddClipPlaneFromCBuffer
end class
#endif
class WrappedID3D11Linker : public ID3D11Linker {
private:
  ID3D11Linker *m_pID3D11Linker;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11Linker(T *pWrapped) {
    out() << "// [CREATE] ID3D11Linker(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11Linker = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11Linker), (void **)&m_pID3D11Linker);
    if (!res) {
      m_pID3D11Linker->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11Linker);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11Linker)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11Linker;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11Linker() {
    out() << "// [DESTROY] ID3D11Linker(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11Linker));
    m_pID3D11Linker = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall Link(
    struct ID3D11ModuleInstance * pEntry, 
    LPCSTR pEntryName, 
    LPCSTR pTargetName, 
    UINT uFlags, 
    ID3DBlob ** ppShaderBlob, 
    ID3DBlob ** ppErrorBuffer
  ) override;
  HRESULT __stdcall UseLibrary(
    struct ID3D11ModuleInstance * pLibraryMI
  ) override;
  HRESULT __stdcall AddClipPlaneFromCBuffer(
    UINT uCBufferSlot, 
    UINT uCBufferEntry
  ) override;
};
#if 0
begin class ID3D11LinkingNode
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
end class
#endif
class WrappedID3D11LinkingNode : public ID3D11LinkingNode {
private:
  ID3D11LinkingNode *m_pID3D11LinkingNode;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11LinkingNode(T *pWrapped) {
    out() << "// [CREATE] ID3D11LinkingNode(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11LinkingNode = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11LinkingNode), (void **)&m_pID3D11LinkingNode);
    if (!res) {
      m_pID3D11LinkingNode->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11LinkingNode);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11LinkingNode)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11LinkingNode;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11LinkingNode() {
    out() << "// [DESTROY] ID3D11LinkingNode(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11LinkingNode));
    m_pID3D11LinkingNode = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
};
#if 0
begin class ID3D11FunctionLinkingGraph
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  CreateModuleInstance
  SetInputSignature
  SetOutputSignature
  CallFunction
  PassValue
  PassValueWithSwizzle
  GetLastError
  GenerateHlsl
end class
#endif
class WrappedID3D11FunctionLinkingGraph : public ID3D11FunctionLinkingGraph {
private:
  ID3D11FunctionLinkingGraph *m_pID3D11FunctionLinkingGraph;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D11FunctionLinkingGraph(T *pWrapped) {
    out() << "// [CREATE] ID3D11FunctionLinkingGraph(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D11FunctionLinkingGraph = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D11FunctionLinkingGraph), (void **)&m_pID3D11FunctionLinkingGraph);
    if (!res) {
      m_pID3D11FunctionLinkingGraph->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D11FunctionLinkingGraph);
      wt[reinterpret_cast<size_t>((void*)m_pID3D11FunctionLinkingGraph)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D11FunctionLinkingGraph;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D11FunctionLinkingGraph() {
    out() << "// [DESTROY] ID3D11FunctionLinkingGraph(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D11FunctionLinkingGraph));
    m_pID3D11FunctionLinkingGraph = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall CreateModuleInstance(
    struct ID3D11ModuleInstance ** ppModuleInstance, 
    ID3DBlob ** ppErrorBuffer
  ) override;
  HRESULT __stdcall SetInputSignature(
    const D3D11_PARAMETER_DESC * pInputParameters, 
    UINT cInputParameters, 
    struct ID3D11LinkingNode ** ppInputNode
  ) override;
  HRESULT __stdcall SetOutputSignature(
    const D3D11_PARAMETER_DESC * pOutputParameters, 
    UINT cOutputParameters, 
    struct ID3D11LinkingNode ** ppOutputNode
  ) override;
  HRESULT __stdcall CallFunction(
    LPCSTR pModuleInstanceNamespace, 
    struct ID3D11Module * pModuleWithFunctionPrototype, 
    LPCSTR pFunctionName, 
    struct ID3D11LinkingNode ** ppCallNode
  ) override;
  HRESULT __stdcall PassValue(
    struct ID3D11LinkingNode * pSrcNode, 
    INT SrcParameterIndex, 
    struct ID3D11LinkingNode * pDstNode, 
    INT DstParameterIndex
  ) override;
  HRESULT __stdcall PassValueWithSwizzle(
    struct ID3D11LinkingNode * pSrcNode, 
    INT SrcParameterIndex, 
    LPCSTR pSrcSwizzle, 
    struct ID3D11LinkingNode * pDstNode, 
    INT DstParameterIndex, 
    LPCSTR pDstSwizzle
  ) override;
  HRESULT __stdcall GetLastError(
    ID3DBlob ** ppErrorBuffer
  ) override;
  HRESULT __stdcall GenerateHlsl(
    UINT uFlags, 
    ID3DBlob ** ppBuffer
  ) override;
};
#if 0
begin class ID3D12ShaderReflectionType
inherits:
methods:
  GetDesc
  GetMemberTypeByIndex
  GetMemberTypeByName
  GetMemberTypeName
  IsEqual
  GetSubType
  GetBaseClass
  GetNumInterfaces
  GetInterfaceByIndex
  IsOfType
  ImplementsInterface
end class
#endif
class WrappedID3D12ShaderReflectionType : public ID3D12ShaderReflectionType {
private:
  ID3D12ShaderReflectionType *m_pID3D12ShaderReflectionType;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D12ShaderReflectionType(T *pWrapped) {
    out() << "// [CREATE] ID3D12ShaderReflectionType(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D12ShaderReflectionType = nullptr;
    m_pID3D12ShaderReflectionType = (ID3D12ShaderReflectionType*)pWrapped;
  }
  ~WrappedID3D12ShaderReflectionType() {
    out() << "// [DESTROY] ID3D12ShaderReflectionType(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D12ShaderReflectionType = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D12_SHADER_TYPE_DESC * pDesc
  ) override;
  struct ID3D12ShaderReflectionType * __stdcall GetMemberTypeByIndex(
    UINT Index
  ) override;
  struct ID3D12ShaderReflectionType * __stdcall GetMemberTypeByName(
    LPCSTR Name
  ) override;
  LPCSTR __stdcall GetMemberTypeName(
    UINT Index
  ) override;
  HRESULT __stdcall IsEqual(
    struct ID3D12ShaderReflectionType * pType
  ) override;
  struct ID3D12ShaderReflectionType * __stdcall GetSubType() override;
  struct ID3D12ShaderReflectionType * __stdcall GetBaseClass() override;
  UINT __stdcall GetNumInterfaces() override;
  struct ID3D12ShaderReflectionType * __stdcall GetInterfaceByIndex(
    UINT uIndex
  ) override;
  HRESULT __stdcall IsOfType(
    struct ID3D12ShaderReflectionType * pType
  ) override;
  HRESULT __stdcall ImplementsInterface(
    struct ID3D12ShaderReflectionType * pBase
  ) override;
};
#if 0
begin class ID3D12ShaderReflectionVariable
inherits:
methods:
  GetDesc
  GetType
  GetBuffer
  GetInterfaceSlot
end class
#endif
class WrappedID3D12ShaderReflectionVariable : public ID3D12ShaderReflectionVariable {
private:
  ID3D12ShaderReflectionVariable *m_pID3D12ShaderReflectionVariable;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D12ShaderReflectionVariable(T *pWrapped) {
    out() << "// [CREATE] ID3D12ShaderReflectionVariable(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D12ShaderReflectionVariable = nullptr;
    m_pID3D12ShaderReflectionVariable = (ID3D12ShaderReflectionVariable*)pWrapped;
  }
  ~WrappedID3D12ShaderReflectionVariable() {
    out() << "// [DESTROY] ID3D12ShaderReflectionVariable(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D12ShaderReflectionVariable = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D12_SHADER_VARIABLE_DESC * pDesc
  ) override;
  ID3D12ShaderReflectionType * __stdcall GetType() override;
  ID3D12ShaderReflectionConstantBuffer * __stdcall GetBuffer() override;
  UINT __stdcall GetInterfaceSlot(
    UINT uArrayIndex
  ) override;
};
#if 0
begin class ID3D12ShaderReflectionConstantBuffer
inherits:
methods:
  GetDesc
  GetVariableByIndex
  GetVariableByName
end class
#endif
class WrappedID3D12ShaderReflectionConstantBuffer : public ID3D12ShaderReflectionConstantBuffer {
private:
  ID3D12ShaderReflectionConstantBuffer *m_pID3D12ShaderReflectionConstantBuffer;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D12ShaderReflectionConstantBuffer(T *pWrapped) {
    out() << "// [CREATE] ID3D12ShaderReflectionConstantBuffer(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D12ShaderReflectionConstantBuffer = nullptr;
    m_pID3D12ShaderReflectionConstantBuffer = (ID3D12ShaderReflectionConstantBuffer*)pWrapped;
  }
  ~WrappedID3D12ShaderReflectionConstantBuffer() {
    out() << "// [DESTROY] ID3D12ShaderReflectionConstantBuffer(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D12ShaderReflectionConstantBuffer = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D12_SHADER_BUFFER_DESC * pDesc
  ) override;
  ID3D12ShaderReflectionVariable * __stdcall GetVariableByIndex(
    UINT Index
  ) override;
  ID3D12ShaderReflectionVariable * __stdcall GetVariableByName(
    LPCSTR Name
  ) override;
};
#if 0
begin class ID3D12ShaderReflection
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  GetDesc
  GetConstantBufferByIndex
  GetConstantBufferByName
  GetResourceBindingDesc
  GetInputParameterDesc
  GetOutputParameterDesc
  GetPatchConstantParameterDesc
  GetVariableByName
  GetResourceBindingDescByName
  GetMovInstructionCount
  GetMovcInstructionCount
  GetConversionInstructionCount
  GetBitwiseInstructionCount
  GetGSInputPrimitive
  IsSampleFrequencyShader
  GetNumInterfaceSlots
  GetMinFeatureLevel
  GetThreadGroupSize
  GetRequiresFlags
end class
#endif
class WrappedID3D12ShaderReflection : public ID3D12ShaderReflection {
private:
  ID3D12ShaderReflection *m_pID3D12ShaderReflection;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D12ShaderReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D12ShaderReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D12ShaderReflection = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D12ShaderReflection), (void **)&m_pID3D12ShaderReflection);
    if (!res) {
      m_pID3D12ShaderReflection->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D12ShaderReflection);
      wt[reinterpret_cast<size_t>((void*)m_pID3D12ShaderReflection)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D12ShaderReflection;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D12ShaderReflection() {
    out() << "// [DESTROY] ID3D12ShaderReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D12ShaderReflection));
    m_pID3D12ShaderReflection = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall GetDesc(
    D3D12_SHADER_DESC * pDesc
  ) override;
  ID3D12ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByIndex(
    UINT Index
  ) override;
  ID3D12ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDesc(
    UINT ResourceIndex, 
    D3D12_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  HRESULT __stdcall GetInputParameterDesc(
    UINT ParameterIndex, 
    D3D12_SIGNATURE_PARAMETER_DESC * pDesc
  ) override;
  HRESULT __stdcall GetOutputParameterDesc(
    UINT ParameterIndex, 
    D3D12_SIGNATURE_PARAMETER_DESC * pDesc
  ) override;
  HRESULT __stdcall GetPatchConstantParameterDesc(
    UINT ParameterIndex, 
    D3D12_SIGNATURE_PARAMETER_DESC * pDesc
  ) override;
  ID3D12ShaderReflectionVariable * __stdcall GetVariableByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDescByName(
    LPCSTR Name, 
    D3D12_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  UINT __stdcall GetMovInstructionCount() override;
  UINT __stdcall GetMovcInstructionCount() override;
  UINT __stdcall GetConversionInstructionCount() override;
  UINT __stdcall GetBitwiseInstructionCount() override;
  D3D_PRIMITIVE __stdcall GetGSInputPrimitive() override;
  BOOL __stdcall IsSampleFrequencyShader() override;
  UINT __stdcall GetNumInterfaceSlots() override;
  HRESULT __stdcall GetMinFeatureLevel(
    enum D3D_FEATURE_LEVEL * pLevel
  ) override;
  UINT __stdcall GetThreadGroupSize(
    UINT * pSizeX, 
    UINT * pSizeY, 
    UINT * pSizeZ
  ) override;
  UINT64 __stdcall GetRequiresFlags() override;
};
#if 0
begin class ID3D12LibraryReflection
inherits:
  IUnknown
methods:
  QueryInterface
  AddRef
  Release
  GetDesc
  GetFunctionByIndex
end class
#endif
class WrappedID3D12LibraryReflection : public ID3D12LibraryReflection {
private:
  ID3D12LibraryReflection *m_pID3D12LibraryReflection;
  IUnknown *m_pIUnknown;
  IUnknown *m_pMain;
public:
  bool CheckLifetime() { if (!m_pMain->Release()) { delete this; return false; } else { m_pMain->AddRef(); return true; } }
  template<typename T>
  WrappedID3D12LibraryReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D12LibraryReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pIUnknown = nullptr;
    res = pWrapped->QueryInterface(__uuidof(IUnknown), (void **)&m_pIUnknown);
    if (!res) {
      m_pIUnknown->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pIUnknown);
      wt[reinterpret_cast<size_t>((void*)m_pIUnknown)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pIUnknown;
    }
    m_pID3D12LibraryReflection = nullptr;
    res = pWrapped->QueryInterface(__uuidof(ID3D12LibraryReflection), (void **)&m_pID3D12LibraryReflection);
    if (!res) {
      m_pID3D12LibraryReflection->Release();
      uwt[reinterpret_cast<size_t>((void*)this)] = reinterpret_cast<size_t>((void*)m_pID3D12LibraryReflection);
      wt[reinterpret_cast<size_t>((void*)m_pID3D12LibraryReflection)] = reinterpret_cast<size_t>((void*)this);
      m_pMain = (IUnknown *)m_pID3D12LibraryReflection;
    }
      m_pMain->AddRef();
  }
  ~WrappedID3D12LibraryReflection() {
    out() << "// [DESTROY] ID3D12LibraryReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    wt.erase(reinterpret_cast<size_t>((void*)m_pIUnknown));
    m_pIUnknown = nullptr;
    wt.erase(reinterpret_cast<size_t>((void*)m_pID3D12LibraryReflection));
    m_pID3D12LibraryReflection = nullptr;
  }
  HRESULT __stdcall QueryInterface(
    const IID & riid, 
    void ** ppvObject
  ) override;
  ULONG __stdcall AddRef() override;
  ULONG __stdcall Release() override;
  HRESULT __stdcall GetDesc(
    D3D12_LIBRARY_DESC * pDesc
  ) override;
  ID3D12FunctionReflection * __stdcall GetFunctionByIndex(
    INT FunctionIndex
  ) override;
};
#if 0
begin class ID3D12FunctionReflection
inherits:
methods:
  GetDesc
  GetConstantBufferByIndex
  GetConstantBufferByName
  GetResourceBindingDesc
  GetVariableByName
  GetResourceBindingDescByName
  GetFunctionParameter
end class
#endif
class WrappedID3D12FunctionReflection : public ID3D12FunctionReflection {
private:
  ID3D12FunctionReflection *m_pID3D12FunctionReflection;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D12FunctionReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D12FunctionReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D12FunctionReflection = nullptr;
    m_pID3D12FunctionReflection = (ID3D12FunctionReflection*)pWrapped;
  }
  ~WrappedID3D12FunctionReflection() {
    out() << "// [DESTROY] ID3D12FunctionReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D12FunctionReflection = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D12_FUNCTION_DESC * pDesc
  ) override;
  ID3D12ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByIndex(
    UINT BufferIndex
  ) override;
  ID3D12ShaderReflectionConstantBuffer * __stdcall GetConstantBufferByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDesc(
    UINT ResourceIndex, 
    D3D12_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  ID3D12ShaderReflectionVariable * __stdcall GetVariableByName(
    LPCSTR Name
  ) override;
  HRESULT __stdcall GetResourceBindingDescByName(
    LPCSTR Name, 
    D3D12_SHADER_INPUT_BIND_DESC * pDesc
  ) override;
  ID3D12FunctionParameterReflection * __stdcall GetFunctionParameter(
    INT ParameterIndex
  ) override;
};
#if 0
begin class ID3D12FunctionParameterReflection
inherits:
methods:
  GetDesc
end class
#endif
class WrappedID3D12FunctionParameterReflection : public ID3D12FunctionParameterReflection {
private:
  ID3D12FunctionParameterReflection *m_pID3D12FunctionParameterReflection;
public:
  bool CheckLifetime() { return true; }
  template<typename T>
  WrappedID3D12FunctionParameterReflection(T *pWrapped) {
    out() << "// [CREATE] ID3D12FunctionParameterReflection(0x" << this << ", 0x" << pWrapped << " )\n";
    assert(pWrapped);
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    HRESULT res = S_OK;
    m_pID3D12FunctionParameterReflection = nullptr;
    m_pID3D12FunctionParameterReflection = (ID3D12FunctionParameterReflection*)pWrapped;
  }
  ~WrappedID3D12FunctionParameterReflection() {
    out() << "// [DESTROY] ID3D12FunctionParameterReflection(0x" << this << " )\n";
    GLOBAL_LOCK;
    auto &uwt = getUnwrapTable();
    auto &wt = getWrapTable();
    uwt.erase(reinterpret_cast<size_t>((void*)this));
    m_pID3D12FunctionParameterReflection = nullptr;
  }
  HRESULT __stdcall GetDesc(
    D3D12_PARAMETER_DESC * pDesc
  ) override;
};
typedef WrappedID3D10Blob WrappedID3DBlob;
HRESULT __stdcall WrappedIDXGIKeyedMutex::AcquireSync(
  UINT64 Key, 
  DWORD dwMilliseconds
) {
  assert(m_pIDXGIKeyedMutex);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Key = Key;
  auto orig_dwMilliseconds = dwMilliseconds;
  auto ret = m_pIDXGIKeyedMutex->AcquireSync(
    Key, 
    dwMilliseconds
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIKeyedMutex", "AcquireSync", &ret, {
    {"Key", {(void*)&orig_Key, (void*)&Key}},
    {"dwMilliseconds", {(void*)&orig_dwMilliseconds, (void*)&dwMilliseconds}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::ReleaseSync(
  UINT64 Key
) {
  assert(m_pIDXGIKeyedMutex);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Key = Key;
  auto ret = m_pIDXGIKeyedMutex->ReleaseSync(
    Key
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIKeyedMutex", "ReleaseSync", &ret, {
    {"Key", {(void*)&orig_Key, (void*)&Key}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::GetDevice(
  const IID & riid, 
  void ** ppDevice
) {
  assert(m_pIDXGIDeviceSubObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppDevice = ppDevice;
  auto ret = m_pIDXGIDeviceSubObject->GetDevice(
    riid, 
    ppDevice
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "IDXGIDeviceSubObject", "GetDevice", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIKeyedMutex::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIKeyedMutex)) {
      *ppvObject = (IDXGIKeyedMutex*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDeviceSubObject)) {
      *ppvObject = (IDXGIDeviceSubObject*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIKeyedMutex::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIKeyedMutex::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
LPVOID __stdcall WrappedID3D10Blob::GetBufferPointer() {
  assert(m_pID3D10Blob);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D10Blob->GetBufferPointer();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D10Blob", "GetBufferPointer", &ret, {
  });
  return ret;
}
SIZE_T __stdcall WrappedID3D10Blob::GetBufferSize() {
  assert(m_pID3D10Blob);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D10Blob->GetBufferSize();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D10Blob", "GetBufferSize", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D10Blob::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D10Blob)) {
      *ppvObject = (ID3D10Blob*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D10Blob::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D10Blob::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3DDestructionNotifier::RegisterDestructionCallback(
  PFN_DESTRUCTION_CALLBACK callbackFn, 
  void * pData, 
  UINT * pCallbackID
) {
  assert(m_pID3DDestructionNotifier);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_callbackFn = callbackFn;
  auto orig_pData = pData;
  auto orig_pCallbackID = pCallbackID;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3DDestructionNotifier->RegisterDestructionCallback(
    callbackFn, 
    unwrapped_pData, 
    pCallbackID
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DDestructionNotifier", "RegisterDestructionCallback", &ret, {
    {"callbackFn", {(void*)&orig_callbackFn, (void*)&callbackFn}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
    {"pCallbackID", {(void*)&orig_pCallbackID, (void*)&pCallbackID}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3DDestructionNotifier::UnregisterDestructionCallback(
  UINT callbackID
) {
  assert(m_pID3DDestructionNotifier);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_callbackID = callbackID;
  auto ret = m_pID3DDestructionNotifier->UnregisterDestructionCallback(
    callbackID
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DDestructionNotifier", "UnregisterDestructionCallback", &ret, {
    {"callbackID", {(void*)&orig_callbackID, (void*)&callbackID}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3DDestructionNotifier::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3DDestructionNotifier)) {
      *ppvObject = (ID3DDestructionNotifier*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3DDestructionNotifier::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3DDestructionNotifier::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3DInclude::Open(
  D3D_INCLUDE_TYPE IncludeType, 
  LPCSTR pFileName, 
  LPCVOID pParentData, 
  LPCVOID * ppData, 
  UINT * pBytes
) {
  assert(m_pID3DInclude);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_IncludeType = IncludeType;
  auto orig_pFileName = pFileName;
  auto orig_pParentData = pParentData;
  auto orig_ppData = ppData;
  auto orig_pBytes = pBytes;
  auto unwrapped_ppData = unwrap(ppData);
  auto unwrapped_pBytes = unwrap(pBytes);
  auto ret = m_pID3DInclude->Open(
    IncludeType, 
    pFileName, 
    pParentData, 
    unwrapped_ppData, 
    unwrapped_pBytes
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DInclude", "Open", &ret, {
    {"IncludeType", {(void*)&orig_IncludeType, (void*)&IncludeType}},
    {"pFileName", {(void*)&orig_pFileName, (void*)&pFileName}},
    {"pParentData", {(void*)&orig_pParentData, (void*)&pParentData}},
    {"ppData", {(void*)&orig_ppData, (void*)&ppData}},
    {"pBytes", {(void*)&orig_pBytes, (void*)&pBytes}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3DInclude::Close(
  LPCVOID pData
) {
  assert(m_pID3DInclude);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pData = pData;
  auto ret = m_pID3DInclude->Close(
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DInclude", "Close", &ret, {
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
void __stdcall WrappedID3D11DepthStencilState::GetDesc(
  D3D11_DEPTH_STENCIL_DESC * pDesc
) {
  assert(m_pID3D11DepthStencilState);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11DepthStencilState->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DepthStencilState", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11DepthStencilState::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11DepthStencilState::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DepthStencilState::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DepthStencilState::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DepthStencilState::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11DepthStencilState)) {
      *ppvObject = (ID3D11DepthStencilState*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DepthStencilState::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DepthStencilState::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Buffer::GetDesc(
  D3D11_BUFFER_DESC * pDesc
) {
  assert(m_pID3D11Buffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Buffer->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Buffer", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11Buffer::GetType(
  D3D11_RESOURCE_DIMENSION * pResourceDimension
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResourceDimension = pResourceDimension;
  m_pID3D11Resource->GetType(
    pResourceDimension
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetType", nullptr, {
    {"pResourceDimension", {(void*)&orig_pResourceDimension, (void*)&pResourceDimension}},
  });
}
void __stdcall WrappedID3D11Buffer::SetEvictionPriority(
  UINT EvictionPriority
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EvictionPriority = EvictionPriority;
  m_pID3D11Resource->SetEvictionPriority(
    EvictionPriority
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "SetEvictionPriority", nullptr, {
    {"EvictionPriority", {(void*)&orig_EvictionPriority, (void*)&EvictionPriority}},
  });
}
UINT __stdcall WrappedID3D11Buffer::GetEvictionPriority() {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Resource->GetEvictionPriority();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetEvictionPriority", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Buffer::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Buffer::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Buffer::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Buffer::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Buffer::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Buffer)) {
      *ppvObject = (ID3D11Buffer*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Resource)) {
      *ppvObject = (ID3D11Resource*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Buffer::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Buffer::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Texture1D::GetDesc(
  D3D11_TEXTURE1D_DESC * pDesc
) {
  assert(m_pID3D11Texture1D);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Texture1D->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Texture1D", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11Texture1D::GetType(
  D3D11_RESOURCE_DIMENSION * pResourceDimension
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResourceDimension = pResourceDimension;
  m_pID3D11Resource->GetType(
    pResourceDimension
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetType", nullptr, {
    {"pResourceDimension", {(void*)&orig_pResourceDimension, (void*)&pResourceDimension}},
  });
}
void __stdcall WrappedID3D11Texture1D::SetEvictionPriority(
  UINT EvictionPriority
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EvictionPriority = EvictionPriority;
  m_pID3D11Resource->SetEvictionPriority(
    EvictionPriority
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "SetEvictionPriority", nullptr, {
    {"EvictionPriority", {(void*)&orig_EvictionPriority, (void*)&EvictionPriority}},
  });
}
UINT __stdcall WrappedID3D11Texture1D::GetEvictionPriority() {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Resource->GetEvictionPriority();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetEvictionPriority", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Texture1D::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Texture1D::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture1D::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture1D::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture1D::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Texture1D)) {
      *ppvObject = (ID3D11Texture1D*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Resource)) {
      *ppvObject = (ID3D11Resource*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Texture1D::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Texture1D::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11DepthStencilView::GetDesc(
  D3D11_DEPTH_STENCIL_VIEW_DESC * pDesc
) {
  assert(m_pID3D11DepthStencilView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11DepthStencilView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DepthStencilView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11DepthStencilView::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11DepthStencilView::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11DepthStencilView::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DepthStencilView::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DepthStencilView::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DepthStencilView::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11DepthStencilView)) {
      *ppvObject = (ID3D11DepthStencilView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DepthStencilView::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DepthStencilView::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11VertexShader::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VertexShader::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VertexShader::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VertexShader::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VertexShader::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VertexShader)) {
      *ppvObject = (ID3D11VertexShader*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VertexShader::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VertexShader::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11HullShader::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11HullShader::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11HullShader::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11HullShader::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11HullShader::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11HullShader)) {
      *ppvObject = (ID3D11HullShader*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11HullShader::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11HullShader::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11DomainShader::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11DomainShader::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DomainShader::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DomainShader::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DomainShader::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11DomainShader)) {
      *ppvObject = (ID3D11DomainShader*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DomainShader::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DomainShader::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11GeometryShader::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11GeometryShader::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11GeometryShader::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11GeometryShader::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11GeometryShader::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11GeometryShader)) {
      *ppvObject = (ID3D11GeometryShader*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11GeometryShader::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11GeometryShader::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11PixelShader::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11PixelShader::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11PixelShader::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11PixelShader::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11PixelShader::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11PixelShader)) {
      *ppvObject = (ID3D11PixelShader*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11PixelShader::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11PixelShader::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11ComputeShader::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11ComputeShader::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ComputeShader::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ComputeShader::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ComputeShader::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11ComputeShader)) {
      *ppvObject = (ID3D11ComputeShader*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ComputeShader::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ComputeShader::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11InputLayout::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11InputLayout::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InputLayout::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InputLayout::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InputLayout::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11InputLayout)) {
      *ppvObject = (ID3D11InputLayout*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11InputLayout::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11InputLayout::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11SamplerState::GetDesc(
  D3D11_SAMPLER_DESC * pDesc
) {
  assert(m_pID3D11SamplerState);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11SamplerState->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11SamplerState", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11SamplerState::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11SamplerState::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11SamplerState::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11SamplerState::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11SamplerState::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11SamplerState)) {
      *ppvObject = (ID3D11SamplerState*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11SamplerState::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11SamplerState::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Predicate::GetDesc(
  D3D11_QUERY_DESC * pDesc
) {
  assert(m_pID3D11Query);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Query->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Query", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
UINT __stdcall WrappedID3D11Predicate::GetDataSize() {
  assert(m_pID3D11Asynchronous);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Asynchronous->GetDataSize();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Asynchronous", "GetDataSize", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Predicate::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Predicate::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Predicate::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Predicate::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Predicate::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Predicate)) {
      *ppvObject = (ID3D11Predicate*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Query)) {
      *ppvObject = (ID3D11Query*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Asynchronous)) {
      *ppvObject = (ID3D11Asynchronous*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Predicate::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Predicate::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Counter::GetDesc(
  D3D11_COUNTER_DESC * pDesc
) {
  assert(m_pID3D11Counter);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Counter->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Counter", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
UINT __stdcall WrappedID3D11Counter::GetDataSize() {
  assert(m_pID3D11Asynchronous);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Asynchronous->GetDataSize();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Asynchronous", "GetDataSize", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Counter::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Counter::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Counter::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Counter::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Counter::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Counter)) {
      *ppvObject = (ID3D11Counter*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Asynchronous)) {
      *ppvObject = (ID3D11Asynchronous*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Counter::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Counter::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11ClassInstance::GetClassLinkage(
  ID3D11ClassLinkage ** ppLinkage
) {
  assert(m_pID3D11ClassInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppLinkage = ppLinkage;
  m_pID3D11ClassInstance->GetClassLinkage(
    ppLinkage
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppLinkage && *ppLinkage ) *ppLinkage = getWrapper<ID3D11ClassLinkage, WrappedID3D11ClassLinkage>(*ppLinkage);
  dumpMethodEvent((void*)this, "ID3D11ClassInstance", "GetClassLinkage", nullptr, {
    {"ppLinkage", {(void*)&orig_ppLinkage, (void*)&ppLinkage}},
  });
}
void __stdcall WrappedID3D11ClassInstance::GetDesc(
  D3D11_CLASS_INSTANCE_DESC * pDesc
) {
  assert(m_pID3D11ClassInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11ClassInstance->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ClassInstance", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11ClassInstance::GetInstanceName(
  LPSTR pInstanceName, 
  SIZE_T * pBufferLength
) {
  assert(m_pID3D11ClassInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pInstanceName = pInstanceName;
  auto orig_pBufferLength = pBufferLength;
  auto unwrapped_pBufferLength = unwrap(pBufferLength);
  m_pID3D11ClassInstance->GetInstanceName(
    pInstanceName, 
    unwrapped_pBufferLength
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ClassInstance", "GetInstanceName", nullptr, {
    {"pInstanceName", {(void*)&orig_pInstanceName, (void*)&pInstanceName}},
    {"pBufferLength", {(void*)&orig_pBufferLength, (void*)&pBufferLength}},
  });
}
void __stdcall WrappedID3D11ClassInstance::GetTypeName(
  LPSTR pTypeName, 
  SIZE_T * pBufferLength
) {
  assert(m_pID3D11ClassInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTypeName = pTypeName;
  auto orig_pBufferLength = pBufferLength;
  auto unwrapped_pBufferLength = unwrap(pBufferLength);
  m_pID3D11ClassInstance->GetTypeName(
    pTypeName, 
    unwrapped_pBufferLength
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ClassInstance", "GetTypeName", nullptr, {
    {"pTypeName", {(void*)&orig_pTypeName, (void*)&pTypeName}},
    {"pBufferLength", {(void*)&orig_pBufferLength, (void*)&pBufferLength}},
  });
}
void __stdcall WrappedID3D11ClassInstance::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11ClassInstance::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassInstance::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassInstance::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassInstance::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11ClassInstance)) {
      *ppvObject = (ID3D11ClassInstance*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ClassInstance::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ClassInstance::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassLinkage::GetClassInstance(
  LPCSTR pClassInstanceName, 
  UINT InstanceIndex, 
  ID3D11ClassInstance ** ppInstance
) {
  assert(m_pID3D11ClassLinkage);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pClassInstanceName = pClassInstanceName;
  auto orig_InstanceIndex = InstanceIndex;
  auto orig_ppInstance = ppInstance;
  auto ret = m_pID3D11ClassLinkage->GetClassInstance(
    pClassInstanceName, 
    InstanceIndex, 
    ppInstance
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppInstance && *ppInstance ) *ppInstance = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(*ppInstance);
  dumpMethodEvent((void*)this, "ID3D11ClassLinkage", "GetClassInstance", &ret, {
    {"pClassInstanceName", {(void*)&orig_pClassInstanceName, (void*)&pClassInstanceName}},
    {"InstanceIndex", {(void*)&orig_InstanceIndex, (void*)&InstanceIndex}},
    {"ppInstance", {(void*)&orig_ppInstance, (void*)&ppInstance}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassLinkage::CreateClassInstance(
  LPCSTR pClassTypeName, 
  UINT ConstantBufferOffset, 
  UINT ConstantVectorOffset, 
  UINT TextureOffset, 
  UINT SamplerOffset, 
  ID3D11ClassInstance ** ppInstance
) {
  assert(m_pID3D11ClassLinkage);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pClassTypeName = pClassTypeName;
  auto orig_ConstantBufferOffset = ConstantBufferOffset;
  auto orig_ConstantVectorOffset = ConstantVectorOffset;
  auto orig_TextureOffset = TextureOffset;
  auto orig_SamplerOffset = SamplerOffset;
  auto orig_ppInstance = ppInstance;
  auto ret = m_pID3D11ClassLinkage->CreateClassInstance(
    pClassTypeName, 
    ConstantBufferOffset, 
    ConstantVectorOffset, 
    TextureOffset, 
    SamplerOffset, 
    ppInstance
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppInstance && *ppInstance ) *ppInstance = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(*ppInstance);
  dumpMethodEvent((void*)this, "ID3D11ClassLinkage", "CreateClassInstance", &ret, {
    {"pClassTypeName", {(void*)&orig_pClassTypeName, (void*)&pClassTypeName}},
    {"ConstantBufferOffset", {(void*)&orig_ConstantBufferOffset, (void*)&ConstantBufferOffset}},
    {"ConstantVectorOffset", {(void*)&orig_ConstantVectorOffset, (void*)&ConstantVectorOffset}},
    {"TextureOffset", {(void*)&orig_TextureOffset, (void*)&TextureOffset}},
    {"SamplerOffset", {(void*)&orig_SamplerOffset, (void*)&SamplerOffset}},
    {"ppInstance", {(void*)&orig_ppInstance, (void*)&ppInstance}},
  });
  return ret;
}
void __stdcall WrappedID3D11ClassLinkage::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11ClassLinkage::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassLinkage::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassLinkage::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ClassLinkage::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11ClassLinkage)) {
      *ppvObject = (ID3D11ClassLinkage*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ClassLinkage::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ClassLinkage::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
UINT __stdcall WrappedID3D11CommandList::GetContextFlags() {
  assert(m_pID3D11CommandList);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11CommandList->GetContextFlags();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11CommandList", "GetContextFlags", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11CommandList::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11CommandList::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CommandList::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CommandList::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CommandList::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11CommandList)) {
      *ppvObject = (ID3D11CommandList*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11CommandList::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11CommandList::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoder::GetCreationParameters(
  D3D11_VIDEO_DECODER_DESC * pVideoDesc, 
  D3D11_VIDEO_DECODER_CONFIG * pConfig
) {
  assert(m_pID3D11VideoDecoder);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoDesc = pVideoDesc;
  auto orig_pConfig = pConfig;
  auto ret = m_pID3D11VideoDecoder->GetCreationParameters(
    pVideoDesc, 
    pConfig
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDecoder", "GetCreationParameters", &ret, {
    {"pVideoDesc", {(void*)&orig_pVideoDesc, (void*)&pVideoDesc}},
    {"pConfig", {(void*)&orig_pConfig, (void*)&pConfig}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoder::GetDriverHandle(
  HANDLE * pDriverHandle
) {
  assert(m_pID3D11VideoDecoder);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDriverHandle = pDriverHandle;
  auto ret = m_pID3D11VideoDecoder->GetDriverHandle(
    pDriverHandle
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDecoder", "GetDriverHandle", &ret, {
    {"pDriverHandle", {(void*)&orig_pDriverHandle, (void*)&pDriverHandle}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoDecoder::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoDecoder::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoder::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoder::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoder::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoDecoder)) {
      *ppvObject = (ID3D11VideoDecoder*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoDecoder::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoDecoder::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11VideoProcessor::GetContentDesc(
  D3D11_VIDEO_PROCESSOR_CONTENT_DESC * pDesc
) {
  assert(m_pID3D11VideoProcessor);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11VideoProcessor->GetContentDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessor", "GetContentDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11VideoProcessor::GetRateConversionCaps(
  D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS * pCaps
) {
  assert(m_pID3D11VideoProcessor);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCaps = pCaps;
  m_pID3D11VideoProcessor->GetRateConversionCaps(
    pCaps
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessor", "GetRateConversionCaps", nullptr, {
    {"pCaps", {(void*)&orig_pCaps, (void*)&pCaps}},
  });
}
void __stdcall WrappedID3D11VideoProcessor::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoProcessor::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessor::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessor::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessor::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoProcessor)) {
      *ppvObject = (ID3D11VideoProcessor*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessor::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessor::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11AuthenticatedChannel::GetCertificateSize(
  UINT * pCertificateSize
) {
  assert(m_pID3D11AuthenticatedChannel);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCertificateSize = pCertificateSize;
  auto ret = m_pID3D11AuthenticatedChannel->GetCertificateSize(
    pCertificateSize
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11AuthenticatedChannel", "GetCertificateSize", &ret, {
    {"pCertificateSize", {(void*)&orig_pCertificateSize, (void*)&pCertificateSize}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11AuthenticatedChannel::GetCertificate(
  UINT CertificateSize, 
  BYTE * pCertificate
) {
  assert(m_pID3D11AuthenticatedChannel);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_CertificateSize = CertificateSize;
  auto orig_pCertificate = pCertificate;
  auto ret = m_pID3D11AuthenticatedChannel->GetCertificate(
    CertificateSize, 
    pCertificate
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11AuthenticatedChannel", "GetCertificate", &ret, {
    {"CertificateSize", {(void*)&orig_CertificateSize, (void*)&CertificateSize}},
    {"pCertificate", {(void*)&orig_pCertificate, (void*)&pCertificate}},
  });
  return ret;
}
void __stdcall WrappedID3D11AuthenticatedChannel::GetChannelHandle(
  HANDLE * pChannelHandle
) {
  assert(m_pID3D11AuthenticatedChannel);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pChannelHandle = pChannelHandle;
  m_pID3D11AuthenticatedChannel->GetChannelHandle(
    pChannelHandle
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11AuthenticatedChannel", "GetChannelHandle", nullptr, {
    {"pChannelHandle", {(void*)&orig_pChannelHandle, (void*)&pChannelHandle}},
  });
}
void __stdcall WrappedID3D11AuthenticatedChannel::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11AuthenticatedChannel::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11AuthenticatedChannel::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11AuthenticatedChannel::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11AuthenticatedChannel::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11AuthenticatedChannel)) {
      *ppvObject = (ID3D11AuthenticatedChannel*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11AuthenticatedChannel::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11AuthenticatedChannel::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11CryptoSession::GetCryptoType(
  GUID * pCryptoType
) {
  assert(m_pID3D11CryptoSession);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoType = pCryptoType;
  m_pID3D11CryptoSession->GetCryptoType(
    pCryptoType
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11CryptoSession", "GetCryptoType", nullptr, {
    {"pCryptoType", {(void*)&orig_pCryptoType, (void*)&pCryptoType}},
  });
}
void __stdcall WrappedID3D11CryptoSession::GetDecoderProfile(
  GUID * pDecoderProfile
) {
  assert(m_pID3D11CryptoSession);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoderProfile = pDecoderProfile;
  m_pID3D11CryptoSession->GetDecoderProfile(
    pDecoderProfile
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11CryptoSession", "GetDecoderProfile", nullptr, {
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
  });
}
HRESULT __stdcall WrappedID3D11CryptoSession::GetCertificateSize(
  UINT * pCertificateSize
) {
  assert(m_pID3D11CryptoSession);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCertificateSize = pCertificateSize;
  auto ret = m_pID3D11CryptoSession->GetCertificateSize(
    pCertificateSize
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11CryptoSession", "GetCertificateSize", &ret, {
    {"pCertificateSize", {(void*)&orig_pCertificateSize, (void*)&pCertificateSize}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CryptoSession::GetCertificate(
  UINT CertificateSize, 
  BYTE * pCertificate
) {
  assert(m_pID3D11CryptoSession);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_CertificateSize = CertificateSize;
  auto orig_pCertificate = pCertificate;
  auto ret = m_pID3D11CryptoSession->GetCertificate(
    CertificateSize, 
    pCertificate
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11CryptoSession", "GetCertificate", &ret, {
    {"CertificateSize", {(void*)&orig_CertificateSize, (void*)&CertificateSize}},
    {"pCertificate", {(void*)&orig_pCertificate, (void*)&pCertificate}},
  });
  return ret;
}
void __stdcall WrappedID3D11CryptoSession::GetCryptoSessionHandle(
  HANDLE * pCryptoSessionHandle
) {
  assert(m_pID3D11CryptoSession);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSessionHandle = pCryptoSessionHandle;
  m_pID3D11CryptoSession->GetCryptoSessionHandle(
    pCryptoSessionHandle
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11CryptoSession", "GetCryptoSessionHandle", nullptr, {
    {"pCryptoSessionHandle", {(void*)&orig_pCryptoSessionHandle, (void*)&pCryptoSessionHandle}},
  });
}
void __stdcall WrappedID3D11CryptoSession::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11CryptoSession::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CryptoSession::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CryptoSession::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11CryptoSession::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11CryptoSession)) {
      *ppvObject = (ID3D11CryptoSession*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11CryptoSession::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11CryptoSession::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11VideoDecoderOutputView::GetDesc(
  D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC * pDesc
) {
  assert(m_pID3D11VideoDecoderOutputView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11VideoDecoderOutputView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDecoderOutputView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11VideoDecoderOutputView::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11VideoDecoderOutputView::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoDecoderOutputView::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoderOutputView::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoderOutputView::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDecoderOutputView::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoDecoderOutputView)) {
      *ppvObject = (ID3D11VideoDecoderOutputView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoDecoderOutputView::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoDecoderOutputView::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11VideoProcessorInputView::GetDesc(
  D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC * pDesc
) {
  assert(m_pID3D11VideoProcessorInputView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11VideoProcessorInputView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorInputView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11VideoProcessorInputView::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11VideoProcessorInputView::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoProcessorInputView::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorInputView::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorInputView::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorInputView::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoProcessorInputView)) {
      *ppvObject = (ID3D11VideoProcessorInputView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessorInputView::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessorInputView::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11VideoProcessorOutputView::GetDesc(
  D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC * pDesc
) {
  assert(m_pID3D11VideoProcessorOutputView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11VideoProcessorOutputView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorOutputView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11VideoProcessorOutputView::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11VideoProcessorOutputView::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoProcessorOutputView::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorOutputView::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorOutputView::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorOutputView::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoProcessorOutputView)) {
      *ppvObject = (ID3D11VideoProcessorOutputView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessorOutputView::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessorOutputView::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::SetFeatureMask(
  UINT Mask
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Mask = Mask;
  auto ret = m_pID3D11Debug->SetFeatureMask(
    Mask
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "SetFeatureMask", &ret, {
    {"Mask", {(void*)&orig_Mask, (void*)&Mask}},
  });
  return ret;
}
UINT __stdcall WrappedID3D11Debug::GetFeatureMask() {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Debug->GetFeatureMask();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "GetFeatureMask", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::SetPresentPerRenderOpDelay(
  UINT Milliseconds
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Milliseconds = Milliseconds;
  auto ret = m_pID3D11Debug->SetPresentPerRenderOpDelay(
    Milliseconds
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "SetPresentPerRenderOpDelay", &ret, {
    {"Milliseconds", {(void*)&orig_Milliseconds, (void*)&Milliseconds}},
  });
  return ret;
}
UINT __stdcall WrappedID3D11Debug::GetPresentPerRenderOpDelay() {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Debug->GetPresentPerRenderOpDelay();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "GetPresentPerRenderOpDelay", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::SetSwapChain(
  IDXGISwapChain * pSwapChain
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSwapChain = pSwapChain;
  auto unwrapped_pSwapChain = unwrap(pSwapChain);
  auto ret = m_pID3D11Debug->SetSwapChain(
    unwrapped_pSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "SetSwapChain", &ret, {
    {"pSwapChain", {(void*)&orig_pSwapChain, (void*)&pSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::GetSwapChain(
  IDXGISwapChain ** ppSwapChain
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppSwapChain = ppSwapChain;
  auto ret = m_pID3D11Debug->GetSwapChain(
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGISwapChain, WrappedIDXGISwapChain4>(*ppSwapChain);
  dumpMethodEvent((void*)this, "ID3D11Debug", "GetSwapChain", &ret, {
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::ValidateContext(
  ID3D11DeviceContext * pContext
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pContext = pContext;
  auto unwrapped_pContext = unwrap(pContext);
  auto ret = m_pID3D11Debug->ValidateContext(
    unwrapped_pContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "ValidateContext", &ret, {
    {"pContext", {(void*)&orig_pContext, (void*)&pContext}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::ReportLiveDeviceObjects(
  D3D11_RLDO_FLAGS Flags
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Flags = Flags;
  auto ret = m_pID3D11Debug->ReportLiveDeviceObjects(
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "ReportLiveDeviceObjects", &ret, {
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::ValidateContextForDispatch(
  ID3D11DeviceContext * pContext
) {
  assert(m_pID3D11Debug);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pContext = pContext;
  auto unwrapped_pContext = unwrap(pContext);
  auto ret = m_pID3D11Debug->ValidateContextForDispatch(
    unwrapped_pContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Debug", "ValidateContextForDispatch", &ret, {
    {"pContext", {(void*)&orig_pContext, (void*)&pContext}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Debug::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Debug)) {
      *ppvObject = (ID3D11Debug*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Debug::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Debug::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
BOOL __stdcall WrappedID3D11SwitchToRef::SetUseRef(
  BOOL UseRef
) {
  assert(m_pID3D11SwitchToRef);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_UseRef = UseRef;
  auto ret = m_pID3D11SwitchToRef->SetUseRef(
    UseRef
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11SwitchToRef", "SetUseRef", &ret, {
    {"UseRef", {(void*)&orig_UseRef, (void*)&UseRef}},
  });
  return ret;
}
BOOL __stdcall WrappedID3D11SwitchToRef::GetUseRef() {
  assert(m_pID3D11SwitchToRef);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11SwitchToRef->GetUseRef();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11SwitchToRef", "GetUseRef", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11SwitchToRef::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11SwitchToRef)) {
      *ppvObject = (ID3D11SwitchToRef*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11SwitchToRef::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11SwitchToRef::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11TracingDevice::SetShaderTrackingOptionsByType(
  UINT ResourceTypeFlags, 
  UINT Options
) {
  assert(m_pID3D11TracingDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ResourceTypeFlags = ResourceTypeFlags;
  auto orig_Options = Options;
  auto ret = m_pID3D11TracingDevice->SetShaderTrackingOptionsByType(
    ResourceTypeFlags, 
    Options
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11TracingDevice", "SetShaderTrackingOptionsByType", &ret, {
    {"ResourceTypeFlags", {(void*)&orig_ResourceTypeFlags, (void*)&ResourceTypeFlags}},
    {"Options", {(void*)&orig_Options, (void*)&Options}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11TracingDevice::SetShaderTrackingOptions(
  struct IUnknown * pShader, 
  UINT Options
) {
  assert(m_pID3D11TracingDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShader = pShader;
  auto orig_Options = Options;
  auto unwrapped_pShader = unwrap(pShader);
  auto ret = m_pID3D11TracingDevice->SetShaderTrackingOptions(
    unwrapped_pShader, 
    Options
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11TracingDevice", "SetShaderTrackingOptions", &ret, {
    {"pShader", {(void*)&orig_pShader, (void*)&pShader}},
    {"Options", {(void*)&orig_Options, (void*)&Options}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11TracingDevice::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11TracingDevice)) {
      *ppvObject = (ID3D11TracingDevice*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11TracingDevice::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11TracingDevice::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11RefTrackingOptions::SetTrackingOptions(
  UINT uOptions
) {
  assert(m_pID3D11RefTrackingOptions);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uOptions = uOptions;
  auto ret = m_pID3D11RefTrackingOptions->SetTrackingOptions(
    uOptions
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RefTrackingOptions", "SetTrackingOptions", &ret, {
    {"uOptions", {(void*)&orig_uOptions, (void*)&uOptions}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RefTrackingOptions::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11RefTrackingOptions)) {
      *ppvObject = (ID3D11RefTrackingOptions*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RefTrackingOptions::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RefTrackingOptions::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11RefDefaultTrackingOptions::SetTrackingOptions(
  UINT ResourceTypeFlags, 
  UINT Options
) {
  assert(m_pID3D11RefDefaultTrackingOptions);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ResourceTypeFlags = ResourceTypeFlags;
  auto orig_Options = Options;
  auto ret = m_pID3D11RefDefaultTrackingOptions->SetTrackingOptions(
    ResourceTypeFlags, 
    Options
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RefDefaultTrackingOptions", "SetTrackingOptions", &ret, {
    {"ResourceTypeFlags", {(void*)&orig_ResourceTypeFlags, (void*)&ResourceTypeFlags}},
    {"Options", {(void*)&orig_Options, (void*)&Options}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RefDefaultTrackingOptions::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11RefDefaultTrackingOptions)) {
      *ppvObject = (ID3D11RefDefaultTrackingOptions*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RefDefaultTrackingOptions::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RefDefaultTrackingOptions::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::SetMessageCountLimit(
  UINT64 MessageCountLimit
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_MessageCountLimit = MessageCountLimit;
  auto ret = m_pID3D11InfoQueue->SetMessageCountLimit(
    MessageCountLimit
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "SetMessageCountLimit", &ret, {
    {"MessageCountLimit", {(void*)&orig_MessageCountLimit, (void*)&MessageCountLimit}},
  });
  return ret;
}
void __stdcall WrappedID3D11InfoQueue::ClearStoredMessages() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11InfoQueue->ClearStoredMessages();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "ClearStoredMessages", nullptr, {
  });
}
HRESULT __stdcall WrappedID3D11InfoQueue::GetMessageW(
  UINT64 MessageIndex, 
  D3D11_MESSAGE * pMessage, 
  SIZE_T * pMessageByteLength
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_MessageIndex = MessageIndex;
  auto orig_pMessage = pMessage;
  auto orig_pMessageByteLength = pMessageByteLength;
  auto unwrapped_pMessageByteLength = unwrap(pMessageByteLength);
  auto ret = m_pID3D11InfoQueue->GetMessageW(
    MessageIndex, 
    pMessage, 
    unwrapped_pMessageByteLength
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetMessageW", &ret, {
    {"MessageIndex", {(void*)&orig_MessageIndex, (void*)&MessageIndex}},
    {"pMessage", {(void*)&orig_pMessage, (void*)&pMessage}},
    {"pMessageByteLength", {(void*)&orig_pMessageByteLength, (void*)&pMessageByteLength}},
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11InfoQueue::GetNumMessagesAllowedByStorageFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetNumMessagesAllowedByStorageFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetNumMessagesAllowedByStorageFilter", &ret, {
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11InfoQueue::GetNumMessagesDeniedByStorageFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetNumMessagesDeniedByStorageFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetNumMessagesDeniedByStorageFilter", &ret, {
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11InfoQueue::GetNumStoredMessages() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetNumStoredMessages();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetNumStoredMessages", &ret, {
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11InfoQueue::GetNumStoredMessagesAllowedByRetrievalFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetNumStoredMessagesAllowedByRetrievalFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetNumStoredMessagesAllowedByRetrievalFilter", &ret, {
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11InfoQueue::GetNumMessagesDiscardedByMessageCountLimit() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetNumMessagesDiscardedByMessageCountLimit();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetNumMessagesDiscardedByMessageCountLimit", &ret, {
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11InfoQueue::GetMessageCountLimit() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetMessageCountLimit();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetMessageCountLimit", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::AddStorageFilterEntries(
  D3D11_INFO_QUEUE_FILTER * pFilter
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFilter = pFilter;
  auto unwrapped_pFilter = unwrap(pFilter);
  auto ret = m_pID3D11InfoQueue->AddStorageFilterEntries(
    unwrapped_pFilter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "AddStorageFilterEntries", &ret, {
    {"pFilter", {(void*)&orig_pFilter, (void*)&pFilter}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::GetStorageFilter(
  D3D11_INFO_QUEUE_FILTER * pFilter, 
  SIZE_T * pFilterByteLength
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFilter = pFilter;
  auto orig_pFilterByteLength = pFilterByteLength;
  auto unwrapped_pFilterByteLength = unwrap(pFilterByteLength);
  auto ret = m_pID3D11InfoQueue->GetStorageFilter(
    pFilter, 
    unwrapped_pFilterByteLength
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetStorageFilter", &ret, {
    {"pFilter", {(void*)&orig_pFilter, (void*)&pFilter}},
    {"pFilterByteLength", {(void*)&orig_pFilterByteLength, (void*)&pFilterByteLength}},
  });
  return ret;
}
void __stdcall WrappedID3D11InfoQueue::ClearStorageFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11InfoQueue->ClearStorageFilter();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "ClearStorageFilter", nullptr, {
  });
}
HRESULT __stdcall WrappedID3D11InfoQueue::PushEmptyStorageFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->PushEmptyStorageFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PushEmptyStorageFilter", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::PushCopyOfStorageFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->PushCopyOfStorageFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PushCopyOfStorageFilter", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::PushStorageFilter(
  D3D11_INFO_QUEUE_FILTER * pFilter
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFilter = pFilter;
  auto unwrapped_pFilter = unwrap(pFilter);
  auto ret = m_pID3D11InfoQueue->PushStorageFilter(
    unwrapped_pFilter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PushStorageFilter", &ret, {
    {"pFilter", {(void*)&orig_pFilter, (void*)&pFilter}},
  });
  return ret;
}
void __stdcall WrappedID3D11InfoQueue::PopStorageFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11InfoQueue->PopStorageFilter();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PopStorageFilter", nullptr, {
  });
}
UINT __stdcall WrappedID3D11InfoQueue::GetStorageFilterStackSize() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetStorageFilterStackSize();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetStorageFilterStackSize", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::AddRetrievalFilterEntries(
  D3D11_INFO_QUEUE_FILTER * pFilter
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFilter = pFilter;
  auto unwrapped_pFilter = unwrap(pFilter);
  auto ret = m_pID3D11InfoQueue->AddRetrievalFilterEntries(
    unwrapped_pFilter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "AddRetrievalFilterEntries", &ret, {
    {"pFilter", {(void*)&orig_pFilter, (void*)&pFilter}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::GetRetrievalFilter(
  D3D11_INFO_QUEUE_FILTER * pFilter, 
  SIZE_T * pFilterByteLength
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFilter = pFilter;
  auto orig_pFilterByteLength = pFilterByteLength;
  auto unwrapped_pFilterByteLength = unwrap(pFilterByteLength);
  auto ret = m_pID3D11InfoQueue->GetRetrievalFilter(
    pFilter, 
    unwrapped_pFilterByteLength
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetRetrievalFilter", &ret, {
    {"pFilter", {(void*)&orig_pFilter, (void*)&pFilter}},
    {"pFilterByteLength", {(void*)&orig_pFilterByteLength, (void*)&pFilterByteLength}},
  });
  return ret;
}
void __stdcall WrappedID3D11InfoQueue::ClearRetrievalFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11InfoQueue->ClearRetrievalFilter();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "ClearRetrievalFilter", nullptr, {
  });
}
HRESULT __stdcall WrappedID3D11InfoQueue::PushEmptyRetrievalFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->PushEmptyRetrievalFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PushEmptyRetrievalFilter", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::PushCopyOfRetrievalFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->PushCopyOfRetrievalFilter();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PushCopyOfRetrievalFilter", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::PushRetrievalFilter(
  D3D11_INFO_QUEUE_FILTER * pFilter
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFilter = pFilter;
  auto unwrapped_pFilter = unwrap(pFilter);
  auto ret = m_pID3D11InfoQueue->PushRetrievalFilter(
    unwrapped_pFilter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PushRetrievalFilter", &ret, {
    {"pFilter", {(void*)&orig_pFilter, (void*)&pFilter}},
  });
  return ret;
}
void __stdcall WrappedID3D11InfoQueue::PopRetrievalFilter() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11InfoQueue->PopRetrievalFilter();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "PopRetrievalFilter", nullptr, {
  });
}
UINT __stdcall WrappedID3D11InfoQueue::GetRetrievalFilterStackSize() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetRetrievalFilterStackSize();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetRetrievalFilterStackSize", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::AddMessage(
  D3D11_MESSAGE_CATEGORY Category, 
  D3D11_MESSAGE_SEVERITY Severity, 
  D3D11_MESSAGE_ID ID, 
  LPCSTR pDescription
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Category = Category;
  auto orig_Severity = Severity;
  auto orig_ID = ID;
  auto orig_pDescription = pDescription;
  auto ret = m_pID3D11InfoQueue->AddMessage(
    Category, 
    Severity, 
    ID, 
    pDescription
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "AddMessage", &ret, {
    {"Category", {(void*)&orig_Category, (void*)&Category}},
    {"Severity", {(void*)&orig_Severity, (void*)&Severity}},
    {"ID", {(void*)&orig_ID, (void*)&ID}},
    {"pDescription", {(void*)&orig_pDescription, (void*)&pDescription}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::AddApplicationMessage(
  D3D11_MESSAGE_SEVERITY Severity, 
  LPCSTR pDescription
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Severity = Severity;
  auto orig_pDescription = pDescription;
  auto ret = m_pID3D11InfoQueue->AddApplicationMessage(
    Severity, 
    pDescription
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "AddApplicationMessage", &ret, {
    {"Severity", {(void*)&orig_Severity, (void*)&Severity}},
    {"pDescription", {(void*)&orig_pDescription, (void*)&pDescription}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::SetBreakOnCategory(
  D3D11_MESSAGE_CATEGORY Category, 
  BOOL bEnable
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Category = Category;
  auto orig_bEnable = bEnable;
  auto ret = m_pID3D11InfoQueue->SetBreakOnCategory(
    Category, 
    bEnable
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "SetBreakOnCategory", &ret, {
    {"Category", {(void*)&orig_Category, (void*)&Category}},
    {"bEnable", {(void*)&orig_bEnable, (void*)&bEnable}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::SetBreakOnSeverity(
  D3D11_MESSAGE_SEVERITY Severity, 
  BOOL bEnable
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Severity = Severity;
  auto orig_bEnable = bEnable;
  auto ret = m_pID3D11InfoQueue->SetBreakOnSeverity(
    Severity, 
    bEnable
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "SetBreakOnSeverity", &ret, {
    {"Severity", {(void*)&orig_Severity, (void*)&Severity}},
    {"bEnable", {(void*)&orig_bEnable, (void*)&bEnable}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::SetBreakOnID(
  D3D11_MESSAGE_ID ID, 
  BOOL bEnable
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ID = ID;
  auto orig_bEnable = bEnable;
  auto ret = m_pID3D11InfoQueue->SetBreakOnID(
    ID, 
    bEnable
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "SetBreakOnID", &ret, {
    {"ID", {(void*)&orig_ID, (void*)&ID}},
    {"bEnable", {(void*)&orig_bEnable, (void*)&bEnable}},
  });
  return ret;
}
BOOL __stdcall WrappedID3D11InfoQueue::GetBreakOnCategory(
  D3D11_MESSAGE_CATEGORY Category
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Category = Category;
  auto ret = m_pID3D11InfoQueue->GetBreakOnCategory(
    Category
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetBreakOnCategory", &ret, {
    {"Category", {(void*)&orig_Category, (void*)&Category}},
  });
  return ret;
}
BOOL __stdcall WrappedID3D11InfoQueue::GetBreakOnSeverity(
  D3D11_MESSAGE_SEVERITY Severity
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Severity = Severity;
  auto ret = m_pID3D11InfoQueue->GetBreakOnSeverity(
    Severity
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetBreakOnSeverity", &ret, {
    {"Severity", {(void*)&orig_Severity, (void*)&Severity}},
  });
  return ret;
}
BOOL __stdcall WrappedID3D11InfoQueue::GetBreakOnID(
  D3D11_MESSAGE_ID ID
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ID = ID;
  auto ret = m_pID3D11InfoQueue->GetBreakOnID(
    ID
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetBreakOnID", &ret, {
    {"ID", {(void*)&orig_ID, (void*)&ID}},
  });
  return ret;
}
void __stdcall WrappedID3D11InfoQueue::SetMuteDebugOutput(
  BOOL bMute
) {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_bMute = bMute;
  m_pID3D11InfoQueue->SetMuteDebugOutput(
    bMute
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "SetMuteDebugOutput", nullptr, {
    {"bMute", {(void*)&orig_bMute, (void*)&bMute}},
  });
}
BOOL __stdcall WrappedID3D11InfoQueue::GetMuteDebugOutput() {
  assert(m_pID3D11InfoQueue);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11InfoQueue->GetMuteDebugOutput();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11InfoQueue", "GetMuteDebugOutput", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11InfoQueue::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11InfoQueue)) {
      *ppvObject = (ID3D11InfoQueue*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11InfoQueue::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11InfoQueue::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3DDeviceContextState::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3DDeviceContextState::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3DDeviceContextState::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3DDeviceContextState::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3DDeviceContextState::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3DDeviceContextState)) {
      *ppvObject = (ID3DDeviceContextState*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3DDeviceContextState::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3DDeviceContextState::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
BOOL __stdcall WrappedIDXGIDisplayControl::IsStereoEnabled() {
  assert(m_pIDXGIDisplayControl);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIDisplayControl->IsStereoEnabled();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDisplayControl", "IsStereoEnabled", &ret, {
  });
  return ret;
}
void __stdcall WrappedIDXGIDisplayControl::SetStereoEnabled(
  BOOL enabled
) {
  assert(m_pIDXGIDisplayControl);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_enabled = enabled;
  m_pIDXGIDisplayControl->SetStereoEnabled(
    enabled
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDisplayControl", "SetStereoEnabled", nullptr, {
    {"enabled", {(void*)&orig_enabled, (void*)&enabled}},
  });
}
HRESULT __stdcall WrappedIDXGIDisplayControl::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIDisplayControl)) {
      *ppvObject = (IDXGIDisplayControl*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIDisplayControl::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIDisplayControl::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedIDXGIOutputDuplication::GetDesc(
  DXGI_OUTDUPL_DESC * pDesc
) {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pIDXGIOutputDuplication->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::AcquireNextFrame(
  UINT TimeoutInMilliseconds, 
  DXGI_OUTDUPL_FRAME_INFO * pFrameInfo, 
  IDXGIResource ** ppDesktopResource
) {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_TimeoutInMilliseconds = TimeoutInMilliseconds;
  auto orig_pFrameInfo = pFrameInfo;
  auto orig_ppDesktopResource = ppDesktopResource;
  auto ret = m_pIDXGIOutputDuplication->AcquireNextFrame(
    TimeoutInMilliseconds, 
    pFrameInfo, 
    ppDesktopResource
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDesktopResource && *ppDesktopResource ) *ppDesktopResource = getWrapper<IDXGIResource, WrappedIDXGIResource1>(*ppDesktopResource);
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "AcquireNextFrame", &ret, {
    {"TimeoutInMilliseconds", {(void*)&orig_TimeoutInMilliseconds, (void*)&TimeoutInMilliseconds}},
    {"pFrameInfo", {(void*)&orig_pFrameInfo, (void*)&pFrameInfo}},
    {"ppDesktopResource", {(void*)&orig_ppDesktopResource, (void*)&ppDesktopResource}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::GetFrameDirtyRects(
  UINT DirtyRectsBufferSize, 
  RECT * pDirtyRectsBuffer, 
  UINT * pDirtyRectsBufferSizeRequired
) {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_DirtyRectsBufferSize = DirtyRectsBufferSize;
  auto orig_pDirtyRectsBuffer = pDirtyRectsBuffer;
  auto orig_pDirtyRectsBufferSizeRequired = pDirtyRectsBufferSizeRequired;
  auto unwrapped_pDirtyRectsBuffer = unwrap(pDirtyRectsBuffer);
  auto ret = m_pIDXGIOutputDuplication->GetFrameDirtyRects(
    DirtyRectsBufferSize, 
    unwrapped_pDirtyRectsBuffer, 
    pDirtyRectsBufferSizeRequired
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "GetFrameDirtyRects", &ret, {
    {"DirtyRectsBufferSize", {(void*)&orig_DirtyRectsBufferSize, (void*)&DirtyRectsBufferSize}},
    {"pDirtyRectsBuffer", {(void*)&orig_pDirtyRectsBuffer, (void*)&pDirtyRectsBuffer}},
    {"pDirtyRectsBufferSizeRequired", {(void*)&orig_pDirtyRectsBufferSizeRequired, (void*)&pDirtyRectsBufferSizeRequired}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::GetFrameMoveRects(
  UINT MoveRectsBufferSize, 
  DXGI_OUTDUPL_MOVE_RECT * pMoveRectBuffer, 
  UINT * pMoveRectsBufferSizeRequired
) {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_MoveRectsBufferSize = MoveRectsBufferSize;
  auto orig_pMoveRectBuffer = pMoveRectBuffer;
  auto orig_pMoveRectsBufferSizeRequired = pMoveRectsBufferSizeRequired;
  auto unwrapped_pMoveRectBuffer = unwrap(pMoveRectBuffer);
  auto ret = m_pIDXGIOutputDuplication->GetFrameMoveRects(
    MoveRectsBufferSize, 
    unwrapped_pMoveRectBuffer, 
    pMoveRectsBufferSizeRequired
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "GetFrameMoveRects", &ret, {
    {"MoveRectsBufferSize", {(void*)&orig_MoveRectsBufferSize, (void*)&MoveRectsBufferSize}},
    {"pMoveRectBuffer", {(void*)&orig_pMoveRectBuffer, (void*)&pMoveRectBuffer}},
    {"pMoveRectsBufferSizeRequired", {(void*)&orig_pMoveRectsBufferSizeRequired, (void*)&pMoveRectsBufferSizeRequired}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::GetFramePointerShape(
  UINT PointerShapeBufferSize, 
  void * pPointerShapeBuffer, 
  UINT * pPointerShapeBufferSizeRequired, 
  DXGI_OUTDUPL_POINTER_SHAPE_INFO * pPointerShapeInfo
) {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_PointerShapeBufferSize = PointerShapeBufferSize;
  auto orig_pPointerShapeBuffer = pPointerShapeBuffer;
  auto orig_pPointerShapeBufferSizeRequired = pPointerShapeBufferSizeRequired;
  auto orig_pPointerShapeInfo = pPointerShapeInfo;
  auto unwrapped_pPointerShapeBuffer = unwrap(pPointerShapeBuffer);
  auto ret = m_pIDXGIOutputDuplication->GetFramePointerShape(
    PointerShapeBufferSize, 
    unwrapped_pPointerShapeBuffer, 
    pPointerShapeBufferSizeRequired, 
    pPointerShapeInfo
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "GetFramePointerShape", &ret, {
    {"PointerShapeBufferSize", {(void*)&orig_PointerShapeBufferSize, (void*)&PointerShapeBufferSize}},
    {"pPointerShapeBuffer", {(void*)&orig_pPointerShapeBuffer, (void*)&pPointerShapeBuffer}},
    {"pPointerShapeBufferSizeRequired", {(void*)&orig_pPointerShapeBufferSizeRequired, (void*)&pPointerShapeBufferSizeRequired}},
    {"pPointerShapeInfo", {(void*)&orig_pPointerShapeInfo, (void*)&pPointerShapeInfo}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::MapDesktopSurface(
  DXGI_MAPPED_RECT * pLockedRect
) {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLockedRect = pLockedRect;
  auto ret = m_pIDXGIOutputDuplication->MapDesktopSurface(
    pLockedRect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "MapDesktopSurface", &ret, {
    {"pLockedRect", {(void*)&orig_pLockedRect, (void*)&pLockedRect}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::UnMapDesktopSurface() {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIOutputDuplication->UnMapDesktopSurface();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "UnMapDesktopSurface", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::ReleaseFrame() {
  assert(m_pIDXGIOutputDuplication);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIOutputDuplication->ReleaseFrame();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutputDuplication", "ReleaseFrame", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutputDuplication::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIOutputDuplication)) {
      *ppvObject = (IDXGIOutputDuplication*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIOutputDuplication::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIOutputDuplication::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::GetResource(
  const IID & riid, 
  void ** ppParentResource, 
  UINT * pSubresourceIndex
) {
  assert(m_pIDXGISurface2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParentResource = ppParentResource;
  auto orig_pSubresourceIndex = pSubresourceIndex;
  auto ret = m_pIDXGISurface2->GetResource(
    riid, 
    ppParentResource, 
    pSubresourceIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*pSubresourceIndex)
    HandleWrap(__uuidof(ID3D11Resource), (void**)pSubresourceIndex);
  dumpMethodEvent((void*)this, "IDXGISurface2", "GetResource", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParentResource", {(void*)&orig_ppParentResource, (void*)&ppParentResource}},
    {"pSubresourceIndex", {(void*)&orig_pSubresourceIndex, (void*)&pSubresourceIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::GetDC(
  BOOL Discard, 
  HDC * phdc
) {
  assert(m_pIDXGISurface1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Discard = Discard;
  auto orig_phdc = phdc;
  auto ret = m_pIDXGISurface1->GetDC(
    Discard, 
    phdc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISurface1", "GetDC", &ret, {
    {"Discard", {(void*)&orig_Discard, (void*)&Discard}},
    {"phdc", {(void*)&orig_phdc, (void*)&phdc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::ReleaseDC(
  RECT * pDirtyRect
) {
  assert(m_pIDXGISurface1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDirtyRect = pDirtyRect;
  auto unwrapped_pDirtyRect = unwrap(pDirtyRect);
  auto ret = m_pIDXGISurface1->ReleaseDC(
    unwrapped_pDirtyRect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISurface1", "ReleaseDC", &ret, {
    {"pDirtyRect", {(void*)&orig_pDirtyRect, (void*)&pDirtyRect}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::GetDesc(
  DXGI_SURFACE_DESC * pDesc
) {
  assert(m_pIDXGISurface);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGISurface->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISurface", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::Map(
  DXGI_MAPPED_RECT * pLockedRect, 
  UINT MapFlags
) {
  assert(m_pIDXGISurface);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLockedRect = pLockedRect;
  auto orig_MapFlags = MapFlags;
  auto ret = m_pIDXGISurface->Map(
    pLockedRect, 
    MapFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISurface", "Map", &ret, {
    {"pLockedRect", {(void*)&orig_pLockedRect, (void*)&pLockedRect}},
    {"MapFlags", {(void*)&orig_MapFlags, (void*)&MapFlags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::Unmap() {
  assert(m_pIDXGISurface);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGISurface->Unmap();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISurface", "Unmap", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::GetDevice(
  const IID & riid, 
  void ** ppDevice
) {
  assert(m_pIDXGIDeviceSubObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppDevice = ppDevice;
  auto ret = m_pIDXGIDeviceSubObject->GetDevice(
    riid, 
    ppDevice
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "IDXGIDeviceSubObject", "GetDevice", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISurface2::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGISurface2)) {
      *ppvObject = (IDXGISurface2*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGISurface1)) {
      *ppvObject = (IDXGISurface1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGISurface)) {
      *ppvObject = (IDXGISurface*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDeviceSubObject)) {
      *ppvObject = (IDXGIDeviceSubObject*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGISurface2::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGISurface2::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::CreateSubresourceSurface(
  UINT index, 
  IDXGISurface2 ** ppSurface
) {
  assert(m_pIDXGIResource1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_index = index;
  auto orig_ppSurface = ppSurface;
  auto ret = m_pIDXGIResource1->CreateSubresourceSurface(
    index, 
    ppSurface
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSurface && *ppSurface ) *ppSurface = getWrapper<IDXGISurface2, WrappedIDXGISurface2>(*ppSurface);
  dumpMethodEvent((void*)this, "IDXGIResource1", "CreateSubresourceSurface", &ret, {
    {"index", {(void*)&orig_index, (void*)&index}},
    {"ppSurface", {(void*)&orig_ppSurface, (void*)&ppSurface}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::CreateSharedHandle(
  const SECURITY_ATTRIBUTES * pAttributes, 
  DWORD dwAccess, 
  LPCWSTR lpName, 
  HANDLE * pHandle
) {
  assert(m_pIDXGIResource1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAttributes = pAttributes;
  auto orig_dwAccess = dwAccess;
  auto orig_lpName = lpName;
  auto orig_pHandle = pHandle;
  auto unwrapped_pAttributes = unwrap(pAttributes);
  auto ret = m_pIDXGIResource1->CreateSharedHandle(
    unwrapped_pAttributes, 
    dwAccess, 
    lpName, 
    pHandle
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIResource1", "CreateSharedHandle", &ret, {
    {"pAttributes", {(void*)&orig_pAttributes, (void*)&pAttributes}},
    {"dwAccess", {(void*)&orig_dwAccess, (void*)&dwAccess}},
    {"lpName", {(void*)&orig_lpName, (void*)&lpName}},
    {"pHandle", {(void*)&orig_pHandle, (void*)&pHandle}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::GetSharedHandle(
  HANDLE * pSharedHandle
) {
  assert(m_pIDXGIResource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSharedHandle = pSharedHandle;
  auto ret = m_pIDXGIResource->GetSharedHandle(
    pSharedHandle
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIResource", "GetSharedHandle", &ret, {
    {"pSharedHandle", {(void*)&orig_pSharedHandle, (void*)&pSharedHandle}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::GetUsage(
  DXGI_USAGE * pUsage
) {
  assert(m_pIDXGIResource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pUsage = pUsage;
  auto unwrapped_pUsage = unwrap(pUsage);
  auto ret = m_pIDXGIResource->GetUsage(
    unwrapped_pUsage
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIResource", "GetUsage", &ret, {
    {"pUsage", {(void*)&orig_pUsage, (void*)&pUsage}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::SetEvictionPriority(
  UINT EvictionPriority
) {
  assert(m_pIDXGIResource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EvictionPriority = EvictionPriority;
  auto ret = m_pIDXGIResource->SetEvictionPriority(
    EvictionPriority
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIResource", "SetEvictionPriority", &ret, {
    {"EvictionPriority", {(void*)&orig_EvictionPriority, (void*)&EvictionPriority}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::GetEvictionPriority(
  UINT * pEvictionPriority
) {
  assert(m_pIDXGIResource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pEvictionPriority = pEvictionPriority;
  auto ret = m_pIDXGIResource->GetEvictionPriority(
    pEvictionPriority
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIResource", "GetEvictionPriority", &ret, {
    {"pEvictionPriority", {(void*)&orig_pEvictionPriority, (void*)&pEvictionPriority}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::GetDevice(
  const IID & riid, 
  void ** ppDevice
) {
  assert(m_pIDXGIDeviceSubObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppDevice = ppDevice;
  auto ret = m_pIDXGIDeviceSubObject->GetDevice(
    riid, 
    ppDevice
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "IDXGIDeviceSubObject", "GetDevice", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIResource1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIResource1)) {
      *ppvObject = (IDXGIResource1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIResource)) {
      *ppvObject = (IDXGIResource*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDeviceSubObject)) {
      *ppvObject = (IDXGIDeviceSubObject*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIResource1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIResource1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11BlendState1::GetDesc1(
  D3D11_BLEND_DESC1 * pDesc
) {
  assert(m_pID3D11BlendState1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11BlendState1->GetDesc1(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11BlendState1", "GetDesc1", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11BlendState1::GetDesc(
  D3D11_BLEND_DESC * pDesc
) {
  assert(m_pID3D11BlendState);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11BlendState->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11BlendState", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11BlendState1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11BlendState1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11BlendState1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11BlendState1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11BlendState1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11BlendState1)) {
      *ppvObject = (ID3D11BlendState1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11BlendState)) {
      *ppvObject = (ID3D11BlendState*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11BlendState1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11BlendState1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::CheckVideoProcessorFormatConversion(
  DXGI_FORMAT InputFormat, 
  DXGI_COLOR_SPACE_TYPE InputColorSpace, 
  DXGI_FORMAT OutputFormat, 
  DXGI_COLOR_SPACE_TYPE OutputColorSpace, 
  BOOL * pSupported
) {
  assert(m_pID3D11VideoProcessorEnumerator1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_InputFormat = InputFormat;
  auto orig_InputColorSpace = InputColorSpace;
  auto orig_OutputFormat = OutputFormat;
  auto orig_OutputColorSpace = OutputColorSpace;
  auto orig_pSupported = pSupported;
  auto ret = m_pID3D11VideoProcessorEnumerator1->CheckVideoProcessorFormatConversion(
    InputFormat, 
    InputColorSpace, 
    OutputFormat, 
    OutputColorSpace, 
    pSupported
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator1", "CheckVideoProcessorFormatConversion", &ret, {
    {"InputFormat", {(void*)&orig_InputFormat, (void*)&InputFormat}},
    {"InputColorSpace", {(void*)&orig_InputColorSpace, (void*)&InputColorSpace}},
    {"OutputFormat", {(void*)&orig_OutputFormat, (void*)&OutputFormat}},
    {"OutputColorSpace", {(void*)&orig_OutputColorSpace, (void*)&OutputColorSpace}},
    {"pSupported", {(void*)&orig_pSupported, (void*)&pSupported}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::GetVideoProcessorContentDesc(
  D3D11_VIDEO_PROCESSOR_CONTENT_DESC * pContentDesc
) {
  assert(m_pID3D11VideoProcessorEnumerator);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pContentDesc = pContentDesc;
  auto ret = m_pID3D11VideoProcessorEnumerator->GetVideoProcessorContentDesc(
    pContentDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator", "GetVideoProcessorContentDesc", &ret, {
    {"pContentDesc", {(void*)&orig_pContentDesc, (void*)&pContentDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::CheckVideoProcessorFormat(
  DXGI_FORMAT Format, 
  UINT * pFlags
) {
  assert(m_pID3D11VideoProcessorEnumerator);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Format = Format;
  auto orig_pFlags = pFlags;
  auto ret = m_pID3D11VideoProcessorEnumerator->CheckVideoProcessorFormat(
    Format, 
    pFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator", "CheckVideoProcessorFormat", &ret, {
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"pFlags", {(void*)&orig_pFlags, (void*)&pFlags}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::GetVideoProcessorCaps(
  D3D11_VIDEO_PROCESSOR_CAPS * pCaps
) {
  assert(m_pID3D11VideoProcessorEnumerator);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCaps = pCaps;
  auto ret = m_pID3D11VideoProcessorEnumerator->GetVideoProcessorCaps(
    pCaps
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator", "GetVideoProcessorCaps", &ret, {
    {"pCaps", {(void*)&orig_pCaps, (void*)&pCaps}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::GetVideoProcessorRateConversionCaps(
  UINT TypeIndex, 
  D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS * pCaps
) {
  assert(m_pID3D11VideoProcessorEnumerator);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_TypeIndex = TypeIndex;
  auto orig_pCaps = pCaps;
  auto ret = m_pID3D11VideoProcessorEnumerator->GetVideoProcessorRateConversionCaps(
    TypeIndex, 
    pCaps
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator", "GetVideoProcessorRateConversionCaps", &ret, {
    {"TypeIndex", {(void*)&orig_TypeIndex, (void*)&TypeIndex}},
    {"pCaps", {(void*)&orig_pCaps, (void*)&pCaps}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::GetVideoProcessorCustomRate(
  UINT TypeIndex, 
  UINT CustomRateIndex, 
  D3D11_VIDEO_PROCESSOR_CUSTOM_RATE * pRate
) {
  assert(m_pID3D11VideoProcessorEnumerator);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_TypeIndex = TypeIndex;
  auto orig_CustomRateIndex = CustomRateIndex;
  auto orig_pRate = pRate;
  auto ret = m_pID3D11VideoProcessorEnumerator->GetVideoProcessorCustomRate(
    TypeIndex, 
    CustomRateIndex, 
    pRate
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator", "GetVideoProcessorCustomRate", &ret, {
    {"TypeIndex", {(void*)&orig_TypeIndex, (void*)&TypeIndex}},
    {"CustomRateIndex", {(void*)&orig_CustomRateIndex, (void*)&CustomRateIndex}},
    {"pRate", {(void*)&orig_pRate, (void*)&pRate}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::GetVideoProcessorFilterRange(
  D3D11_VIDEO_PROCESSOR_FILTER Filter, 
  D3D11_VIDEO_PROCESSOR_FILTER_RANGE * pRange
) {
  assert(m_pID3D11VideoProcessorEnumerator);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Filter = Filter;
  auto orig_pRange = pRange;
  auto ret = m_pID3D11VideoProcessorEnumerator->GetVideoProcessorFilterRange(
    Filter, 
    pRange
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoProcessorEnumerator", "GetVideoProcessorFilterRange", &ret, {
    {"Filter", {(void*)&orig_Filter, (void*)&Filter}},
    {"pRange", {(void*)&orig_pRange, (void*)&pRange}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoProcessorEnumerator1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoProcessorEnumerator1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoProcessorEnumerator1)) {
      *ppvObject = (ID3D11VideoProcessorEnumerator1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11VideoProcessorEnumerator)) {
      *ppvObject = (ID3D11VideoProcessorEnumerator*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessorEnumerator1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoProcessorEnumerator1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
INT __stdcall WrappedID3DUserDefinedAnnotation::BeginEvent(
  LPCWSTR Name
) {
  assert(m_pID3DUserDefinedAnnotation);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3DUserDefinedAnnotation->BeginEvent(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DUserDefinedAnnotation", "BeginEvent", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
INT __stdcall WrappedID3DUserDefinedAnnotation::EndEvent() {
  assert(m_pID3DUserDefinedAnnotation);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3DUserDefinedAnnotation->EndEvent();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DUserDefinedAnnotation", "EndEvent", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3DUserDefinedAnnotation::SetMarker(
  LPCWSTR Name
) {
  assert(m_pID3DUserDefinedAnnotation);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  m_pID3DUserDefinedAnnotation->SetMarker(
    Name
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DUserDefinedAnnotation", "SetMarker", nullptr, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
}
BOOL __stdcall WrappedID3DUserDefinedAnnotation::GetStatus() {
  assert(m_pID3DUserDefinedAnnotation);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3DUserDefinedAnnotation->GetStatus();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3DUserDefinedAnnotation", "GetStatus", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3DUserDefinedAnnotation::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3DUserDefinedAnnotation)) {
      *ppvObject = (ID3DUserDefinedAnnotation*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3DUserDefinedAnnotation::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3DUserDefinedAnnotation::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::PresentBuffer(
  UINT BufferToPresent, 
  UINT SyncInterval, 
  UINT Flags
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_BufferToPresent = BufferToPresent;
  auto orig_SyncInterval = SyncInterval;
  auto orig_Flags = Flags;
  auto ret = m_pIDXGIDecodeSwapChain->PresentBuffer(
    BufferToPresent, 
    SyncInterval, 
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "PresentBuffer", &ret, {
    {"BufferToPresent", {(void*)&orig_BufferToPresent, (void*)&BufferToPresent}},
    {"SyncInterval", {(void*)&orig_SyncInterval, (void*)&SyncInterval}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::SetSourceRect(
  const RECT * pRect
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRect = pRect;
  auto unwrapped_pRect = unwrap(pRect);
  auto ret = m_pIDXGIDecodeSwapChain->SetSourceRect(
    unwrapped_pRect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "SetSourceRect", &ret, {
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::SetTargetRect(
  const RECT * pRect
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRect = pRect;
  auto unwrapped_pRect = unwrap(pRect);
  auto ret = m_pIDXGIDecodeSwapChain->SetTargetRect(
    unwrapped_pRect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "SetTargetRect", &ret, {
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::SetDestSize(
  UINT Width, 
  UINT Height
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Width = Width;
  auto orig_Height = Height;
  auto ret = m_pIDXGIDecodeSwapChain->SetDestSize(
    Width, 
    Height
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "SetDestSize", &ret, {
    {"Width", {(void*)&orig_Width, (void*)&Width}},
    {"Height", {(void*)&orig_Height, (void*)&Height}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::GetSourceRect(
  RECT * pRect
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRect = pRect;
  auto ret = m_pIDXGIDecodeSwapChain->GetSourceRect(
    pRect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "GetSourceRect", &ret, {
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::GetTargetRect(
  RECT * pRect
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRect = pRect;
  auto ret = m_pIDXGIDecodeSwapChain->GetTargetRect(
    pRect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "GetTargetRect", &ret, {
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::GetDestSize(
  UINT * pWidth, 
  UINT * pHeight
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pWidth = pWidth;
  auto orig_pHeight = pHeight;
  auto ret = m_pIDXGIDecodeSwapChain->GetDestSize(
    pWidth, 
    pHeight
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "GetDestSize", &ret, {
    {"pWidth", {(void*)&orig_pWidth, (void*)&pWidth}},
    {"pHeight", {(void*)&orig_pHeight, (void*)&pHeight}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::SetColorSpace(
  DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS ColorSpace
) {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ColorSpace = ColorSpace;
  auto ret = m_pIDXGIDecodeSwapChain->SetColorSpace(
    ColorSpace
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "SetColorSpace", &ret, {
    {"ColorSpace", {(void*)&orig_ColorSpace, (void*)&ColorSpace}},
  });
  return ret;
}
DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS __stdcall WrappedIDXGIDecodeSwapChain::GetColorSpace() {
  assert(m_pIDXGIDecodeSwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIDecodeSwapChain->GetColorSpace();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDecodeSwapChain", "GetColorSpace", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDecodeSwapChain::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIDecodeSwapChain)) {
      *ppvObject = (IDXGIDecodeSwapChain*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIDecodeSwapChain::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIDecodeSwapChain::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactoryMedia::CreateSwapChainForCompositionSurfaceHandle(
  struct IUnknown * pDevice, 
  HANDLE hSurface, 
  const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
  IDXGIOutput * pRestrictToOutput, 
  IDXGISwapChain1 ** ppSwapChain
) {
  assert(m_pIDXGIFactoryMedia);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_hSurface = hSurface;
  auto orig_pDesc = pDesc;
  auto orig_pRestrictToOutput = pRestrictToOutput;
  auto orig_ppSwapChain = ppSwapChain;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pRestrictToOutput = unwrap(pRestrictToOutput);
  auto ret = m_pIDXGIFactoryMedia->CreateSwapChainForCompositionSurfaceHandle(
    unwrapped_pDevice, 
    hSurface, 
    unwrapped_pDesc, 
    unwrapped_pRestrictToOutput, 
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGISwapChain1, WrappedIDXGISwapChain4>(*ppSwapChain);
  dumpMethodEvent((void*)this, "IDXGIFactoryMedia", "CreateSwapChainForCompositionSurfaceHandle", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"hSurface", {(void*)&orig_hSurface, (void*)&hSurface}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pRestrictToOutput", {(void*)&orig_pRestrictToOutput, (void*)&pRestrictToOutput}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactoryMedia::CreateDecodeSwapChainForCompositionSurfaceHandle(
  struct IUnknown * pDevice, 
  HANDLE hSurface, 
  DXGI_DECODE_SWAP_CHAIN_DESC * pDesc, 
  IDXGIResource * pYuvDecodeBuffers, 
  IDXGIOutput * pRestrictToOutput, 
  IDXGIDecodeSwapChain ** ppSwapChain
) {
  assert(m_pIDXGIFactoryMedia);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_hSurface = hSurface;
  auto orig_pDesc = pDesc;
  auto orig_pYuvDecodeBuffers = pYuvDecodeBuffers;
  auto orig_pRestrictToOutput = pRestrictToOutput;
  auto orig_ppSwapChain = ppSwapChain;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pYuvDecodeBuffers = unwrap(pYuvDecodeBuffers);
  auto unwrapped_pRestrictToOutput = unwrap(pRestrictToOutput);
  auto ret = m_pIDXGIFactoryMedia->CreateDecodeSwapChainForCompositionSurfaceHandle(
    unwrapped_pDevice, 
    hSurface, 
    unwrapped_pDesc, 
    unwrapped_pYuvDecodeBuffers, 
    unwrapped_pRestrictToOutput, 
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGIDecodeSwapChain, WrappedIDXGIDecodeSwapChain>(*ppSwapChain);
  dumpMethodEvent((void*)this, "IDXGIFactoryMedia", "CreateDecodeSwapChainForCompositionSurfaceHandle", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"hSurface", {(void*)&orig_hSurface, (void*)&hSurface}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pYuvDecodeBuffers", {(void*)&orig_pYuvDecodeBuffers, (void*)&pYuvDecodeBuffers}},
    {"pRestrictToOutput", {(void*)&orig_pRestrictToOutput, (void*)&pRestrictToOutput}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactoryMedia::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIFactoryMedia)) {
      *ppvObject = (IDXGIFactoryMedia*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIFactoryMedia::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIFactoryMedia::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChainMedia::GetFrameStatisticsMedia(
  DXGI_FRAME_STATISTICS_MEDIA * pStats
) {
  assert(m_pIDXGISwapChainMedia);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pStats = pStats;
  auto ret = m_pIDXGISwapChainMedia->GetFrameStatisticsMedia(
    pStats
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChainMedia", "GetFrameStatisticsMedia", &ret, {
    {"pStats", {(void*)&orig_pStats, (void*)&pStats}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChainMedia::SetPresentDuration(
  UINT Duration
) {
  assert(m_pIDXGISwapChainMedia);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Duration = Duration;
  auto ret = m_pIDXGISwapChainMedia->SetPresentDuration(
    Duration
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChainMedia", "SetPresentDuration", &ret, {
    {"Duration", {(void*)&orig_Duration, (void*)&Duration}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChainMedia::CheckPresentDurationSupport(
  UINT DesiredPresentDuration, 
  UINT * pClosestSmallerPresentDuration, 
  UINT * pClosestLargerPresentDuration
) {
  assert(m_pIDXGISwapChainMedia);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_DesiredPresentDuration = DesiredPresentDuration;
  auto orig_pClosestSmallerPresentDuration = pClosestSmallerPresentDuration;
  auto orig_pClosestLargerPresentDuration = pClosestLargerPresentDuration;
  auto ret = m_pIDXGISwapChainMedia->CheckPresentDurationSupport(
    DesiredPresentDuration, 
    pClosestSmallerPresentDuration, 
    pClosestLargerPresentDuration
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChainMedia", "CheckPresentDurationSupport", &ret, {
    {"DesiredPresentDuration", {(void*)&orig_DesiredPresentDuration, (void*)&DesiredPresentDuration}},
    {"pClosestSmallerPresentDuration", {(void*)&orig_pClosestSmallerPresentDuration, (void*)&pClosestSmallerPresentDuration}},
    {"pClosestLargerPresentDuration", {(void*)&orig_pClosestLargerPresentDuration, (void*)&pClosestLargerPresentDuration}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChainMedia::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGISwapChainMedia)) {
      *ppvObject = (IDXGISwapChainMedia*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGISwapChainMedia::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGISwapChainMedia::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Texture2D1::GetDesc1(
  D3D11_TEXTURE2D_DESC1 * pDesc
) {
  assert(m_pID3D11Texture2D1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Texture2D1->GetDesc1(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Texture2D1", "GetDesc1", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11Texture2D1::GetDesc(
  D3D11_TEXTURE2D_DESC * pDesc
) {
  assert(m_pID3D11Texture2D);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Texture2D->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Texture2D", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11Texture2D1::GetType(
  D3D11_RESOURCE_DIMENSION * pResourceDimension
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResourceDimension = pResourceDimension;
  m_pID3D11Resource->GetType(
    pResourceDimension
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetType", nullptr, {
    {"pResourceDimension", {(void*)&orig_pResourceDimension, (void*)&pResourceDimension}},
  });
}
void __stdcall WrappedID3D11Texture2D1::SetEvictionPriority(
  UINT EvictionPriority
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EvictionPriority = EvictionPriority;
  m_pID3D11Resource->SetEvictionPriority(
    EvictionPriority
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "SetEvictionPriority", nullptr, {
    {"EvictionPriority", {(void*)&orig_EvictionPriority, (void*)&EvictionPriority}},
  });
}
UINT __stdcall WrappedID3D11Texture2D1::GetEvictionPriority() {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Resource->GetEvictionPriority();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetEvictionPriority", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Texture2D1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Texture2D1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture2D1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture2D1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture2D1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Texture2D1)) {
      *ppvObject = (ID3D11Texture2D1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Texture2D)) {
      *ppvObject = (ID3D11Texture2D*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Resource)) {
      *ppvObject = (ID3D11Resource*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Texture2D1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Texture2D1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Texture3D1::GetDesc1(
  D3D11_TEXTURE3D_DESC1 * pDesc
) {
  assert(m_pID3D11Texture3D1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Texture3D1->GetDesc1(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Texture3D1", "GetDesc1", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11Texture3D1::GetDesc(
  D3D11_TEXTURE3D_DESC * pDesc
) {
  assert(m_pID3D11Texture3D);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Texture3D->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Texture3D", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11Texture3D1::GetType(
  D3D11_RESOURCE_DIMENSION * pResourceDimension
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResourceDimension = pResourceDimension;
  m_pID3D11Resource->GetType(
    pResourceDimension
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetType", nullptr, {
    {"pResourceDimension", {(void*)&orig_pResourceDimension, (void*)&pResourceDimension}},
  });
}
void __stdcall WrappedID3D11Texture3D1::SetEvictionPriority(
  UINT EvictionPriority
) {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EvictionPriority = EvictionPriority;
  m_pID3D11Resource->SetEvictionPriority(
    EvictionPriority
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "SetEvictionPriority", nullptr, {
    {"EvictionPriority", {(void*)&orig_EvictionPriority, (void*)&EvictionPriority}},
  });
}
UINT __stdcall WrappedID3D11Texture3D1::GetEvictionPriority() {
  assert(m_pID3D11Resource);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Resource->GetEvictionPriority();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Resource", "GetEvictionPriority", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Texture3D1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Texture3D1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture3D1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture3D1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Texture3D1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Texture3D1)) {
      *ppvObject = (ID3D11Texture3D1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Texture3D)) {
      *ppvObject = (ID3D11Texture3D*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Resource)) {
      *ppvObject = (ID3D11Resource*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Texture3D1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Texture3D1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11RasterizerState2::GetDesc2(
  D3D11_RASTERIZER_DESC2 * pDesc
) {
  assert(m_pID3D11RasterizerState2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11RasterizerState2->GetDesc2(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RasterizerState2", "GetDesc2", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11RasterizerState2::GetDesc1(
  D3D11_RASTERIZER_DESC1 * pDesc
) {
  assert(m_pID3D11RasterizerState1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11RasterizerState1->GetDesc1(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RasterizerState1", "GetDesc1", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11RasterizerState2::GetDesc(
  D3D11_RASTERIZER_DESC * pDesc
) {
  assert(m_pID3D11RasterizerState);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11RasterizerState->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RasterizerState", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11RasterizerState2::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11RasterizerState2::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RasterizerState2::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RasterizerState2::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RasterizerState2::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11RasterizerState2)) {
      *ppvObject = (ID3D11RasterizerState2*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11RasterizerState1)) {
      *ppvObject = (ID3D11RasterizerState1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11RasterizerState)) {
      *ppvObject = (ID3D11RasterizerState*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RasterizerState2::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RasterizerState2::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11ShaderResourceView1::GetDesc1(
  D3D11_SHADER_RESOURCE_VIEW_DESC1 * pDesc1
) {
  assert(m_pID3D11ShaderResourceView1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc1 = pDesc1;
  m_pID3D11ShaderResourceView1->GetDesc1(
    pDesc1
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderResourceView1", "GetDesc1", nullptr, {
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
  });
}
void __stdcall WrappedID3D11ShaderResourceView1::GetDesc(
  D3D11_SHADER_RESOURCE_VIEW_DESC * pDesc
) {
  assert(m_pID3D11ShaderResourceView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11ShaderResourceView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderResourceView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11ShaderResourceView1::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11ShaderResourceView1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11ShaderResourceView1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderResourceView1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderResourceView1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderResourceView1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11ShaderResourceView1)) {
      *ppvObject = (ID3D11ShaderResourceView1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11ShaderResourceView)) {
      *ppvObject = (ID3D11ShaderResourceView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ShaderResourceView1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ShaderResourceView1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11RenderTargetView1::GetDesc1(
  D3D11_RENDER_TARGET_VIEW_DESC1 * pDesc1
) {
  assert(m_pID3D11RenderTargetView1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc1 = pDesc1;
  m_pID3D11RenderTargetView1->GetDesc1(
    pDesc1
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RenderTargetView1", "GetDesc1", nullptr, {
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
  });
}
void __stdcall WrappedID3D11RenderTargetView1::GetDesc(
  D3D11_RENDER_TARGET_VIEW_DESC * pDesc
) {
  assert(m_pID3D11RenderTargetView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11RenderTargetView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11RenderTargetView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11RenderTargetView1::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11RenderTargetView1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11RenderTargetView1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RenderTargetView1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RenderTargetView1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11RenderTargetView1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11RenderTargetView1)) {
      *ppvObject = (ID3D11RenderTargetView1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11RenderTargetView)) {
      *ppvObject = (ID3D11RenderTargetView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RenderTargetView1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11RenderTargetView1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11UnorderedAccessView1::GetDesc1(
  D3D11_UNORDERED_ACCESS_VIEW_DESC1 * pDesc1
) {
  assert(m_pID3D11UnorderedAccessView1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc1 = pDesc1;
  m_pID3D11UnorderedAccessView1->GetDesc1(
    pDesc1
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11UnorderedAccessView1", "GetDesc1", nullptr, {
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
  });
}
void __stdcall WrappedID3D11UnorderedAccessView1::GetDesc(
  D3D11_UNORDERED_ACCESS_VIEW_DESC * pDesc
) {
  assert(m_pID3D11UnorderedAccessView);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11UnorderedAccessView->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11UnorderedAccessView", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
void __stdcall WrappedID3D11UnorderedAccessView1::GetResource(
  ID3D11Resource ** ppResource
) {
  assert(m_pID3D11View);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResource = ppResource;
  m_pID3D11View->GetResource(
    ppResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(__uuidof(ID3D11Resource), (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11View", "GetResource", nullptr, {
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
}
void __stdcall WrappedID3D11UnorderedAccessView1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11UnorderedAccessView1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11UnorderedAccessView1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11UnorderedAccessView1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11UnorderedAccessView1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11UnorderedAccessView1)) {
      *ppvObject = (ID3D11UnorderedAccessView1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11UnorderedAccessView)) {
      *ppvObject = (ID3D11UnorderedAccessView*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11View)) {
      *ppvObject = (ID3D11View*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11UnorderedAccessView1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11UnorderedAccessView1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Query1::GetDesc1(
  D3D11_QUERY_DESC1 * pDesc1
) {
  assert(m_pID3D11Query1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc1 = pDesc1;
  m_pID3D11Query1->GetDesc1(
    pDesc1
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Query1", "GetDesc1", nullptr, {
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
  });
}
void __stdcall WrappedID3D11Query1::GetDesc(
  D3D11_QUERY_DESC * pDesc
) {
  assert(m_pID3D11Query);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  m_pID3D11Query->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Query", "GetDesc", nullptr, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
}
UINT __stdcall WrappedID3D11Query1::GetDataSize() {
  assert(m_pID3D11Asynchronous);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Asynchronous->GetDataSize();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Asynchronous", "GetDataSize", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Query1::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Query1::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Query1::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Query1::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Query1::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Query1)) {
      *ppvObject = (ID3D11Query1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Query)) {
      *ppvObject = (ID3D11Query*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Asynchronous)) {
      *ppvObject = (ID3D11Asynchronous*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Query1::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Query1::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11Fence::CreateSharedHandle(
  const SECURITY_ATTRIBUTES * pAttributes, 
  DWORD dwAccess, 
  LPCWSTR lpName, 
  HANDLE * pHandle
) {
  assert(m_pID3D11Fence);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAttributes = pAttributes;
  auto orig_dwAccess = dwAccess;
  auto orig_lpName = lpName;
  auto orig_pHandle = pHandle;
  auto unwrapped_pAttributes = unwrap(pAttributes);
  auto ret = m_pID3D11Fence->CreateSharedHandle(
    unwrapped_pAttributes, 
    dwAccess, 
    lpName, 
    pHandle
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Fence", "CreateSharedHandle", &ret, {
    {"pAttributes", {(void*)&orig_pAttributes, (void*)&pAttributes}},
    {"dwAccess", {(void*)&orig_dwAccess, (void*)&dwAccess}},
    {"lpName", {(void*)&orig_lpName, (void*)&lpName}},
    {"pHandle", {(void*)&orig_pHandle, (void*)&pHandle}},
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11Fence::GetCompletedValue() {
  assert(m_pID3D11Fence);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Fence->GetCompletedValue();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Fence", "GetCompletedValue", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Fence::SetEventOnCompletion(
  UINT64 Value, 
  HANDLE hEvent
) {
  assert(m_pID3D11Fence);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Value = Value;
  auto orig_hEvent = hEvent;
  auto ret = m_pID3D11Fence->SetEventOnCompletion(
    Value, 
    hEvent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Fence", "SetEventOnCompletion", &ret, {
    {"Value", {(void*)&orig_Value, (void*)&Value}},
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
  });
  return ret;
}
void __stdcall WrappedID3D11Fence::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11Fence::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Fence::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Fence::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Fence::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Fence)) {
      *ppvObject = (ID3D11Fence*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Fence::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Fence::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::Signal(
  ID3D11Fence * pFence, 
  UINT64 Value
) {
  assert(m_pID3D11DeviceContext4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFence = pFence;
  auto orig_Value = Value;
  auto unwrapped_pFence = unwrap(pFence);
  auto ret = m_pID3D11DeviceContext4->Signal(
    unwrapped_pFence, 
    Value
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext4", "Signal", &ret, {
    {"pFence", {(void*)&orig_pFence, (void*)&pFence}},
    {"Value", {(void*)&orig_Value, (void*)&Value}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::Wait(
  ID3D11Fence * pFence, 
  UINT64 Value
) {
  assert(m_pID3D11DeviceContext4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFence = pFence;
  auto orig_Value = Value;
  auto unwrapped_pFence = unwrap(pFence);
  auto ret = m_pID3D11DeviceContext4->Wait(
    unwrapped_pFence, 
    Value
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext4", "Wait", &ret, {
    {"pFence", {(void*)&orig_pFence, (void*)&pFence}},
    {"Value", {(void*)&orig_Value, (void*)&Value}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::Flush1(
  D3D11_CONTEXT_TYPE ContextType, 
  HANDLE hEvent
) {
  assert(m_pID3D11DeviceContext3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ContextType = ContextType;
  auto orig_hEvent = hEvent;
  m_pID3D11DeviceContext3->Flush1(
    ContextType, 
    hEvent
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext3", "Flush1", nullptr, {
    {"ContextType", {(void*)&orig_ContextType, (void*)&ContextType}},
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::SetHardwareProtectionState(
  BOOL HwProtectionEnable
) {
  assert(m_pID3D11DeviceContext3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_HwProtectionEnable = HwProtectionEnable;
  m_pID3D11DeviceContext3->SetHardwareProtectionState(
    HwProtectionEnable
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext3", "SetHardwareProtectionState", nullptr, {
    {"HwProtectionEnable", {(void*)&orig_HwProtectionEnable, (void*)&HwProtectionEnable}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GetHardwareProtectionState(
  BOOL * pHwProtectionEnable
) {
  assert(m_pID3D11DeviceContext3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pHwProtectionEnable = pHwProtectionEnable;
  m_pID3D11DeviceContext3->GetHardwareProtectionState(
    pHwProtectionEnable
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext3", "GetHardwareProtectionState", nullptr, {
    {"pHwProtectionEnable", {(void*)&orig_pHwProtectionEnable, (void*)&pHwProtectionEnable}},
  });
}
HRESULT __stdcall WrappedID3D11DeviceContext4::UpdateTileMappings(
  ID3D11Resource * pTiledResource, 
  UINT NumTiledResourceRegions, 
  const D3D11_TILED_RESOURCE_COORDINATE * pTiledResourceRegionStartCoordinates, 
  const D3D11_TILE_REGION_SIZE * pTiledResourceRegionSizes, 
  ID3D11Buffer * pTilePool, 
  UINT NumRanges, 
  const UINT * pRangeFlags, 
  const UINT * pTilePoolStartOffsets, 
  const UINT * pRangeTileCounts, 
  UINT Flags
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTiledResource = pTiledResource;
  auto orig_NumTiledResourceRegions = NumTiledResourceRegions;
  auto orig_pTiledResourceRegionStartCoordinates = pTiledResourceRegionStartCoordinates;
  auto orig_pTiledResourceRegionSizes = pTiledResourceRegionSizes;
  auto orig_pTilePool = pTilePool;
  auto orig_NumRanges = NumRanges;
  auto orig_pRangeFlags = pRangeFlags;
  auto orig_pTilePoolStartOffsets = pTilePoolStartOffsets;
  auto orig_pRangeTileCounts = pRangeTileCounts;
  auto orig_Flags = Flags;
  auto unwrapped_pTiledResource = unwrap(pTiledResource);
  auto unwrapped_pTilePool = unwrap(pTilePool);
  auto ret = m_pID3D11DeviceContext2->UpdateTileMappings(
    unwrapped_pTiledResource, 
    NumTiledResourceRegions, 
    pTiledResourceRegionStartCoordinates, 
    pTiledResourceRegionSizes, 
    unwrapped_pTilePool, 
    NumRanges, 
    pRangeFlags, 
    pTilePoolStartOffsets, 
    pRangeTileCounts, 
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "UpdateTileMappings", &ret, {
    {"pTiledResource", {(void*)&orig_pTiledResource, (void*)&pTiledResource}},
    {"NumTiledResourceRegions", {(void*)&orig_NumTiledResourceRegions, (void*)&NumTiledResourceRegions}},
    {"pTiledResourceRegionStartCoordinates", {(void*)&orig_pTiledResourceRegionStartCoordinates, (void*)&pTiledResourceRegionStartCoordinates}},
    {"pTiledResourceRegionSizes", {(void*)&orig_pTiledResourceRegionSizes, (void*)&pTiledResourceRegionSizes}},
    {"pTilePool", {(void*)&orig_pTilePool, (void*)&pTilePool}},
    {"NumRanges", {(void*)&orig_NumRanges, (void*)&NumRanges}},
    {"pRangeFlags", {(void*)&orig_pRangeFlags, (void*)&pRangeFlags}},
    {"pTilePoolStartOffsets", {(void*)&orig_pTilePoolStartOffsets, (void*)&pTilePoolStartOffsets}},
    {"pRangeTileCounts", {(void*)&orig_pRangeTileCounts, (void*)&pRangeTileCounts}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::CopyTileMappings(
  ID3D11Resource * pDestTiledResource, 
  const D3D11_TILED_RESOURCE_COORDINATE * pDestRegionStartCoordinate, 
  ID3D11Resource * pSourceTiledResource, 
  const D3D11_TILED_RESOURCE_COORDINATE * pSourceRegionStartCoordinate, 
  const D3D11_TILE_REGION_SIZE * pTileRegionSize, 
  UINT Flags
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDestTiledResource = pDestTiledResource;
  auto orig_pDestRegionStartCoordinate = pDestRegionStartCoordinate;
  auto orig_pSourceTiledResource = pSourceTiledResource;
  auto orig_pSourceRegionStartCoordinate = pSourceRegionStartCoordinate;
  auto orig_pTileRegionSize = pTileRegionSize;
  auto orig_Flags = Flags;
  auto unwrapped_pDestTiledResource = unwrap(pDestTiledResource);
  auto unwrapped_pDestRegionStartCoordinate = unwrap(pDestRegionStartCoordinate);
  auto unwrapped_pSourceTiledResource = unwrap(pSourceTiledResource);
  auto unwrapped_pSourceRegionStartCoordinate = unwrap(pSourceRegionStartCoordinate);
  auto unwrapped_pTileRegionSize = unwrap(pTileRegionSize);
  auto ret = m_pID3D11DeviceContext2->CopyTileMappings(
    unwrapped_pDestTiledResource, 
    unwrapped_pDestRegionStartCoordinate, 
    unwrapped_pSourceTiledResource, 
    unwrapped_pSourceRegionStartCoordinate, 
    unwrapped_pTileRegionSize, 
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "CopyTileMappings", &ret, {
    {"pDestTiledResource", {(void*)&orig_pDestTiledResource, (void*)&pDestTiledResource}},
    {"pDestRegionStartCoordinate", {(void*)&orig_pDestRegionStartCoordinate, (void*)&pDestRegionStartCoordinate}},
    {"pSourceTiledResource", {(void*)&orig_pSourceTiledResource, (void*)&pSourceTiledResource}},
    {"pSourceRegionStartCoordinate", {(void*)&orig_pSourceRegionStartCoordinate, (void*)&pSourceRegionStartCoordinate}},
    {"pTileRegionSize", {(void*)&orig_pTileRegionSize, (void*)&pTileRegionSize}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::CopyTiles(
  ID3D11Resource * pTiledResource, 
  const D3D11_TILED_RESOURCE_COORDINATE * pTileRegionStartCoordinate, 
  const D3D11_TILE_REGION_SIZE * pTileRegionSize, 
  ID3D11Buffer * pBuffer, 
  UINT64 BufferStartOffsetInBytes, 
  UINT Flags
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTiledResource = pTiledResource;
  auto orig_pTileRegionStartCoordinate = pTileRegionStartCoordinate;
  auto orig_pTileRegionSize = pTileRegionSize;
  auto orig_pBuffer = pBuffer;
  auto orig_BufferStartOffsetInBytes = BufferStartOffsetInBytes;
  auto orig_Flags = Flags;
  auto unwrapped_pTiledResource = unwrap(pTiledResource);
  auto unwrapped_pTileRegionStartCoordinate = unwrap(pTileRegionStartCoordinate);
  auto unwrapped_pTileRegionSize = unwrap(pTileRegionSize);
  auto unwrapped_pBuffer = unwrap(pBuffer);
  m_pID3D11DeviceContext2->CopyTiles(
    unwrapped_pTiledResource, 
    unwrapped_pTileRegionStartCoordinate, 
    unwrapped_pTileRegionSize, 
    unwrapped_pBuffer, 
    BufferStartOffsetInBytes, 
    Flags
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "CopyTiles", nullptr, {
    {"pTiledResource", {(void*)&orig_pTiledResource, (void*)&pTiledResource}},
    {"pTileRegionStartCoordinate", {(void*)&orig_pTileRegionStartCoordinate, (void*)&pTileRegionStartCoordinate}},
    {"pTileRegionSize", {(void*)&orig_pTileRegionSize, (void*)&pTileRegionSize}},
    {"pBuffer", {(void*)&orig_pBuffer, (void*)&pBuffer}},
    {"BufferStartOffsetInBytes", {(void*)&orig_BufferStartOffsetInBytes, (void*)&BufferStartOffsetInBytes}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::UpdateTiles(
  ID3D11Resource * pDestTiledResource, 
  const D3D11_TILED_RESOURCE_COORDINATE * pDestTileRegionStartCoordinate, 
  const D3D11_TILE_REGION_SIZE * pDestTileRegionSize, 
  const void * pSourceTileData, 
  UINT Flags
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDestTiledResource = pDestTiledResource;
  auto orig_pDestTileRegionStartCoordinate = pDestTileRegionStartCoordinate;
  auto orig_pDestTileRegionSize = pDestTileRegionSize;
  auto orig_pSourceTileData = pSourceTileData;
  auto orig_Flags = Flags;
  auto unwrapped_pDestTiledResource = unwrap(pDestTiledResource);
  auto unwrapped_pDestTileRegionStartCoordinate = unwrap(pDestTileRegionStartCoordinate);
  auto unwrapped_pDestTileRegionSize = unwrap(pDestTileRegionSize);
  auto unwrapped_pSourceTileData = unwrap(pSourceTileData);
  m_pID3D11DeviceContext2->UpdateTiles(
    unwrapped_pDestTiledResource, 
    unwrapped_pDestTileRegionStartCoordinate, 
    unwrapped_pDestTileRegionSize, 
    unwrapped_pSourceTileData, 
    Flags
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "UpdateTiles", nullptr, {
    {"pDestTiledResource", {(void*)&orig_pDestTiledResource, (void*)&pDestTiledResource}},
    {"pDestTileRegionStartCoordinate", {(void*)&orig_pDestTileRegionStartCoordinate, (void*)&pDestTileRegionStartCoordinate}},
    {"pDestTileRegionSize", {(void*)&orig_pDestTileRegionSize, (void*)&pDestTileRegionSize}},
    {"pSourceTileData", {(void*)&orig_pSourceTileData, (void*)&pSourceTileData}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
}
HRESULT __stdcall WrappedID3D11DeviceContext4::ResizeTilePool(
  ID3D11Buffer * pTilePool, 
  UINT64 NewSizeInBytes
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTilePool = pTilePool;
  auto orig_NewSizeInBytes = NewSizeInBytes;
  auto unwrapped_pTilePool = unwrap(pTilePool);
  auto ret = m_pID3D11DeviceContext2->ResizeTilePool(
    unwrapped_pTilePool, 
    NewSizeInBytes
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "ResizeTilePool", &ret, {
    {"pTilePool", {(void*)&orig_pTilePool, (void*)&pTilePool}},
    {"NewSizeInBytes", {(void*)&orig_NewSizeInBytes, (void*)&NewSizeInBytes}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::TiledResourceBarrier(
  struct ID3D11DeviceChild * pTiledResourceOrViewAccessBeforeBarrier, 
  struct ID3D11DeviceChild * pTiledResourceOrViewAccessAfterBarrier
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTiledResourceOrViewAccessBeforeBarrier = pTiledResourceOrViewAccessBeforeBarrier;
  auto orig_pTiledResourceOrViewAccessAfterBarrier = pTiledResourceOrViewAccessAfterBarrier;
  auto unwrapped_pTiledResourceOrViewAccessBeforeBarrier = unwrap(pTiledResourceOrViewAccessBeforeBarrier);
  auto unwrapped_pTiledResourceOrViewAccessAfterBarrier = unwrap(pTiledResourceOrViewAccessAfterBarrier);
  m_pID3D11DeviceContext2->TiledResourceBarrier(
    unwrapped_pTiledResourceOrViewAccessBeforeBarrier, 
    unwrapped_pTiledResourceOrViewAccessAfterBarrier
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "TiledResourceBarrier", nullptr, {
    {"pTiledResourceOrViewAccessBeforeBarrier", {(void*)&orig_pTiledResourceOrViewAccessBeforeBarrier, (void*)&pTiledResourceOrViewAccessBeforeBarrier}},
    {"pTiledResourceOrViewAccessAfterBarrier", {(void*)&orig_pTiledResourceOrViewAccessAfterBarrier, (void*)&pTiledResourceOrViewAccessAfterBarrier}},
  });
}
BOOL __stdcall WrappedID3D11DeviceContext4::IsAnnotationEnabled() {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11DeviceContext2->IsAnnotationEnabled();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "IsAnnotationEnabled", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::SetMarkerInt(
  LPCWSTR pLabel, 
  INT Data
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLabel = pLabel;
  auto orig_Data = Data;
  m_pID3D11DeviceContext2->SetMarkerInt(
    pLabel, 
    Data
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "SetMarkerInt", nullptr, {
    {"pLabel", {(void*)&orig_pLabel, (void*)&pLabel}},
    {"Data", {(void*)&orig_Data, (void*)&Data}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::BeginEventInt(
  LPCWSTR pLabel, 
  INT Data
) {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLabel = pLabel;
  auto orig_Data = Data;
  m_pID3D11DeviceContext2->BeginEventInt(
    pLabel, 
    Data
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "BeginEventInt", nullptr, {
    {"pLabel", {(void*)&orig_pLabel, (void*)&pLabel}},
    {"Data", {(void*)&orig_Data, (void*)&Data}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::EndEvent() {
  assert(m_pID3D11DeviceContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11DeviceContext2->EndEvent();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext2", "EndEvent", nullptr, {
  });
}
void __stdcall WrappedID3D11DeviceContext4::CopySubresourceRegion1(
  ID3D11Resource * pDstResource, 
  UINT DstSubresource, 
  UINT DstX, 
  UINT DstY, 
  UINT DstZ, 
  ID3D11Resource * pSrcResource, 
  UINT SrcSubresource, 
  const D3D11_BOX * pSrcBox, 
  UINT CopyFlags
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_DstSubresource = DstSubresource;
  auto orig_DstX = DstX;
  auto orig_DstY = DstY;
  auto orig_DstZ = DstZ;
  auto orig_pSrcResource = pSrcResource;
  auto orig_SrcSubresource = SrcSubresource;
  auto orig_pSrcBox = pSrcBox;
  auto orig_CopyFlags = CopyFlags;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pSrcResource = unwrap(pSrcResource);
  auto unwrapped_pSrcBox = unwrap(pSrcBox);
  m_pID3D11DeviceContext1->CopySubresourceRegion1(
    unwrapped_pDstResource, 
    DstSubresource, 
    DstX, 
    DstY, 
    DstZ, 
    unwrapped_pSrcResource, 
    SrcSubresource, 
    unwrapped_pSrcBox, 
    CopyFlags
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "CopySubresourceRegion1", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"DstSubresource", {(void*)&orig_DstSubresource, (void*)&DstSubresource}},
    {"DstX", {(void*)&orig_DstX, (void*)&DstX}},
    {"DstY", {(void*)&orig_DstY, (void*)&DstY}},
    {"DstZ", {(void*)&orig_DstZ, (void*)&DstZ}},
    {"pSrcResource", {(void*)&orig_pSrcResource, (void*)&pSrcResource}},
    {"SrcSubresource", {(void*)&orig_SrcSubresource, (void*)&SrcSubresource}},
    {"pSrcBox", {(void*)&orig_pSrcBox, (void*)&pSrcBox}},
    {"CopyFlags", {(void*)&orig_CopyFlags, (void*)&CopyFlags}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::UpdateSubresource1(
  ID3D11Resource * pDstResource, 
  UINT DstSubresource, 
  const D3D11_BOX * pDstBox, 
  const void * pSrcData, 
  UINT SrcRowPitch, 
  UINT SrcDepthPitch, 
  UINT CopyFlags
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_DstSubresource = DstSubresource;
  auto orig_pDstBox = pDstBox;
  auto orig_pSrcData = pSrcData;
  auto orig_SrcRowPitch = SrcRowPitch;
  auto orig_SrcDepthPitch = SrcDepthPitch;
  auto orig_CopyFlags = CopyFlags;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pDstBox = unwrap(pDstBox);
  auto unwrapped_pSrcData = unwrap(pSrcData);
  m_pID3D11DeviceContext1->UpdateSubresource1(
    unwrapped_pDstResource, 
    DstSubresource, 
    unwrapped_pDstBox, 
    unwrapped_pSrcData, 
    SrcRowPitch, 
    SrcDepthPitch, 
    CopyFlags
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "UpdateSubresource1", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"DstSubresource", {(void*)&orig_DstSubresource, (void*)&DstSubresource}},
    {"pDstBox", {(void*)&orig_pDstBox, (void*)&pDstBox}},
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcRowPitch", {(void*)&orig_SrcRowPitch, (void*)&SrcRowPitch}},
    {"SrcDepthPitch", {(void*)&orig_SrcDepthPitch, (void*)&SrcDepthPitch}},
    {"CopyFlags", {(void*)&orig_CopyFlags, (void*)&CopyFlags}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DiscardResource(
  ID3D11Resource * pResource
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto unwrapped_pResource = unwrap(pResource);
  m_pID3D11DeviceContext1->DiscardResource(
    unwrapped_pResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "DiscardResource", nullptr, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DiscardView(
  ID3D11View * pResourceView
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResourceView = pResourceView;
  auto unwrapped_pResourceView = unwrap(pResourceView);
  m_pID3D11DeviceContext1->DiscardView(
    unwrapped_pResourceView
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "DiscardView", nullptr, {
    {"pResourceView", {(void*)&orig_pResourceView, (void*)&pResourceView}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSSetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers, 
  const UINT * pFirstConstant, 
  const UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext1->VSSetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "VSSetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSSetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers, 
  const UINT * pFirstConstant, 
  const UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext1->HSSetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "HSSetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSSetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers, 
  const UINT * pFirstConstant, 
  const UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext1->DSSetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "DSSetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSSetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers, 
  const UINT * pFirstConstant, 
  const UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext1->GSSetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "GSSetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSSetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers, 
  const UINT * pFirstConstant, 
  const UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext1->PSSetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "PSSetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSSetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers, 
  const UINT * pFirstConstant, 
  const UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext1->CSSetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "CSSetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSGetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers, 
  UINT * pFirstConstant, 
  UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  m_pID3D11DeviceContext1->VSGetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "VSGetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSGetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers, 
  UINT * pFirstConstant, 
  UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  m_pID3D11DeviceContext1->HSGetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "HSGetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSGetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers, 
  UINT * pFirstConstant, 
  UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  m_pID3D11DeviceContext1->DSGetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "DSGetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSGetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers, 
  UINT * pFirstConstant, 
  UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  m_pID3D11DeviceContext1->GSGetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "GSGetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSGetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers, 
  UINT * pFirstConstant, 
  UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  m_pID3D11DeviceContext1->PSGetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "PSGetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSGetConstantBuffers1(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers, 
  UINT * pFirstConstant, 
  UINT * pNumConstants
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  auto orig_pFirstConstant = pFirstConstant;
  auto orig_pNumConstants = pNumConstants;
  m_pID3D11DeviceContext1->CSGetConstantBuffers1(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers, 
    pFirstConstant, 
    pNumConstants
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "CSGetConstantBuffers1", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
    {"pFirstConstant", {(void*)&orig_pFirstConstant, (void*)&pFirstConstant}},
    {"pNumConstants", {(void*)&orig_pNumConstants, (void*)&pNumConstants}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::SwapDeviceContextState(
  ID3DDeviceContextState * pState, 
  ID3DDeviceContextState ** ppPreviousState
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pState = pState;
  auto orig_ppPreviousState = ppPreviousState;
  auto unwrapped_pState = unwrap(pState);
  m_pID3D11DeviceContext1->SwapDeviceContextState(
    unwrapped_pState, 
    ppPreviousState
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppPreviousState && *ppPreviousState ) *ppPreviousState = getWrapper<ID3DDeviceContextState, WrappedID3DDeviceContextState>(*ppPreviousState);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "SwapDeviceContextState", nullptr, {
    {"pState", {(void*)&orig_pState, (void*)&pState}},
    {"ppPreviousState", {(void*)&orig_ppPreviousState, (void*)&ppPreviousState}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ClearView(
  ID3D11View * pView, 
  const FLOAT * Color, 
  const D3D11_RECT * pRect, 
  UINT NumRects
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pView = pView;
  auto orig_Color = Color;
  auto orig_pRect = pRect;
  auto orig_NumRects = NumRects;
  auto unwrapped_pView = unwrap(pView);
  auto unwrapped_Color = unwrap(Color);
  m_pID3D11DeviceContext1->ClearView(
    unwrapped_pView, 
    unwrapped_Color, 
    pRect, 
    NumRects
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "ClearView", nullptr, {
    {"pView", {(void*)&orig_pView, (void*)&pView}},
    {"Color", {(void*)&orig_Color, (void*)&Color}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
    {"NumRects", {(void*)&orig_NumRects, (void*)&NumRects}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DiscardView1(
  ID3D11View * pResourceView, 
  const D3D11_RECT * pRects, 
  UINT NumRects
) {
  assert(m_pID3D11DeviceContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResourceView = pResourceView;
  auto orig_pRects = pRects;
  auto orig_NumRects = NumRects;
  auto unwrapped_pResourceView = unwrap(pResourceView);
  m_pID3D11DeviceContext1->DiscardView1(
    unwrapped_pResourceView, 
    pRects, 
    NumRects
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext1", "DiscardView1", nullptr, {
    {"pResourceView", {(void*)&orig_pResourceView, (void*)&pResourceView}},
    {"pRects", {(void*)&orig_pRects, (void*)&pRects}},
    {"NumRects", {(void*)&orig_NumRects, (void*)&NumRects}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSSetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext->VSSetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSSetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSSetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView *const * ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  ID3D11ShaderResourceView  *tmp_ppShaderResourceViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppShaderResourceViews[i] = unwrap(ppShaderResourceViews[i]);
  m_pID3D11DeviceContext->PSSetShaderResources(
    StartSlot, 
    NumViews, 
    tmp_ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSSetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSSetShader(
  ID3D11PixelShader * pPixelShader, 
  ID3D11ClassInstance *const * ppClassInstances, 
  UINT NumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pPixelShader = pPixelShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_NumClassInstances = NumClassInstances;
  auto unwrapped_pPixelShader = unwrap(pPixelShader);
  ID3D11ClassInstance  *tmp_ppClassInstances[0x80];
  for (uint32_t i = 0; i < NumClassInstances; i++) tmp_ppClassInstances[i] = unwrap(ppClassInstances[i]);
  m_pID3D11DeviceContext->PSSetShader(
    unwrapped_pPixelShader, 
    tmp_ppClassInstances, 
    NumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSSetShader", nullptr, {
    {"pPixelShader", {(void*)&orig_pPixelShader, (void*)&pPixelShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"NumClassInstances", {(void*)&orig_NumClassInstances, (void*)&NumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSSetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState *const * ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  ID3D11SamplerState  *tmp_ppSamplers[0x80];
  for (uint32_t i = 0; i < NumSamplers; i++) tmp_ppSamplers[i] = unwrap(ppSamplers[i]);
  m_pID3D11DeviceContext->PSSetSamplers(
    StartSlot, 
    NumSamplers, 
    tmp_ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSSetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSSetShader(
  ID3D11VertexShader * pVertexShader, 
  ID3D11ClassInstance *const * ppClassInstances, 
  UINT NumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVertexShader = pVertexShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_NumClassInstances = NumClassInstances;
  auto unwrapped_pVertexShader = unwrap(pVertexShader);
  ID3D11ClassInstance  *tmp_ppClassInstances[0x80];
  for (uint32_t i = 0; i < NumClassInstances; i++) tmp_ppClassInstances[i] = unwrap(ppClassInstances[i]);
  m_pID3D11DeviceContext->VSSetShader(
    unwrapped_pVertexShader, 
    tmp_ppClassInstances, 
    NumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSSetShader", nullptr, {
    {"pVertexShader", {(void*)&orig_pVertexShader, (void*)&pVertexShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"NumClassInstances", {(void*)&orig_NumClassInstances, (void*)&NumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DrawIndexed(
  UINT IndexCount, 
  UINT StartIndexLocation, 
  INT BaseVertexLocation
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_IndexCount = IndexCount;
  auto orig_StartIndexLocation = StartIndexLocation;
  auto orig_BaseVertexLocation = BaseVertexLocation;
  m_pID3D11DeviceContext->DrawIndexed(
    IndexCount, 
    StartIndexLocation, 
    BaseVertexLocation
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DrawIndexed", nullptr, {
    {"IndexCount", {(void*)&orig_IndexCount, (void*)&IndexCount}},
    {"StartIndexLocation", {(void*)&orig_StartIndexLocation, (void*)&StartIndexLocation}},
    {"BaseVertexLocation", {(void*)&orig_BaseVertexLocation, (void*)&BaseVertexLocation}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::Draw(
  UINT VertexCount, 
  UINT StartVertexLocation
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_VertexCount = VertexCount;
  auto orig_StartVertexLocation = StartVertexLocation;
  m_pID3D11DeviceContext->Draw(
    VertexCount, 
    StartVertexLocation
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "Draw", nullptr, {
    {"VertexCount", {(void*)&orig_VertexCount, (void*)&VertexCount}},
    {"StartVertexLocation", {(void*)&orig_StartVertexLocation, (void*)&StartVertexLocation}},
  });
}
HRESULT __stdcall WrappedID3D11DeviceContext4::Map(
  ID3D11Resource * pResource, 
  UINT Subresource, 
  D3D11_MAP MapType, 
  UINT MapFlags, 
  D3D11_MAPPED_SUBRESOURCE * pMappedResource
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_Subresource = Subresource;
  auto orig_MapType = MapType;
  auto orig_MapFlags = MapFlags;
  auto orig_pMappedResource = pMappedResource;
  auto unwrapped_pResource = unwrap(pResource);
  auto ret = m_pID3D11DeviceContext->Map(
    unwrapped_pResource, 
    Subresource, 
    MapType, 
    MapFlags, 
    pMappedResource
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "Map", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"Subresource", {(void*)&orig_Subresource, (void*)&Subresource}},
    {"MapType", {(void*)&orig_MapType, (void*)&MapType}},
    {"MapFlags", {(void*)&orig_MapFlags, (void*)&MapFlags}},
    {"pMappedResource", {(void*)&orig_pMappedResource, (void*)&pMappedResource}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::Unmap(
  ID3D11Resource * pResource, 
  UINT Subresource
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_Subresource = Subresource;
  auto unwrapped_pResource = unwrap(pResource);
  m_pID3D11DeviceContext->Unmap(
    unwrapped_pResource, 
    Subresource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "Unmap", nullptr, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"Subresource", {(void*)&orig_Subresource, (void*)&Subresource}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSSetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext->PSSetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSSetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IASetInputLayout(
  ID3D11InputLayout * pInputLayout
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pInputLayout = pInputLayout;
  auto unwrapped_pInputLayout = unwrap(pInputLayout);
  m_pID3D11DeviceContext->IASetInputLayout(
    unwrapped_pInputLayout
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IASetInputLayout", nullptr, {
    {"pInputLayout", {(void*)&orig_pInputLayout, (void*)&pInputLayout}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IASetVertexBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppVertexBuffers, 
  const UINT * pStrides, 
  const UINT * pOffsets
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppVertexBuffers = ppVertexBuffers;
  auto orig_pStrides = pStrides;
  auto orig_pOffsets = pOffsets;
  ID3D11Buffer  *tmp_ppVertexBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppVertexBuffers[i] = unwrap(ppVertexBuffers[i]);
  m_pID3D11DeviceContext->IASetVertexBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppVertexBuffers, 
    pStrides, 
    pOffsets
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IASetVertexBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppVertexBuffers", {(void*)&orig_ppVertexBuffers, (void*)&ppVertexBuffers}},
    {"pStrides", {(void*)&orig_pStrides, (void*)&pStrides}},
    {"pOffsets", {(void*)&orig_pOffsets, (void*)&pOffsets}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IASetIndexBuffer(
  ID3D11Buffer * pIndexBuffer, 
  DXGI_FORMAT Format, 
  UINT Offset
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pIndexBuffer = pIndexBuffer;
  auto orig_Format = Format;
  auto orig_Offset = Offset;
  auto unwrapped_pIndexBuffer = unwrap(pIndexBuffer);
  m_pID3D11DeviceContext->IASetIndexBuffer(
    unwrapped_pIndexBuffer, 
    Format, 
    Offset
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IASetIndexBuffer", nullptr, {
    {"pIndexBuffer", {(void*)&orig_pIndexBuffer, (void*)&pIndexBuffer}},
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"Offset", {(void*)&orig_Offset, (void*)&Offset}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DrawIndexedInstanced(
  UINT IndexCountPerInstance, 
  UINT InstanceCount, 
  UINT StartIndexLocation, 
  INT BaseVertexLocation, 
  UINT StartInstanceLocation
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_IndexCountPerInstance = IndexCountPerInstance;
  auto orig_InstanceCount = InstanceCount;
  auto orig_StartIndexLocation = StartIndexLocation;
  auto orig_BaseVertexLocation = BaseVertexLocation;
  auto orig_StartInstanceLocation = StartInstanceLocation;
  m_pID3D11DeviceContext->DrawIndexedInstanced(
    IndexCountPerInstance, 
    InstanceCount, 
    StartIndexLocation, 
    BaseVertexLocation, 
    StartInstanceLocation
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DrawIndexedInstanced", nullptr, {
    {"IndexCountPerInstance", {(void*)&orig_IndexCountPerInstance, (void*)&IndexCountPerInstance}},
    {"InstanceCount", {(void*)&orig_InstanceCount, (void*)&InstanceCount}},
    {"StartIndexLocation", {(void*)&orig_StartIndexLocation, (void*)&StartIndexLocation}},
    {"BaseVertexLocation", {(void*)&orig_BaseVertexLocation, (void*)&BaseVertexLocation}},
    {"StartInstanceLocation", {(void*)&orig_StartInstanceLocation, (void*)&StartInstanceLocation}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DrawInstanced(
  UINT VertexCountPerInstance, 
  UINT InstanceCount, 
  UINT StartVertexLocation, 
  UINT StartInstanceLocation
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_VertexCountPerInstance = VertexCountPerInstance;
  auto orig_InstanceCount = InstanceCount;
  auto orig_StartVertexLocation = StartVertexLocation;
  auto orig_StartInstanceLocation = StartInstanceLocation;
  m_pID3D11DeviceContext->DrawInstanced(
    VertexCountPerInstance, 
    InstanceCount, 
    StartVertexLocation, 
    StartInstanceLocation
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DrawInstanced", nullptr, {
    {"VertexCountPerInstance", {(void*)&orig_VertexCountPerInstance, (void*)&VertexCountPerInstance}},
    {"InstanceCount", {(void*)&orig_InstanceCount, (void*)&InstanceCount}},
    {"StartVertexLocation", {(void*)&orig_StartVertexLocation, (void*)&StartVertexLocation}},
    {"StartInstanceLocation", {(void*)&orig_StartInstanceLocation, (void*)&StartInstanceLocation}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSSetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext->GSSetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSSetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSSetShader(
  ID3D11GeometryShader * pShader, 
  ID3D11ClassInstance *const * ppClassInstances, 
  UINT NumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShader = pShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_NumClassInstances = NumClassInstances;
  auto unwrapped_pShader = unwrap(pShader);
  ID3D11ClassInstance  *tmp_ppClassInstances[0x80];
  for (uint32_t i = 0; i < NumClassInstances; i++) tmp_ppClassInstances[i] = unwrap(ppClassInstances[i]);
  m_pID3D11DeviceContext->GSSetShader(
    unwrapped_pShader, 
    tmp_ppClassInstances, 
    NumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSSetShader", nullptr, {
    {"pShader", {(void*)&orig_pShader, (void*)&pShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"NumClassInstances", {(void*)&orig_NumClassInstances, (void*)&NumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IASetPrimitiveTopology(
  D3D11_PRIMITIVE_TOPOLOGY Topology
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Topology = Topology;
  m_pID3D11DeviceContext->IASetPrimitiveTopology(
    Topology
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IASetPrimitiveTopology", nullptr, {
    {"Topology", {(void*)&orig_Topology, (void*)&Topology}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSSetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView *const * ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  ID3D11ShaderResourceView  *tmp_ppShaderResourceViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppShaderResourceViews[i] = unwrap(ppShaderResourceViews[i]);
  m_pID3D11DeviceContext->VSSetShaderResources(
    StartSlot, 
    NumViews, 
    tmp_ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSSetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSSetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState *const * ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  ID3D11SamplerState  *tmp_ppSamplers[0x80];
  for (uint32_t i = 0; i < NumSamplers; i++) tmp_ppSamplers[i] = unwrap(ppSamplers[i]);
  m_pID3D11DeviceContext->VSSetSamplers(
    StartSlot, 
    NumSamplers, 
    tmp_ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSSetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::Begin(
  ID3D11Asynchronous * pAsync
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAsync = pAsync;
  auto unwrapped_pAsync = unwrap(pAsync);
  m_pID3D11DeviceContext->Begin(
    unwrapped_pAsync
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "Begin", nullptr, {
    {"pAsync", {(void*)&orig_pAsync, (void*)&pAsync}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::End(
  ID3D11Asynchronous * pAsync
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAsync = pAsync;
  auto unwrapped_pAsync = unwrap(pAsync);
  m_pID3D11DeviceContext->End(
    unwrapped_pAsync
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "End", nullptr, {
    {"pAsync", {(void*)&orig_pAsync, (void*)&pAsync}},
  });
}
HRESULT __stdcall WrappedID3D11DeviceContext4::GetData(
  ID3D11Asynchronous * pAsync, 
  void * pData, 
  UINT DataSize, 
  UINT GetDataFlags
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAsync = pAsync;
  auto orig_pData = pData;
  auto orig_DataSize = DataSize;
  auto orig_GetDataFlags = GetDataFlags;
  auto unwrapped_pAsync = unwrap(pAsync);
  auto ret = m_pID3D11DeviceContext->GetData(
    unwrapped_pAsync, 
    pData, 
    DataSize, 
    GetDataFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GetData", &ret, {
    {"pAsync", {(void*)&orig_pAsync, (void*)&pAsync}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"GetDataFlags", {(void*)&orig_GetDataFlags, (void*)&GetDataFlags}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::SetPredication(
  ID3D11Predicate * pPredicate, 
  BOOL PredicateValue
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pPredicate = pPredicate;
  auto orig_PredicateValue = PredicateValue;
  auto unwrapped_pPredicate = unwrap(pPredicate);
  m_pID3D11DeviceContext->SetPredication(
    unwrapped_pPredicate, 
    PredicateValue
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "SetPredication", nullptr, {
    {"pPredicate", {(void*)&orig_pPredicate, (void*)&pPredicate}},
    {"PredicateValue", {(void*)&orig_PredicateValue, (void*)&PredicateValue}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSSetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView *const * ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  ID3D11ShaderResourceView  *tmp_ppShaderResourceViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppShaderResourceViews[i] = unwrap(ppShaderResourceViews[i]);
  m_pID3D11DeviceContext->GSSetShaderResources(
    StartSlot, 
    NumViews, 
    tmp_ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSSetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSSetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState *const * ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  ID3D11SamplerState  *tmp_ppSamplers[0x80];
  for (uint32_t i = 0; i < NumSamplers; i++) tmp_ppSamplers[i] = unwrap(ppSamplers[i]);
  m_pID3D11DeviceContext->GSSetSamplers(
    StartSlot, 
    NumSamplers, 
    tmp_ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSSetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMSetRenderTargets(
  UINT NumViews, 
  ID3D11RenderTargetView *const * ppRenderTargetViews, 
  ID3D11DepthStencilView * pDepthStencilView
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumViews = NumViews;
  auto orig_ppRenderTargetViews = ppRenderTargetViews;
  auto orig_pDepthStencilView = pDepthStencilView;
  ID3D11RenderTargetView  *tmp_ppRenderTargetViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppRenderTargetViews[i] = unwrap(ppRenderTargetViews[i]);
  auto unwrapped_pDepthStencilView = unwrap(pDepthStencilView);
  m_pID3D11DeviceContext->OMSetRenderTargets(
    NumViews, 
    tmp_ppRenderTargetViews, 
    unwrapped_pDepthStencilView
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMSetRenderTargets", nullptr, {
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppRenderTargetViews", {(void*)&orig_ppRenderTargetViews, (void*)&ppRenderTargetViews}},
    {"pDepthStencilView", {(void*)&orig_pDepthStencilView, (void*)&pDepthStencilView}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMSetRenderTargetsAndUnorderedAccessViews(
  UINT NumRTVs, 
  ID3D11RenderTargetView *const * ppRenderTargetViews, 
  ID3D11DepthStencilView * pDepthStencilView, 
  UINT UAVStartSlot, 
  UINT NumUAVs, 
  ID3D11UnorderedAccessView *const * ppUnorderedAccessViews, 
  const UINT * pUAVInitialCounts
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumRTVs = NumRTVs;
  auto orig_ppRenderTargetViews = ppRenderTargetViews;
  auto orig_pDepthStencilView = pDepthStencilView;
  auto orig_UAVStartSlot = UAVStartSlot;
  auto orig_NumUAVs = NumUAVs;
  auto orig_ppUnorderedAccessViews = ppUnorderedAccessViews;
  auto orig_pUAVInitialCounts = pUAVInitialCounts;
  ID3D11RenderTargetView  *tmp_ppRenderTargetViews[0x80];
  for (uint32_t i = 0; i < NumRTVs; i++) tmp_ppRenderTargetViews[i] = unwrap(ppRenderTargetViews[i]);
  auto unwrapped_pDepthStencilView = unwrap(pDepthStencilView);
  ID3D11UnorderedAccessView  *tmp_ppUnorderedAccessViews[0x80];
  for (uint32_t i = 0; i < NumUAVs; i++) tmp_ppUnorderedAccessViews[i] = unwrap(ppUnorderedAccessViews[i]);
  m_pID3D11DeviceContext->OMSetRenderTargetsAndUnorderedAccessViews(
    NumRTVs, 
    tmp_ppRenderTargetViews, 
    unwrapped_pDepthStencilView, 
    UAVStartSlot, 
    NumUAVs, 
    tmp_ppUnorderedAccessViews, 
    pUAVInitialCounts
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMSetRenderTargetsAndUnorderedAccessViews", nullptr, {
    {"NumRTVs", {(void*)&orig_NumRTVs, (void*)&NumRTVs}},
    {"ppRenderTargetViews", {(void*)&orig_ppRenderTargetViews, (void*)&ppRenderTargetViews}},
    {"pDepthStencilView", {(void*)&orig_pDepthStencilView, (void*)&pDepthStencilView}},
    {"UAVStartSlot", {(void*)&orig_UAVStartSlot, (void*)&UAVStartSlot}},
    {"NumUAVs", {(void*)&orig_NumUAVs, (void*)&NumUAVs}},
    {"ppUnorderedAccessViews", {(void*)&orig_ppUnorderedAccessViews, (void*)&ppUnorderedAccessViews}},
    {"pUAVInitialCounts", {(void*)&orig_pUAVInitialCounts, (void*)&pUAVInitialCounts}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMSetBlendState(
  ID3D11BlendState * pBlendState, 
  const FLOAT * BlendFactor, 
  UINT SampleMask
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBlendState = pBlendState;
  auto orig_BlendFactor = BlendFactor;
  auto orig_SampleMask = SampleMask;
  auto unwrapped_pBlendState = unwrap(pBlendState);
  auto unwrapped_BlendFactor = unwrap(BlendFactor);
  m_pID3D11DeviceContext->OMSetBlendState(
    unwrapped_pBlendState, 
    unwrapped_BlendFactor, 
    SampleMask
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMSetBlendState", nullptr, {
    {"pBlendState", {(void*)&orig_pBlendState, (void*)&pBlendState}},
    {"BlendFactor", {(void*)&orig_BlendFactor, (void*)&BlendFactor}},
    {"SampleMask", {(void*)&orig_SampleMask, (void*)&SampleMask}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMSetDepthStencilState(
  ID3D11DepthStencilState * pDepthStencilState, 
  UINT StencilRef
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDepthStencilState = pDepthStencilState;
  auto orig_StencilRef = StencilRef;
  auto unwrapped_pDepthStencilState = unwrap(pDepthStencilState);
  m_pID3D11DeviceContext->OMSetDepthStencilState(
    unwrapped_pDepthStencilState, 
    StencilRef
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMSetDepthStencilState", nullptr, {
    {"pDepthStencilState", {(void*)&orig_pDepthStencilState, (void*)&pDepthStencilState}},
    {"StencilRef", {(void*)&orig_StencilRef, (void*)&StencilRef}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::SOSetTargets(
  UINT NumBuffers, 
  ID3D11Buffer *const * ppSOTargets, 
  const UINT * pOffsets
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppSOTargets = ppSOTargets;
  auto orig_pOffsets = pOffsets;
  ID3D11Buffer  *tmp_ppSOTargets[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppSOTargets[i] = unwrap(ppSOTargets[i]);
  m_pID3D11DeviceContext->SOSetTargets(
    NumBuffers, 
    tmp_ppSOTargets, 
    pOffsets
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "SOSetTargets", nullptr, {
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppSOTargets", {(void*)&orig_ppSOTargets, (void*)&ppSOTargets}},
    {"pOffsets", {(void*)&orig_pOffsets, (void*)&pOffsets}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DrawAuto() {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11DeviceContext->DrawAuto();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DrawAuto", nullptr, {
  });
}
void __stdcall WrappedID3D11DeviceContext4::DrawIndexedInstancedIndirect(
  ID3D11Buffer * pBufferForArgs, 
  UINT AlignedByteOffsetForArgs
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBufferForArgs = pBufferForArgs;
  auto orig_AlignedByteOffsetForArgs = AlignedByteOffsetForArgs;
  auto unwrapped_pBufferForArgs = unwrap(pBufferForArgs);
  m_pID3D11DeviceContext->DrawIndexedInstancedIndirect(
    unwrapped_pBufferForArgs, 
    AlignedByteOffsetForArgs
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DrawIndexedInstancedIndirect", nullptr, {
    {"pBufferForArgs", {(void*)&orig_pBufferForArgs, (void*)&pBufferForArgs}},
    {"AlignedByteOffsetForArgs", {(void*)&orig_AlignedByteOffsetForArgs, (void*)&AlignedByteOffsetForArgs}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DrawInstancedIndirect(
  ID3D11Buffer * pBufferForArgs, 
  UINT AlignedByteOffsetForArgs
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBufferForArgs = pBufferForArgs;
  auto orig_AlignedByteOffsetForArgs = AlignedByteOffsetForArgs;
  auto unwrapped_pBufferForArgs = unwrap(pBufferForArgs);
  m_pID3D11DeviceContext->DrawInstancedIndirect(
    unwrapped_pBufferForArgs, 
    AlignedByteOffsetForArgs
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DrawInstancedIndirect", nullptr, {
    {"pBufferForArgs", {(void*)&orig_pBufferForArgs, (void*)&pBufferForArgs}},
    {"AlignedByteOffsetForArgs", {(void*)&orig_AlignedByteOffsetForArgs, (void*)&AlignedByteOffsetForArgs}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::Dispatch(
  UINT ThreadGroupCountX, 
  UINT ThreadGroupCountY, 
  UINT ThreadGroupCountZ
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ThreadGroupCountX = ThreadGroupCountX;
  auto orig_ThreadGroupCountY = ThreadGroupCountY;
  auto orig_ThreadGroupCountZ = ThreadGroupCountZ;
  m_pID3D11DeviceContext->Dispatch(
    ThreadGroupCountX, 
    ThreadGroupCountY, 
    ThreadGroupCountZ
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "Dispatch", nullptr, {
    {"ThreadGroupCountX", {(void*)&orig_ThreadGroupCountX, (void*)&ThreadGroupCountX}},
    {"ThreadGroupCountY", {(void*)&orig_ThreadGroupCountY, (void*)&ThreadGroupCountY}},
    {"ThreadGroupCountZ", {(void*)&orig_ThreadGroupCountZ, (void*)&ThreadGroupCountZ}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DispatchIndirect(
  ID3D11Buffer * pBufferForArgs, 
  UINT AlignedByteOffsetForArgs
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBufferForArgs = pBufferForArgs;
  auto orig_AlignedByteOffsetForArgs = AlignedByteOffsetForArgs;
  auto unwrapped_pBufferForArgs = unwrap(pBufferForArgs);
  m_pID3D11DeviceContext->DispatchIndirect(
    unwrapped_pBufferForArgs, 
    AlignedByteOffsetForArgs
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DispatchIndirect", nullptr, {
    {"pBufferForArgs", {(void*)&orig_pBufferForArgs, (void*)&pBufferForArgs}},
    {"AlignedByteOffsetForArgs", {(void*)&orig_AlignedByteOffsetForArgs, (void*)&AlignedByteOffsetForArgs}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::RSSetState(
  ID3D11RasterizerState * pRasterizerState
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRasterizerState = pRasterizerState;
  auto unwrapped_pRasterizerState = unwrap(pRasterizerState);
  m_pID3D11DeviceContext->RSSetState(
    unwrapped_pRasterizerState
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "RSSetState", nullptr, {
    {"pRasterizerState", {(void*)&orig_pRasterizerState, (void*)&pRasterizerState}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::RSSetViewports(
  UINT NumViewports, 
  const D3D11_VIEWPORT * pViewports
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumViewports = NumViewports;
  auto orig_pViewports = pViewports;
  m_pID3D11DeviceContext->RSSetViewports(
    NumViewports, 
    pViewports
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "RSSetViewports", nullptr, {
    {"NumViewports", {(void*)&orig_NumViewports, (void*)&NumViewports}},
    {"pViewports", {(void*)&orig_pViewports, (void*)&pViewports}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::RSSetScissorRects(
  UINT NumRects, 
  const D3D11_RECT * pRects
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumRects = NumRects;
  auto orig_pRects = pRects;
  m_pID3D11DeviceContext->RSSetScissorRects(
    NumRects, 
    pRects
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "RSSetScissorRects", nullptr, {
    {"NumRects", {(void*)&orig_NumRects, (void*)&NumRects}},
    {"pRects", {(void*)&orig_pRects, (void*)&pRects}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CopySubresourceRegion(
  ID3D11Resource * pDstResource, 
  UINT DstSubresource, 
  UINT DstX, 
  UINT DstY, 
  UINT DstZ, 
  ID3D11Resource * pSrcResource, 
  UINT SrcSubresource, 
  const D3D11_BOX * pSrcBox
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_DstSubresource = DstSubresource;
  auto orig_DstX = DstX;
  auto orig_DstY = DstY;
  auto orig_DstZ = DstZ;
  auto orig_pSrcResource = pSrcResource;
  auto orig_SrcSubresource = SrcSubresource;
  auto orig_pSrcBox = pSrcBox;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pSrcResource = unwrap(pSrcResource);
  auto unwrapped_pSrcBox = unwrap(pSrcBox);
  m_pID3D11DeviceContext->CopySubresourceRegion(
    unwrapped_pDstResource, 
    DstSubresource, 
    DstX, 
    DstY, 
    DstZ, 
    unwrapped_pSrcResource, 
    SrcSubresource, 
    unwrapped_pSrcBox
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CopySubresourceRegion", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"DstSubresource", {(void*)&orig_DstSubresource, (void*)&DstSubresource}},
    {"DstX", {(void*)&orig_DstX, (void*)&DstX}},
    {"DstY", {(void*)&orig_DstY, (void*)&DstY}},
    {"DstZ", {(void*)&orig_DstZ, (void*)&DstZ}},
    {"pSrcResource", {(void*)&orig_pSrcResource, (void*)&pSrcResource}},
    {"SrcSubresource", {(void*)&orig_SrcSubresource, (void*)&SrcSubresource}},
    {"pSrcBox", {(void*)&orig_pSrcBox, (void*)&pSrcBox}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CopyResource(
  ID3D11Resource * pDstResource, 
  ID3D11Resource * pSrcResource
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_pSrcResource = pSrcResource;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pSrcResource = unwrap(pSrcResource);
  m_pID3D11DeviceContext->CopyResource(
    unwrapped_pDstResource, 
    unwrapped_pSrcResource
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CopyResource", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"pSrcResource", {(void*)&orig_pSrcResource, (void*)&pSrcResource}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::UpdateSubresource(
  ID3D11Resource * pDstResource, 
  UINT DstSubresource, 
  const D3D11_BOX * pDstBox, 
  const void * pSrcData, 
  UINT SrcRowPitch, 
  UINT SrcDepthPitch
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_DstSubresource = DstSubresource;
  auto orig_pDstBox = pDstBox;
  auto orig_pSrcData = pSrcData;
  auto orig_SrcRowPitch = SrcRowPitch;
  auto orig_SrcDepthPitch = SrcDepthPitch;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pDstBox = unwrap(pDstBox);
  auto unwrapped_pSrcData = unwrap(pSrcData);
  m_pID3D11DeviceContext->UpdateSubresource(
    unwrapped_pDstResource, 
    DstSubresource, 
    unwrapped_pDstBox, 
    unwrapped_pSrcData, 
    SrcRowPitch, 
    SrcDepthPitch
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "UpdateSubresource", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"DstSubresource", {(void*)&orig_DstSubresource, (void*)&DstSubresource}},
    {"pDstBox", {(void*)&orig_pDstBox, (void*)&pDstBox}},
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcRowPitch", {(void*)&orig_SrcRowPitch, (void*)&SrcRowPitch}},
    {"SrcDepthPitch", {(void*)&orig_SrcDepthPitch, (void*)&SrcDepthPitch}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CopyStructureCount(
  ID3D11Buffer * pDstBuffer, 
  UINT DstAlignedByteOffset, 
  ID3D11UnorderedAccessView * pSrcView
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstBuffer = pDstBuffer;
  auto orig_DstAlignedByteOffset = DstAlignedByteOffset;
  auto orig_pSrcView = pSrcView;
  auto unwrapped_pDstBuffer = unwrap(pDstBuffer);
  auto unwrapped_pSrcView = unwrap(pSrcView);
  m_pID3D11DeviceContext->CopyStructureCount(
    unwrapped_pDstBuffer, 
    DstAlignedByteOffset, 
    unwrapped_pSrcView
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CopyStructureCount", nullptr, {
    {"pDstBuffer", {(void*)&orig_pDstBuffer, (void*)&pDstBuffer}},
    {"DstAlignedByteOffset", {(void*)&orig_DstAlignedByteOffset, (void*)&DstAlignedByteOffset}},
    {"pSrcView", {(void*)&orig_pSrcView, (void*)&pSrcView}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ClearRenderTargetView(
  ID3D11RenderTargetView * pRenderTargetView, 
  const FLOAT * ColorRGBA
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRenderTargetView = pRenderTargetView;
  auto orig_ColorRGBA = ColorRGBA;
  auto unwrapped_pRenderTargetView = unwrap(pRenderTargetView);
  auto unwrapped_ColorRGBA = unwrap(ColorRGBA);
  m_pID3D11DeviceContext->ClearRenderTargetView(
    unwrapped_pRenderTargetView, 
    unwrapped_ColorRGBA
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ClearRenderTargetView", nullptr, {
    {"pRenderTargetView", {(void*)&orig_pRenderTargetView, (void*)&pRenderTargetView}},
    {"ColorRGBA", {(void*)&orig_ColorRGBA, (void*)&ColorRGBA}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ClearUnorderedAccessViewUint(
  ID3D11UnorderedAccessView * pUnorderedAccessView, 
  const UINT * Values
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pUnorderedAccessView = pUnorderedAccessView;
  auto orig_Values = Values;
  auto unwrapped_pUnorderedAccessView = unwrap(pUnorderedAccessView);
  auto unwrapped_Values = unwrap(Values);
  m_pID3D11DeviceContext->ClearUnorderedAccessViewUint(
    unwrapped_pUnorderedAccessView, 
    unwrapped_Values
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ClearUnorderedAccessViewUint", nullptr, {
    {"pUnorderedAccessView", {(void*)&orig_pUnorderedAccessView, (void*)&pUnorderedAccessView}},
    {"Values", {(void*)&orig_Values, (void*)&Values}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ClearUnorderedAccessViewFloat(
  ID3D11UnorderedAccessView * pUnorderedAccessView, 
  const FLOAT * Values
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pUnorderedAccessView = pUnorderedAccessView;
  auto orig_Values = Values;
  auto unwrapped_pUnorderedAccessView = unwrap(pUnorderedAccessView);
  auto unwrapped_Values = unwrap(Values);
  m_pID3D11DeviceContext->ClearUnorderedAccessViewFloat(
    unwrapped_pUnorderedAccessView, 
    unwrapped_Values
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ClearUnorderedAccessViewFloat", nullptr, {
    {"pUnorderedAccessView", {(void*)&orig_pUnorderedAccessView, (void*)&pUnorderedAccessView}},
    {"Values", {(void*)&orig_Values, (void*)&Values}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ClearDepthStencilView(
  ID3D11DepthStencilView * pDepthStencilView, 
  UINT ClearFlags, 
  FLOAT Depth, 
  UINT8 Stencil
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDepthStencilView = pDepthStencilView;
  auto orig_ClearFlags = ClearFlags;
  auto orig_Depth = Depth;
  auto orig_Stencil = Stencil;
  auto unwrapped_pDepthStencilView = unwrap(pDepthStencilView);
  m_pID3D11DeviceContext->ClearDepthStencilView(
    unwrapped_pDepthStencilView, 
    ClearFlags, 
    Depth, 
    Stencil
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ClearDepthStencilView", nullptr, {
    {"pDepthStencilView", {(void*)&orig_pDepthStencilView, (void*)&pDepthStencilView}},
    {"ClearFlags", {(void*)&orig_ClearFlags, (void*)&ClearFlags}},
    {"Depth", {(void*)&orig_Depth, (void*)&Depth}},
    {"Stencil", {(void*)&orig_Stencil, (void*)&Stencil}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GenerateMips(
  ID3D11ShaderResourceView * pShaderResourceView
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderResourceView = pShaderResourceView;
  auto unwrapped_pShaderResourceView = unwrap(pShaderResourceView);
  m_pID3D11DeviceContext->GenerateMips(
    unwrapped_pShaderResourceView
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GenerateMips", nullptr, {
    {"pShaderResourceView", {(void*)&orig_pShaderResourceView, (void*)&pShaderResourceView}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::SetResourceMinLOD(
  ID3D11Resource * pResource, 
  FLOAT MinLOD
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_MinLOD = MinLOD;
  auto unwrapped_pResource = unwrap(pResource);
  m_pID3D11DeviceContext->SetResourceMinLOD(
    unwrapped_pResource, 
    MinLOD
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "SetResourceMinLOD", nullptr, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"MinLOD", {(void*)&orig_MinLOD, (void*)&MinLOD}},
  });
}
FLOAT __stdcall WrappedID3D11DeviceContext4::GetResourceMinLOD(
  ID3D11Resource * pResource
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto unwrapped_pResource = unwrap(pResource);
  auto ret = m_pID3D11DeviceContext->GetResourceMinLOD(
    unwrapped_pResource
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GetResourceMinLOD", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::ResolveSubresource(
  ID3D11Resource * pDstResource, 
  UINT DstSubresource, 
  ID3D11Resource * pSrcResource, 
  UINT SrcSubresource, 
  DXGI_FORMAT Format
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_DstSubresource = DstSubresource;
  auto orig_pSrcResource = pSrcResource;
  auto orig_SrcSubresource = SrcSubresource;
  auto orig_Format = Format;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pSrcResource = unwrap(pSrcResource);
  m_pID3D11DeviceContext->ResolveSubresource(
    unwrapped_pDstResource, 
    DstSubresource, 
    unwrapped_pSrcResource, 
    SrcSubresource, 
    Format
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ResolveSubresource", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"DstSubresource", {(void*)&orig_DstSubresource, (void*)&DstSubresource}},
    {"pSrcResource", {(void*)&orig_pSrcResource, (void*)&pSrcResource}},
    {"SrcSubresource", {(void*)&orig_SrcSubresource, (void*)&SrcSubresource}},
    {"Format", {(void*)&orig_Format, (void*)&Format}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ExecuteCommandList(
  ID3D11CommandList * pCommandList, 
  BOOL RestoreContextState
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCommandList = pCommandList;
  auto orig_RestoreContextState = RestoreContextState;
  auto unwrapped_pCommandList = unwrap(pCommandList);
  m_pID3D11DeviceContext->ExecuteCommandList(
    unwrapped_pCommandList, 
    RestoreContextState
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ExecuteCommandList", nullptr, {
    {"pCommandList", {(void*)&orig_pCommandList, (void*)&pCommandList}},
    {"RestoreContextState", {(void*)&orig_RestoreContextState, (void*)&RestoreContextState}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSSetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView *const * ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  ID3D11ShaderResourceView  *tmp_ppShaderResourceViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppShaderResourceViews[i] = unwrap(ppShaderResourceViews[i]);
  m_pID3D11DeviceContext->HSSetShaderResources(
    StartSlot, 
    NumViews, 
    tmp_ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSSetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSSetShader(
  ID3D11HullShader * pHullShader, 
  ID3D11ClassInstance *const * ppClassInstances, 
  UINT NumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pHullShader = pHullShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_NumClassInstances = NumClassInstances;
  auto unwrapped_pHullShader = unwrap(pHullShader);
  ID3D11ClassInstance  *tmp_ppClassInstances[0x80];
  for (uint32_t i = 0; i < NumClassInstances; i++) tmp_ppClassInstances[i] = unwrap(ppClassInstances[i]);
  m_pID3D11DeviceContext->HSSetShader(
    unwrapped_pHullShader, 
    tmp_ppClassInstances, 
    NumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSSetShader", nullptr, {
    {"pHullShader", {(void*)&orig_pHullShader, (void*)&pHullShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"NumClassInstances", {(void*)&orig_NumClassInstances, (void*)&NumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSSetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState *const * ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  ID3D11SamplerState  *tmp_ppSamplers[0x80];
  for (uint32_t i = 0; i < NumSamplers; i++) tmp_ppSamplers[i] = unwrap(ppSamplers[i]);
  m_pID3D11DeviceContext->HSSetSamplers(
    StartSlot, 
    NumSamplers, 
    tmp_ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSSetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSSetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext->HSSetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSSetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSSetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView *const * ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  ID3D11ShaderResourceView  *tmp_ppShaderResourceViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppShaderResourceViews[i] = unwrap(ppShaderResourceViews[i]);
  m_pID3D11DeviceContext->DSSetShaderResources(
    StartSlot, 
    NumViews, 
    tmp_ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSSetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSSetShader(
  ID3D11DomainShader * pDomainShader, 
  ID3D11ClassInstance *const * ppClassInstances, 
  UINT NumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDomainShader = pDomainShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_NumClassInstances = NumClassInstances;
  auto unwrapped_pDomainShader = unwrap(pDomainShader);
  ID3D11ClassInstance  *tmp_ppClassInstances[0x80];
  for (uint32_t i = 0; i < NumClassInstances; i++) tmp_ppClassInstances[i] = unwrap(ppClassInstances[i]);
  m_pID3D11DeviceContext->DSSetShader(
    unwrapped_pDomainShader, 
    tmp_ppClassInstances, 
    NumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSSetShader", nullptr, {
    {"pDomainShader", {(void*)&orig_pDomainShader, (void*)&pDomainShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"NumClassInstances", {(void*)&orig_NumClassInstances, (void*)&NumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSSetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState *const * ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  ID3D11SamplerState  *tmp_ppSamplers[0x80];
  for (uint32_t i = 0; i < NumSamplers; i++) tmp_ppSamplers[i] = unwrap(ppSamplers[i]);
  m_pID3D11DeviceContext->DSSetSamplers(
    StartSlot, 
    NumSamplers, 
    tmp_ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSSetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSSetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext->DSSetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSSetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSSetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView *const * ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  ID3D11ShaderResourceView  *tmp_ppShaderResourceViews[0x80];
  for (uint32_t i = 0; i < NumViews; i++) tmp_ppShaderResourceViews[i] = unwrap(ppShaderResourceViews[i]);
  m_pID3D11DeviceContext->CSSetShaderResources(
    StartSlot, 
    NumViews, 
    tmp_ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSSetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSSetUnorderedAccessViews(
  UINT StartSlot, 
  UINT NumUAVs, 
  ID3D11UnorderedAccessView *const * ppUnorderedAccessViews, 
  const UINT * pUAVInitialCounts
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumUAVs = NumUAVs;
  auto orig_ppUnorderedAccessViews = ppUnorderedAccessViews;
  auto orig_pUAVInitialCounts = pUAVInitialCounts;
  ID3D11UnorderedAccessView  *tmp_ppUnorderedAccessViews[0x80];
  for (uint32_t i = 0; i < NumUAVs; i++) tmp_ppUnorderedAccessViews[i] = unwrap(ppUnorderedAccessViews[i]);
  m_pID3D11DeviceContext->CSSetUnorderedAccessViews(
    StartSlot, 
    NumUAVs, 
    tmp_ppUnorderedAccessViews, 
    pUAVInitialCounts
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSSetUnorderedAccessViews", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumUAVs", {(void*)&orig_NumUAVs, (void*)&NumUAVs}},
    {"ppUnorderedAccessViews", {(void*)&orig_ppUnorderedAccessViews, (void*)&ppUnorderedAccessViews}},
    {"pUAVInitialCounts", {(void*)&orig_pUAVInitialCounts, (void*)&pUAVInitialCounts}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSSetShader(
  ID3D11ComputeShader * pComputeShader, 
  ID3D11ClassInstance *const * ppClassInstances, 
  UINT NumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pComputeShader = pComputeShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_NumClassInstances = NumClassInstances;
  auto unwrapped_pComputeShader = unwrap(pComputeShader);
  ID3D11ClassInstance  *tmp_ppClassInstances[0x80];
  for (uint32_t i = 0; i < NumClassInstances; i++) tmp_ppClassInstances[i] = unwrap(ppClassInstances[i]);
  m_pID3D11DeviceContext->CSSetShader(
    unwrapped_pComputeShader, 
    tmp_ppClassInstances, 
    NumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSSetShader", nullptr, {
    {"pComputeShader", {(void*)&orig_pComputeShader, (void*)&pComputeShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"NumClassInstances", {(void*)&orig_NumClassInstances, (void*)&NumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSSetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState *const * ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  ID3D11SamplerState  *tmp_ppSamplers[0x80];
  for (uint32_t i = 0; i < NumSamplers; i++) tmp_ppSamplers[i] = unwrap(ppSamplers[i]);
  m_pID3D11DeviceContext->CSSetSamplers(
    StartSlot, 
    NumSamplers, 
    tmp_ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSSetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSSetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer *const * ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  ID3D11Buffer  *tmp_ppConstantBuffers[0x80];
  for (uint32_t i = 0; i < NumBuffers; i++) tmp_ppConstantBuffers[i] = unwrap(ppConstantBuffers[i]);
  m_pID3D11DeviceContext->CSSetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    tmp_ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSSetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSGetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  m_pID3D11DeviceContext->VSGetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSGetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSGetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView ** ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  m_pID3D11DeviceContext->PSGetShaderResources(
    StartSlot, 
    NumViews, 
    ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppShaderResourceViews && ppShaderResourceViews[i]) ppShaderResourceViews[i] = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(ppShaderResourceViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSGetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSGetShader(
  ID3D11PixelShader ** ppPixelShader, 
  ID3D11ClassInstance ** ppClassInstances, 
  UINT * pNumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppPixelShader = ppPixelShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_pNumClassInstances = pNumClassInstances;
  auto unwrapped_pNumClassInstances = unwrap(pNumClassInstances);
  m_pID3D11DeviceContext->PSGetShader(
    ppPixelShader, 
    ppClassInstances, 
    unwrapped_pNumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppPixelShader && *ppPixelShader ) *ppPixelShader = getWrapper<ID3D11PixelShader, WrappedID3D11PixelShader>(*ppPixelShader);
  if (pNumClassInstances)for (uint32_t i = 0; i < *pNumClassInstances; i++) if (true && ppClassInstances && ppClassInstances[i]) ppClassInstances[i] = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(ppClassInstances[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSGetShader", nullptr, {
    {"ppPixelShader", {(void*)&orig_ppPixelShader, (void*)&ppPixelShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"pNumClassInstances", {(void*)&orig_pNumClassInstances, (void*)&pNumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSGetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState ** ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  m_pID3D11DeviceContext->PSGetSamplers(
    StartSlot, 
    NumSamplers, 
    ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumSamplers; i++) if (true && ppSamplers && ppSamplers[i]) ppSamplers[i] = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(ppSamplers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSGetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSGetShader(
  ID3D11VertexShader ** ppVertexShader, 
  ID3D11ClassInstance ** ppClassInstances, 
  UINT * pNumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppVertexShader = ppVertexShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_pNumClassInstances = pNumClassInstances;
  auto unwrapped_pNumClassInstances = unwrap(pNumClassInstances);
  m_pID3D11DeviceContext->VSGetShader(
    ppVertexShader, 
    ppClassInstances, 
    unwrapped_pNumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppVertexShader && *ppVertexShader ) *ppVertexShader = getWrapper<ID3D11VertexShader, WrappedID3D11VertexShader>(*ppVertexShader);
  if (pNumClassInstances)for (uint32_t i = 0; i < *pNumClassInstances; i++) if (true && ppClassInstances && ppClassInstances[i]) ppClassInstances[i] = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(ppClassInstances[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSGetShader", nullptr, {
    {"ppVertexShader", {(void*)&orig_ppVertexShader, (void*)&ppVertexShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"pNumClassInstances", {(void*)&orig_pNumClassInstances, (void*)&pNumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::PSGetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  m_pID3D11DeviceContext->PSGetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "PSGetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IAGetInputLayout(
  ID3D11InputLayout ** ppInputLayout
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppInputLayout = ppInputLayout;
  m_pID3D11DeviceContext->IAGetInputLayout(
    ppInputLayout
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppInputLayout && *ppInputLayout ) *ppInputLayout = getWrapper<ID3D11InputLayout, WrappedID3D11InputLayout>(*ppInputLayout);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IAGetInputLayout", nullptr, {
    {"ppInputLayout", {(void*)&orig_ppInputLayout, (void*)&ppInputLayout}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IAGetVertexBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppVertexBuffers, 
  UINT * pStrides, 
  UINT * pOffsets
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppVertexBuffers = ppVertexBuffers;
  auto orig_pStrides = pStrides;
  auto orig_pOffsets = pOffsets;
  m_pID3D11DeviceContext->IAGetVertexBuffers(
    StartSlot, 
    NumBuffers, 
    ppVertexBuffers, 
    pStrides, 
    pOffsets
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppVertexBuffers && ppVertexBuffers[i]) ppVertexBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppVertexBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IAGetVertexBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppVertexBuffers", {(void*)&orig_ppVertexBuffers, (void*)&ppVertexBuffers}},
    {"pStrides", {(void*)&orig_pStrides, (void*)&pStrides}},
    {"pOffsets", {(void*)&orig_pOffsets, (void*)&pOffsets}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IAGetIndexBuffer(
  ID3D11Buffer ** pIndexBuffer, 
  DXGI_FORMAT * Format, 
  UINT * Offset
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pIndexBuffer = pIndexBuffer;
  auto orig_Format = Format;
  auto orig_Offset = Offset;
  m_pID3D11DeviceContext->IAGetIndexBuffer(
    pIndexBuffer, 
    Format, 
    Offset
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && pIndexBuffer && *pIndexBuffer ) *pIndexBuffer = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(*pIndexBuffer);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IAGetIndexBuffer", nullptr, {
    {"pIndexBuffer", {(void*)&orig_pIndexBuffer, (void*)&pIndexBuffer}},
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"Offset", {(void*)&orig_Offset, (void*)&Offset}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSGetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  m_pID3D11DeviceContext->GSGetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSGetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSGetShader(
  ID3D11GeometryShader ** ppGeometryShader, 
  ID3D11ClassInstance ** ppClassInstances, 
  UINT * pNumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppGeometryShader = ppGeometryShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_pNumClassInstances = pNumClassInstances;
  auto unwrapped_pNumClassInstances = unwrap(pNumClassInstances);
  m_pID3D11DeviceContext->GSGetShader(
    ppGeometryShader, 
    ppClassInstances, 
    unwrapped_pNumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppGeometryShader && *ppGeometryShader ) *ppGeometryShader = getWrapper<ID3D11GeometryShader, WrappedID3D11GeometryShader>(*ppGeometryShader);
  if (pNumClassInstances)for (uint32_t i = 0; i < *pNumClassInstances; i++) if (true && ppClassInstances && ppClassInstances[i]) ppClassInstances[i] = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(ppClassInstances[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSGetShader", nullptr, {
    {"ppGeometryShader", {(void*)&orig_ppGeometryShader, (void*)&ppGeometryShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"pNumClassInstances", {(void*)&orig_pNumClassInstances, (void*)&pNumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::IAGetPrimitiveTopology(
  D3D11_PRIMITIVE_TOPOLOGY * pTopology
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTopology = pTopology;
  m_pID3D11DeviceContext->IAGetPrimitiveTopology(
    pTopology
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "IAGetPrimitiveTopology", nullptr, {
    {"pTopology", {(void*)&orig_pTopology, (void*)&pTopology}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSGetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView ** ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  m_pID3D11DeviceContext->VSGetShaderResources(
    StartSlot, 
    NumViews, 
    ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppShaderResourceViews && ppShaderResourceViews[i]) ppShaderResourceViews[i] = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(ppShaderResourceViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSGetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::VSGetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState ** ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  m_pID3D11DeviceContext->VSGetSamplers(
    StartSlot, 
    NumSamplers, 
    ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumSamplers; i++) if (true && ppSamplers && ppSamplers[i]) ppSamplers[i] = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(ppSamplers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "VSGetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GetPredication(
  ID3D11Predicate ** ppPredicate, 
  BOOL * pPredicateValue
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppPredicate = ppPredicate;
  auto orig_pPredicateValue = pPredicateValue;
  m_pID3D11DeviceContext->GetPredication(
    ppPredicate, 
    pPredicateValue
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppPredicate && *ppPredicate ) *ppPredicate = getWrapper<ID3D11Predicate, WrappedID3D11Predicate>(*ppPredicate);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GetPredication", nullptr, {
    {"ppPredicate", {(void*)&orig_ppPredicate, (void*)&ppPredicate}},
    {"pPredicateValue", {(void*)&orig_pPredicateValue, (void*)&pPredicateValue}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSGetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView ** ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  m_pID3D11DeviceContext->GSGetShaderResources(
    StartSlot, 
    NumViews, 
    ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppShaderResourceViews && ppShaderResourceViews[i]) ppShaderResourceViews[i] = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(ppShaderResourceViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSGetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::GSGetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState ** ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  m_pID3D11DeviceContext->GSGetSamplers(
    StartSlot, 
    NumSamplers, 
    ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumSamplers; i++) if (true && ppSamplers && ppSamplers[i]) ppSamplers[i] = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(ppSamplers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GSGetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMGetRenderTargets(
  UINT NumViews, 
  ID3D11RenderTargetView ** ppRenderTargetViews, 
  ID3D11DepthStencilView ** ppDepthStencilView
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumViews = NumViews;
  auto orig_ppRenderTargetViews = ppRenderTargetViews;
  auto orig_ppDepthStencilView = ppDepthStencilView;
  m_pID3D11DeviceContext->OMGetRenderTargets(
    NumViews, 
    ppRenderTargetViews, 
    ppDepthStencilView
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppRenderTargetViews && ppRenderTargetViews[i]) ppRenderTargetViews[i] = getWrapper<ID3D11RenderTargetView, WrappedID3D11RenderTargetView1>(ppRenderTargetViews[i]);
  if (true && ppDepthStencilView && *ppDepthStencilView ) *ppDepthStencilView = getWrapper<ID3D11DepthStencilView, WrappedID3D11DepthStencilView>(*ppDepthStencilView);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMGetRenderTargets", nullptr, {
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppRenderTargetViews", {(void*)&orig_ppRenderTargetViews, (void*)&ppRenderTargetViews}},
    {"ppDepthStencilView", {(void*)&orig_ppDepthStencilView, (void*)&ppDepthStencilView}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMGetRenderTargetsAndUnorderedAccessViews(
  UINT NumRTVs, 
  ID3D11RenderTargetView ** ppRenderTargetViews, 
  ID3D11DepthStencilView ** ppDepthStencilView, 
  UINT UAVStartSlot, 
  UINT NumUAVs, 
  ID3D11UnorderedAccessView ** ppUnorderedAccessViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumRTVs = NumRTVs;
  auto orig_ppRenderTargetViews = ppRenderTargetViews;
  auto orig_ppDepthStencilView = ppDepthStencilView;
  auto orig_UAVStartSlot = UAVStartSlot;
  auto orig_NumUAVs = NumUAVs;
  auto orig_ppUnorderedAccessViews = ppUnorderedAccessViews;
  m_pID3D11DeviceContext->OMGetRenderTargetsAndUnorderedAccessViews(
    NumRTVs, 
    ppRenderTargetViews, 
    ppDepthStencilView, 
    UAVStartSlot, 
    NumUAVs, 
    ppUnorderedAccessViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumRTVs; i++) if (true && ppRenderTargetViews && ppRenderTargetViews[i]) ppRenderTargetViews[i] = getWrapper<ID3D11RenderTargetView, WrappedID3D11RenderTargetView1>(ppRenderTargetViews[i]);
  if (true && ppDepthStencilView && *ppDepthStencilView ) *ppDepthStencilView = getWrapper<ID3D11DepthStencilView, WrappedID3D11DepthStencilView>(*ppDepthStencilView);
  for (uint32_t i = 0; i < NumUAVs; i++) if (true && ppUnorderedAccessViews && ppUnorderedAccessViews[i]) ppUnorderedAccessViews[i] = getWrapper<ID3D11UnorderedAccessView, WrappedID3D11UnorderedAccessView1>(ppUnorderedAccessViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMGetRenderTargetsAndUnorderedAccessViews", nullptr, {
    {"NumRTVs", {(void*)&orig_NumRTVs, (void*)&NumRTVs}},
    {"ppRenderTargetViews", {(void*)&orig_ppRenderTargetViews, (void*)&ppRenderTargetViews}},
    {"ppDepthStencilView", {(void*)&orig_ppDepthStencilView, (void*)&ppDepthStencilView}},
    {"UAVStartSlot", {(void*)&orig_UAVStartSlot, (void*)&UAVStartSlot}},
    {"NumUAVs", {(void*)&orig_NumUAVs, (void*)&NumUAVs}},
    {"ppUnorderedAccessViews", {(void*)&orig_ppUnorderedAccessViews, (void*)&ppUnorderedAccessViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMGetBlendState(
  ID3D11BlendState ** ppBlendState, 
  FLOAT * BlendFactor, 
  UINT * pSampleMask
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppBlendState = ppBlendState;
  auto orig_BlendFactor = BlendFactor;
  auto orig_pSampleMask = pSampleMask;
  m_pID3D11DeviceContext->OMGetBlendState(
    ppBlendState, 
    BlendFactor, 
    pSampleMask
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppBlendState && *ppBlendState ) *ppBlendState = getWrapper<ID3D11BlendState, WrappedID3D11BlendState1>(*ppBlendState);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMGetBlendState", nullptr, {
    {"ppBlendState", {(void*)&orig_ppBlendState, (void*)&ppBlendState}},
    {"BlendFactor", {(void*)&orig_BlendFactor, (void*)&BlendFactor}},
    {"pSampleMask", {(void*)&orig_pSampleMask, (void*)&pSampleMask}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::OMGetDepthStencilState(
  ID3D11DepthStencilState ** ppDepthStencilState, 
  UINT * pStencilRef
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDepthStencilState = ppDepthStencilState;
  auto orig_pStencilRef = pStencilRef;
  m_pID3D11DeviceContext->OMGetDepthStencilState(
    ppDepthStencilState, 
    pStencilRef
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppDepthStencilState && *ppDepthStencilState ) *ppDepthStencilState = getWrapper<ID3D11DepthStencilState, WrappedID3D11DepthStencilState>(*ppDepthStencilState);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "OMGetDepthStencilState", nullptr, {
    {"ppDepthStencilState", {(void*)&orig_ppDepthStencilState, (void*)&ppDepthStencilState}},
    {"pStencilRef", {(void*)&orig_pStencilRef, (void*)&pStencilRef}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::SOGetTargets(
  UINT NumBuffers, 
  ID3D11Buffer ** ppSOTargets
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppSOTargets = ppSOTargets;
  m_pID3D11DeviceContext->SOGetTargets(
    NumBuffers, 
    ppSOTargets
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppSOTargets && ppSOTargets[i]) ppSOTargets[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppSOTargets[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "SOGetTargets", nullptr, {
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppSOTargets", {(void*)&orig_ppSOTargets, (void*)&ppSOTargets}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::RSGetState(
  ID3D11RasterizerState ** ppRasterizerState
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppRasterizerState = ppRasterizerState;
  m_pID3D11DeviceContext->RSGetState(
    ppRasterizerState
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppRasterizerState && *ppRasterizerState ) *ppRasterizerState = getWrapper<ID3D11RasterizerState, WrappedID3D11RasterizerState2>(*ppRasterizerState);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "RSGetState", nullptr, {
    {"ppRasterizerState", {(void*)&orig_ppRasterizerState, (void*)&ppRasterizerState}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::RSGetViewports(
  UINT * pNumViewports, 
  D3D11_VIEWPORT * pViewports
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pNumViewports = pNumViewports;
  auto orig_pViewports = pViewports;
  auto unwrapped_pNumViewports = unwrap(pNumViewports);
  m_pID3D11DeviceContext->RSGetViewports(
    unwrapped_pNumViewports, 
    pViewports
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "RSGetViewports", nullptr, {
    {"pNumViewports", {(void*)&orig_pNumViewports, (void*)&pNumViewports}},
    {"pViewports", {(void*)&orig_pViewports, (void*)&pViewports}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::RSGetScissorRects(
  UINT * pNumRects, 
  D3D11_RECT * pRects
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pNumRects = pNumRects;
  auto orig_pRects = pRects;
  auto unwrapped_pNumRects = unwrap(pNumRects);
  m_pID3D11DeviceContext->RSGetScissorRects(
    unwrapped_pNumRects, 
    pRects
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "RSGetScissorRects", nullptr, {
    {"pNumRects", {(void*)&orig_pNumRects, (void*)&pNumRects}},
    {"pRects", {(void*)&orig_pRects, (void*)&pRects}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSGetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView ** ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  m_pID3D11DeviceContext->HSGetShaderResources(
    StartSlot, 
    NumViews, 
    ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppShaderResourceViews && ppShaderResourceViews[i]) ppShaderResourceViews[i] = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(ppShaderResourceViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSGetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSGetShader(
  ID3D11HullShader ** ppHullShader, 
  ID3D11ClassInstance ** ppClassInstances, 
  UINT * pNumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppHullShader = ppHullShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_pNumClassInstances = pNumClassInstances;
  auto unwrapped_pNumClassInstances = unwrap(pNumClassInstances);
  m_pID3D11DeviceContext->HSGetShader(
    ppHullShader, 
    ppClassInstances, 
    unwrapped_pNumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppHullShader && *ppHullShader ) *ppHullShader = getWrapper<ID3D11HullShader, WrappedID3D11HullShader>(*ppHullShader);
  if (pNumClassInstances)for (uint32_t i = 0; i < *pNumClassInstances; i++) if (true && ppClassInstances && ppClassInstances[i]) ppClassInstances[i] = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(ppClassInstances[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSGetShader", nullptr, {
    {"ppHullShader", {(void*)&orig_ppHullShader, (void*)&ppHullShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"pNumClassInstances", {(void*)&orig_pNumClassInstances, (void*)&pNumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSGetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState ** ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  m_pID3D11DeviceContext->HSGetSamplers(
    StartSlot, 
    NumSamplers, 
    ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumSamplers; i++) if (true && ppSamplers && ppSamplers[i]) ppSamplers[i] = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(ppSamplers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSGetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::HSGetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  m_pID3D11DeviceContext->HSGetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "HSGetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSGetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView ** ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  m_pID3D11DeviceContext->DSGetShaderResources(
    StartSlot, 
    NumViews, 
    ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppShaderResourceViews && ppShaderResourceViews[i]) ppShaderResourceViews[i] = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(ppShaderResourceViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSGetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSGetShader(
  ID3D11DomainShader ** ppDomainShader, 
  ID3D11ClassInstance ** ppClassInstances, 
  UINT * pNumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDomainShader = ppDomainShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_pNumClassInstances = pNumClassInstances;
  auto unwrapped_pNumClassInstances = unwrap(pNumClassInstances);
  m_pID3D11DeviceContext->DSGetShader(
    ppDomainShader, 
    ppClassInstances, 
    unwrapped_pNumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppDomainShader && *ppDomainShader ) *ppDomainShader = getWrapper<ID3D11DomainShader, WrappedID3D11DomainShader>(*ppDomainShader);
  if (pNumClassInstances)for (uint32_t i = 0; i < *pNumClassInstances; i++) if (true && ppClassInstances && ppClassInstances[i]) ppClassInstances[i] = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(ppClassInstances[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSGetShader", nullptr, {
    {"ppDomainShader", {(void*)&orig_ppDomainShader, (void*)&ppDomainShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"pNumClassInstances", {(void*)&orig_pNumClassInstances, (void*)&pNumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSGetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState ** ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  m_pID3D11DeviceContext->DSGetSamplers(
    StartSlot, 
    NumSamplers, 
    ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumSamplers; i++) if (true && ppSamplers && ppSamplers[i]) ppSamplers[i] = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(ppSamplers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSGetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::DSGetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  m_pID3D11DeviceContext->DSGetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "DSGetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSGetShaderResources(
  UINT StartSlot, 
  UINT NumViews, 
  ID3D11ShaderResourceView ** ppShaderResourceViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumViews = NumViews;
  auto orig_ppShaderResourceViews = ppShaderResourceViews;
  m_pID3D11DeviceContext->CSGetShaderResources(
    StartSlot, 
    NumViews, 
    ppShaderResourceViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumViews; i++) if (true && ppShaderResourceViews && ppShaderResourceViews[i]) ppShaderResourceViews[i] = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(ppShaderResourceViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSGetShaderResources", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumViews", {(void*)&orig_NumViews, (void*)&NumViews}},
    {"ppShaderResourceViews", {(void*)&orig_ppShaderResourceViews, (void*)&ppShaderResourceViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSGetUnorderedAccessViews(
  UINT StartSlot, 
  UINT NumUAVs, 
  ID3D11UnorderedAccessView ** ppUnorderedAccessViews
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumUAVs = NumUAVs;
  auto orig_ppUnorderedAccessViews = ppUnorderedAccessViews;
  m_pID3D11DeviceContext->CSGetUnorderedAccessViews(
    StartSlot, 
    NumUAVs, 
    ppUnorderedAccessViews
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumUAVs; i++) if (true && ppUnorderedAccessViews && ppUnorderedAccessViews[i]) ppUnorderedAccessViews[i] = getWrapper<ID3D11UnorderedAccessView, WrappedID3D11UnorderedAccessView1>(ppUnorderedAccessViews[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSGetUnorderedAccessViews", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumUAVs", {(void*)&orig_NumUAVs, (void*)&NumUAVs}},
    {"ppUnorderedAccessViews", {(void*)&orig_ppUnorderedAccessViews, (void*)&ppUnorderedAccessViews}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSGetShader(
  ID3D11ComputeShader ** ppComputeShader, 
  ID3D11ClassInstance ** ppClassInstances, 
  UINT * pNumClassInstances
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppComputeShader = ppComputeShader;
  auto orig_ppClassInstances = ppClassInstances;
  auto orig_pNumClassInstances = pNumClassInstances;
  auto unwrapped_pNumClassInstances = unwrap(pNumClassInstances);
  m_pID3D11DeviceContext->CSGetShader(
    ppComputeShader, 
    ppClassInstances, 
    unwrapped_pNumClassInstances
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppComputeShader && *ppComputeShader ) *ppComputeShader = getWrapper<ID3D11ComputeShader, WrappedID3D11ComputeShader>(*ppComputeShader);
  if (pNumClassInstances)for (uint32_t i = 0; i < *pNumClassInstances; i++) if (true && ppClassInstances && ppClassInstances[i]) ppClassInstances[i] = getWrapper<ID3D11ClassInstance, WrappedID3D11ClassInstance>(ppClassInstances[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSGetShader", nullptr, {
    {"ppComputeShader", {(void*)&orig_ppComputeShader, (void*)&ppComputeShader}},
    {"ppClassInstances", {(void*)&orig_ppClassInstances, (void*)&ppClassInstances}},
    {"pNumClassInstances", {(void*)&orig_pNumClassInstances, (void*)&pNumClassInstances}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSGetSamplers(
  UINT StartSlot, 
  UINT NumSamplers, 
  ID3D11SamplerState ** ppSamplers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumSamplers = NumSamplers;
  auto orig_ppSamplers = ppSamplers;
  m_pID3D11DeviceContext->CSGetSamplers(
    StartSlot, 
    NumSamplers, 
    ppSamplers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumSamplers; i++) if (true && ppSamplers && ppSamplers[i]) ppSamplers[i] = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(ppSamplers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSGetSamplers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumSamplers", {(void*)&orig_NumSamplers, (void*)&NumSamplers}},
    {"ppSamplers", {(void*)&orig_ppSamplers, (void*)&ppSamplers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::CSGetConstantBuffers(
  UINT StartSlot, 
  UINT NumBuffers, 
  ID3D11Buffer ** ppConstantBuffers
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_StartSlot = StartSlot;
  auto orig_NumBuffers = NumBuffers;
  auto orig_ppConstantBuffers = ppConstantBuffers;
  m_pID3D11DeviceContext->CSGetConstantBuffers(
    StartSlot, 
    NumBuffers, 
    ppConstantBuffers
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  for (uint32_t i = 0; i < NumBuffers; i++) if (true && ppConstantBuffers && ppConstantBuffers[i]) ppConstantBuffers[i] = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(ppConstantBuffers[i]);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "CSGetConstantBuffers", nullptr, {
    {"StartSlot", {(void*)&orig_StartSlot, (void*)&StartSlot}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"ppConstantBuffers", {(void*)&orig_ppConstantBuffers, (void*)&ppConstantBuffers}},
  });
}
void __stdcall WrappedID3D11DeviceContext4::ClearState() {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11DeviceContext->ClearState();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "ClearState", nullptr, {
  });
}
void __stdcall WrappedID3D11DeviceContext4::Flush() {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11DeviceContext->Flush();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "Flush", nullptr, {
  });
}
D3D11_DEVICE_CONTEXT_TYPE __stdcall WrappedID3D11DeviceContext4::GetType() {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11DeviceContext->GetType();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GetType", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11DeviceContext4::GetContextFlags() {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11DeviceContext->GetContextFlags();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "GetContextFlags", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::FinishCommandList(
  BOOL RestoreDeferredContextState, 
  ID3D11CommandList ** ppCommandList
) {
  assert(m_pID3D11DeviceContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_RestoreDeferredContextState = RestoreDeferredContextState;
  auto orig_ppCommandList = ppCommandList;
  auto ret = m_pID3D11DeviceContext->FinishCommandList(
    RestoreDeferredContextState, 
    ppCommandList
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCommandList && *ppCommandList ) *ppCommandList = getWrapper<ID3D11CommandList, WrappedID3D11CommandList>(*ppCommandList);
  dumpMethodEvent((void*)this, "ID3D11DeviceContext", "FinishCommandList", &ret, {
    {"RestoreDeferredContextState", {(void*)&orig_RestoreDeferredContextState, (void*)&RestoreDeferredContextState}},
    {"ppCommandList", {(void*)&orig_ppCommandList, (void*)&ppCommandList}},
  });
  return ret;
}
void __stdcall WrappedID3D11DeviceContext4::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11DeviceContext4::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11DeviceContext4::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11DeviceContext4)) {
      *ppvObject = (ID3D11DeviceContext4*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceContext3)) {
      *ppvObject = (ID3D11DeviceContext3*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceContext2)) {
      *ppvObject = (ID3D11DeviceContext2*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceContext1)) {
      *ppvObject = (ID3D11DeviceContext1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceContext)) {
      *ppvObject = (ID3D11DeviceContext*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DeviceContext4::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11DeviceContext4::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::RegisterHardwareContentProtectionTeardownStatusEvent(
  HANDLE hEvent, 
  DWORD * pdwCookie
) {
  assert(m_pIDXGIAdapter3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hEvent = hEvent;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pIDXGIAdapter3->RegisterHardwareContentProtectionTeardownStatusEvent(
    hEvent, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter3", "RegisterHardwareContentProtectionTeardownStatusEvent", &ret, {
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
void __stdcall WrappedIDXGIAdapter3::UnregisterHardwareContentProtectionTeardownStatus(
  DWORD dwCookie
) {
  assert(m_pIDXGIAdapter3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_dwCookie = dwCookie;
  m_pIDXGIAdapter3->UnregisterHardwareContentProtectionTeardownStatus(
    dwCookie
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter3", "UnregisterHardwareContentProtectionTeardownStatus", nullptr, {
    {"dwCookie", {(void*)&orig_dwCookie, (void*)&dwCookie}},
  });
}
HRESULT __stdcall WrappedIDXGIAdapter3::QueryVideoMemoryInfo(
  UINT NodeIndex, 
  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup, 
  DXGI_QUERY_VIDEO_MEMORY_INFO * pVideoMemoryInfo
) {
  assert(m_pIDXGIAdapter3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NodeIndex = NodeIndex;
  auto orig_MemorySegmentGroup = MemorySegmentGroup;
  auto orig_pVideoMemoryInfo = pVideoMemoryInfo;
  auto ret = m_pIDXGIAdapter3->QueryVideoMemoryInfo(
    NodeIndex, 
    MemorySegmentGroup, 
    pVideoMemoryInfo
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter3", "QueryVideoMemoryInfo", &ret, {
    {"NodeIndex", {(void*)&orig_NodeIndex, (void*)&NodeIndex}},
    {"MemorySegmentGroup", {(void*)&orig_MemorySegmentGroup, (void*)&MemorySegmentGroup}},
    {"pVideoMemoryInfo", {(void*)&orig_pVideoMemoryInfo, (void*)&pVideoMemoryInfo}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::SetVideoMemoryReservation(
  UINT NodeIndex, 
  DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup, 
  UINT64 Reservation
) {
  assert(m_pIDXGIAdapter3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NodeIndex = NodeIndex;
  auto orig_MemorySegmentGroup = MemorySegmentGroup;
  auto orig_Reservation = Reservation;
  auto ret = m_pIDXGIAdapter3->SetVideoMemoryReservation(
    NodeIndex, 
    MemorySegmentGroup, 
    Reservation
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter3", "SetVideoMemoryReservation", &ret, {
    {"NodeIndex", {(void*)&orig_NodeIndex, (void*)&NodeIndex}},
    {"MemorySegmentGroup", {(void*)&orig_MemorySegmentGroup, (void*)&MemorySegmentGroup}},
    {"Reservation", {(void*)&orig_Reservation, (void*)&Reservation}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::RegisterVideoMemoryBudgetChangeNotificationEvent(
  HANDLE hEvent, 
  DWORD * pdwCookie
) {
  assert(m_pIDXGIAdapter3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hEvent = hEvent;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pIDXGIAdapter3->RegisterVideoMemoryBudgetChangeNotificationEvent(
    hEvent, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter3", "RegisterVideoMemoryBudgetChangeNotificationEvent", &ret, {
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
void __stdcall WrappedIDXGIAdapter3::UnregisterVideoMemoryBudgetChangeNotification(
  DWORD dwCookie
) {
  assert(m_pIDXGIAdapter3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_dwCookie = dwCookie;
  m_pIDXGIAdapter3->UnregisterVideoMemoryBudgetChangeNotification(
    dwCookie
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter3", "UnregisterVideoMemoryBudgetChangeNotification", nullptr, {
    {"dwCookie", {(void*)&orig_dwCookie, (void*)&dwCookie}},
  });
}
HRESULT __stdcall WrappedIDXGIAdapter3::GetDesc2(
  DXGI_ADAPTER_DESC2 * pDesc
) {
  assert(m_pIDXGIAdapter2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGIAdapter2->GetDesc2(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter2", "GetDesc2", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::GetDesc1(
  DXGI_ADAPTER_DESC1 * pDesc
) {
  assert(m_pIDXGIAdapter1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGIAdapter1->GetDesc1(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter1", "GetDesc1", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::EnumOutputs(
  UINT Output, 
  IDXGIOutput ** ppOutput
) {
  assert(m_pIDXGIAdapter);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Output = Output;
  auto orig_ppOutput = ppOutput;
  auto ret = m_pIDXGIAdapter->EnumOutputs(
    Output, 
    ppOutput
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppOutput && *ppOutput ) *ppOutput = getWrapper<IDXGIOutput, WrappedIDXGIOutput5>(*ppOutput);
  dumpMethodEvent((void*)this, "IDXGIAdapter", "EnumOutputs", &ret, {
    {"Output", {(void*)&orig_Output, (void*)&Output}},
    {"ppOutput", {(void*)&orig_ppOutput, (void*)&ppOutput}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::GetDesc(
  DXGI_ADAPTER_DESC * pDesc
) {
  assert(m_pIDXGIAdapter);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGIAdapter->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::CheckInterfaceSupport(
  const GUID & InterfaceName, 
  LARGE_INTEGER * pUMDVersion
) {
  assert(m_pIDXGIAdapter);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_InterfaceName = InterfaceName;
  auto orig_pUMDVersion = pUMDVersion;
  auto ret = m_pIDXGIAdapter->CheckInterfaceSupport(
    InterfaceName, 
    pUMDVersion
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIAdapter", "CheckInterfaceSupport", &ret, {
    {"InterfaceName", {(void*)&orig_InterfaceName, (void*)&InterfaceName}},
    {"pUMDVersion", {(void*)&orig_pUMDVersion, (void*)&pUMDVersion}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIAdapter3::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIAdapter3)) {
      *ppvObject = (IDXGIAdapter3*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIAdapter2)) {
      *ppvObject = (IDXGIAdapter2*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIAdapter1)) {
      *ppvObject = (IDXGIAdapter1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIAdapter)) {
      *ppvObject = (IDXGIAdapter*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIAdapter3::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIAdapter3::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::DuplicateOutput1(
  struct IUnknown * pDevice, 
  UINT Flags, 
  UINT SupportedFormatsCount, 
  const DXGI_FORMAT * pSupportedFormats, 
  IDXGIOutputDuplication ** ppOutputDuplication
) {
  assert(m_pIDXGIOutput5);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_Flags = Flags;
  auto orig_SupportedFormatsCount = SupportedFormatsCount;
  auto orig_pSupportedFormats = pSupportedFormats;
  auto orig_ppOutputDuplication = ppOutputDuplication;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto ret = m_pIDXGIOutput5->DuplicateOutput1(
    unwrapped_pDevice, 
    Flags, 
    SupportedFormatsCount, 
    pSupportedFormats, 
    ppOutputDuplication
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppOutputDuplication && *ppOutputDuplication ) *ppOutputDuplication = getWrapper<IDXGIOutputDuplication, WrappedIDXGIOutputDuplication>(*ppOutputDuplication);
  dumpMethodEvent((void*)this, "IDXGIOutput5", "DuplicateOutput1", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"SupportedFormatsCount", {(void*)&orig_SupportedFormatsCount, (void*)&SupportedFormatsCount}},
    {"pSupportedFormats", {(void*)&orig_pSupportedFormats, (void*)&pSupportedFormats}},
    {"ppOutputDuplication", {(void*)&orig_ppOutputDuplication, (void*)&ppOutputDuplication}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::CheckOverlayColorSpaceSupport(
  DXGI_FORMAT Format, 
  DXGI_COLOR_SPACE_TYPE ColorSpace, 
  struct IUnknown * pConcernedDevice, 
  UINT * pFlags
) {
  assert(m_pIDXGIOutput4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Format = Format;
  auto orig_ColorSpace = ColorSpace;
  auto orig_pConcernedDevice = pConcernedDevice;
  auto orig_pFlags = pFlags;
  auto unwrapped_pConcernedDevice = unwrap(pConcernedDevice);
  auto ret = m_pIDXGIOutput4->CheckOverlayColorSpaceSupport(
    Format, 
    ColorSpace, 
    unwrapped_pConcernedDevice, 
    pFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput4", "CheckOverlayColorSpaceSupport", &ret, {
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"ColorSpace", {(void*)&orig_ColorSpace, (void*)&ColorSpace}},
    {"pConcernedDevice", {(void*)&orig_pConcernedDevice, (void*)&pConcernedDevice}},
    {"pFlags", {(void*)&orig_pFlags, (void*)&pFlags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::CheckOverlaySupport(
  DXGI_FORMAT EnumFormat, 
  struct IUnknown * pConcernedDevice, 
  UINT * pFlags
) {
  assert(m_pIDXGIOutput3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EnumFormat = EnumFormat;
  auto orig_pConcernedDevice = pConcernedDevice;
  auto orig_pFlags = pFlags;
  auto unwrapped_pConcernedDevice = unwrap(pConcernedDevice);
  auto ret = m_pIDXGIOutput3->CheckOverlaySupport(
    EnumFormat, 
    unwrapped_pConcernedDevice, 
    pFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput3", "CheckOverlaySupport", &ret, {
    {"EnumFormat", {(void*)&orig_EnumFormat, (void*)&EnumFormat}},
    {"pConcernedDevice", {(void*)&orig_pConcernedDevice, (void*)&pConcernedDevice}},
    {"pFlags", {(void*)&orig_pFlags, (void*)&pFlags}},
  });
  return ret;
}
BOOL __stdcall WrappedIDXGIOutput5::SupportsOverlays() {
  assert(m_pIDXGIOutput2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIOutput2->SupportsOverlays();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput2", "SupportsOverlays", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetDisplayModeList1(
  DXGI_FORMAT EnumFormat, 
  UINT Flags, 
  UINT * pNumModes, 
  DXGI_MODE_DESC1 * pDesc
) {
  assert(m_pIDXGIOutput1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EnumFormat = EnumFormat;
  auto orig_Flags = Flags;
  auto orig_pNumModes = pNumModes;
  auto orig_pDesc = pDesc;
  auto unwrapped_pNumModes = unwrap(pNumModes);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pIDXGIOutput1->GetDisplayModeList1(
    EnumFormat, 
    Flags, 
    unwrapped_pNumModes, 
    unwrapped_pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput1", "GetDisplayModeList1", &ret, {
    {"EnumFormat", {(void*)&orig_EnumFormat, (void*)&EnumFormat}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pNumModes", {(void*)&orig_pNumModes, (void*)&pNumModes}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::FindClosestMatchingMode1(
  const DXGI_MODE_DESC1 * pModeToMatch, 
  DXGI_MODE_DESC1 * pClosestMatch, 
  struct IUnknown * pConcernedDevice
) {
  assert(m_pIDXGIOutput1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pModeToMatch = pModeToMatch;
  auto orig_pClosestMatch = pClosestMatch;
  auto orig_pConcernedDevice = pConcernedDevice;
  auto unwrapped_pModeToMatch = unwrap(pModeToMatch);
  auto unwrapped_pConcernedDevice = unwrap(pConcernedDevice);
  auto ret = m_pIDXGIOutput1->FindClosestMatchingMode1(
    unwrapped_pModeToMatch, 
    pClosestMatch, 
    unwrapped_pConcernedDevice
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput1", "FindClosestMatchingMode1", &ret, {
    {"pModeToMatch", {(void*)&orig_pModeToMatch, (void*)&pModeToMatch}},
    {"pClosestMatch", {(void*)&orig_pClosestMatch, (void*)&pClosestMatch}},
    {"pConcernedDevice", {(void*)&orig_pConcernedDevice, (void*)&pConcernedDevice}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetDisplaySurfaceData1(
  IDXGIResource * pDestination
) {
  assert(m_pIDXGIOutput1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDestination = pDestination;
  auto unwrapped_pDestination = unwrap(pDestination);
  auto ret = m_pIDXGIOutput1->GetDisplaySurfaceData1(
    unwrapped_pDestination
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput1", "GetDisplaySurfaceData1", &ret, {
    {"pDestination", {(void*)&orig_pDestination, (void*)&pDestination}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::DuplicateOutput(
  struct IUnknown * pDevice, 
  IDXGIOutputDuplication ** ppOutputDuplication
) {
  assert(m_pIDXGIOutput1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_ppOutputDuplication = ppOutputDuplication;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto ret = m_pIDXGIOutput1->DuplicateOutput(
    unwrapped_pDevice, 
    ppOutputDuplication
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppOutputDuplication && *ppOutputDuplication ) *ppOutputDuplication = getWrapper<IDXGIOutputDuplication, WrappedIDXGIOutputDuplication>(*ppOutputDuplication);
  dumpMethodEvent((void*)this, "IDXGIOutput1", "DuplicateOutput", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"ppOutputDuplication", {(void*)&orig_ppOutputDuplication, (void*)&ppOutputDuplication}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetDesc(
  DXGI_OUTPUT_DESC * pDesc
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGIOutput->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetDisplayModeList(
  DXGI_FORMAT EnumFormat, 
  UINT Flags, 
  UINT * pNumModes, 
  DXGI_MODE_DESC * pDesc
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_EnumFormat = EnumFormat;
  auto orig_Flags = Flags;
  auto orig_pNumModes = pNumModes;
  auto orig_pDesc = pDesc;
  auto unwrapped_pNumModes = unwrap(pNumModes);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pIDXGIOutput->GetDisplayModeList(
    EnumFormat, 
    Flags, 
    unwrapped_pNumModes, 
    unwrapped_pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "GetDisplayModeList", &ret, {
    {"EnumFormat", {(void*)&orig_EnumFormat, (void*)&EnumFormat}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pNumModes", {(void*)&orig_pNumModes, (void*)&pNumModes}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::FindClosestMatchingMode(
  const DXGI_MODE_DESC * pModeToMatch, 
  DXGI_MODE_DESC * pClosestMatch, 
  struct IUnknown * pConcernedDevice
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pModeToMatch = pModeToMatch;
  auto orig_pClosestMatch = pClosestMatch;
  auto orig_pConcernedDevice = pConcernedDevice;
  auto unwrapped_pModeToMatch = unwrap(pModeToMatch);
  auto unwrapped_pConcernedDevice = unwrap(pConcernedDevice);
  auto ret = m_pIDXGIOutput->FindClosestMatchingMode(
    unwrapped_pModeToMatch, 
    pClosestMatch, 
    unwrapped_pConcernedDevice
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "FindClosestMatchingMode", &ret, {
    {"pModeToMatch", {(void*)&orig_pModeToMatch, (void*)&pModeToMatch}},
    {"pClosestMatch", {(void*)&orig_pClosestMatch, (void*)&pClosestMatch}},
    {"pConcernedDevice", {(void*)&orig_pConcernedDevice, (void*)&pConcernedDevice}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::WaitForVBlank() {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIOutput->WaitForVBlank();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "WaitForVBlank", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::TakeOwnership(
  struct IUnknown * pDevice, 
  BOOL Exclusive
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_Exclusive = Exclusive;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto ret = m_pIDXGIOutput->TakeOwnership(
    unwrapped_pDevice, 
    Exclusive
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "TakeOwnership", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"Exclusive", {(void*)&orig_Exclusive, (void*)&Exclusive}},
  });
  return ret;
}
void __stdcall WrappedIDXGIOutput5::ReleaseOwnership() {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pIDXGIOutput->ReleaseOwnership();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "ReleaseOwnership", nullptr, {
  });
}
HRESULT __stdcall WrappedIDXGIOutput5::GetGammaControlCapabilities(
  DXGI_GAMMA_CONTROL_CAPABILITIES * pGammaCaps
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pGammaCaps = pGammaCaps;
  auto ret = m_pIDXGIOutput->GetGammaControlCapabilities(
    pGammaCaps
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "GetGammaControlCapabilities", &ret, {
    {"pGammaCaps", {(void*)&orig_pGammaCaps, (void*)&pGammaCaps}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::SetGammaControl(
  const DXGI_GAMMA_CONTROL * pArray
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pArray = pArray;
  auto unwrapped_pArray = unwrap(pArray);
  auto ret = m_pIDXGIOutput->SetGammaControl(
    unwrapped_pArray
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "SetGammaControl", &ret, {
    {"pArray", {(void*)&orig_pArray, (void*)&pArray}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetGammaControl(
  DXGI_GAMMA_CONTROL * pArray
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pArray = pArray;
  auto ret = m_pIDXGIOutput->GetGammaControl(
    pArray
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "GetGammaControl", &ret, {
    {"pArray", {(void*)&orig_pArray, (void*)&pArray}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::SetDisplaySurface(
  IDXGISurface * pScanoutSurface
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pScanoutSurface = pScanoutSurface;
  auto unwrapped_pScanoutSurface = unwrap(pScanoutSurface);
  auto ret = m_pIDXGIOutput->SetDisplaySurface(
    unwrapped_pScanoutSurface
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "SetDisplaySurface", &ret, {
    {"pScanoutSurface", {(void*)&orig_pScanoutSurface, (void*)&pScanoutSurface}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetDisplaySurfaceData(
  IDXGISurface * pDestination
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDestination = pDestination;
  auto unwrapped_pDestination = unwrap(pDestination);
  auto ret = m_pIDXGIOutput->GetDisplaySurfaceData(
    unwrapped_pDestination
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "GetDisplaySurfaceData", &ret, {
    {"pDestination", {(void*)&orig_pDestination, (void*)&pDestination}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetFrameStatistics(
  DXGI_FRAME_STATISTICS * pStats
) {
  assert(m_pIDXGIOutput);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pStats = pStats;
  auto ret = m_pIDXGIOutput->GetFrameStatistics(
    pStats
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIOutput", "GetFrameStatistics", &ret, {
    {"pStats", {(void*)&orig_pStats, (void*)&pStats}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIOutput5::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIOutput5)) {
      *ppvObject = (IDXGIOutput5*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIOutput4)) {
      *ppvObject = (IDXGIOutput4*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIOutput3)) {
      *ppvObject = (IDXGIOutput3*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIOutput2)) {
      *ppvObject = (IDXGIOutput2*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIOutput1)) {
      *ppvObject = (IDXGIOutput1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIOutput)) {
      *ppvObject = (IDXGIOutput*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIOutput5::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIOutput5::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetHDRMetaData(
  DXGI_HDR_METADATA_TYPE Type, 
  UINT Size, 
  void * pMetaData
) {
  assert(m_pIDXGISwapChain4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Type = Type;
  auto orig_Size = Size;
  auto orig_pMetaData = pMetaData;
  auto ret = m_pIDXGISwapChain4->SetHDRMetaData(
    Type, 
    Size, 
    pMetaData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain4", "SetHDRMetaData", &ret, {
    {"Type", {(void*)&orig_Type, (void*)&Type}},
    {"Size", {(void*)&orig_Size, (void*)&Size}},
    {"pMetaData", {(void*)&orig_pMetaData, (void*)&pMetaData}},
  });
  return ret;
}
UINT __stdcall WrappedIDXGISwapChain4::GetCurrentBackBufferIndex() {
  assert(m_pIDXGISwapChain3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGISwapChain3->GetCurrentBackBufferIndex();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain3", "GetCurrentBackBufferIndex", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::CheckColorSpaceSupport(
  DXGI_COLOR_SPACE_TYPE ColorSpace, 
  UINT * pColorSpaceSupport
) {
  assert(m_pIDXGISwapChain3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ColorSpace = ColorSpace;
  auto orig_pColorSpaceSupport = pColorSpaceSupport;
  auto ret = m_pIDXGISwapChain3->CheckColorSpaceSupport(
    ColorSpace, 
    pColorSpaceSupport
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain3", "CheckColorSpaceSupport", &ret, {
    {"ColorSpace", {(void*)&orig_ColorSpace, (void*)&ColorSpace}},
    {"pColorSpaceSupport", {(void*)&orig_pColorSpaceSupport, (void*)&pColorSpaceSupport}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetColorSpace1(
  DXGI_COLOR_SPACE_TYPE ColorSpace
) {
  assert(m_pIDXGISwapChain3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ColorSpace = ColorSpace;
  auto ret = m_pIDXGISwapChain3->SetColorSpace1(
    ColorSpace
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain3", "SetColorSpace1", &ret, {
    {"ColorSpace", {(void*)&orig_ColorSpace, (void*)&ColorSpace}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::ResizeBuffers1(
  UINT BufferCount, 
  UINT Width, 
  UINT Height, 
  DXGI_FORMAT Format, 
  UINT SwapChainFlags, 
  const UINT * pCreationNodeMask, 
  struct IUnknown *const * ppPresentQueue
) {
  assert(m_pIDXGISwapChain3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_BufferCount = BufferCount;
  auto orig_Width = Width;
  auto orig_Height = Height;
  auto orig_Format = Format;
  auto orig_SwapChainFlags = SwapChainFlags;
  auto orig_pCreationNodeMask = pCreationNodeMask;
  auto orig_ppPresentQueue = ppPresentQueue;
  struct IUnknown  *tmp_ppPresentQueue[0x80];
  for (uint32_t i = 0; i < BufferCount; i++) tmp_ppPresentQueue[i] = unwrap(ppPresentQueue[i]);
  auto ret = m_pIDXGISwapChain3->ResizeBuffers1(
    BufferCount, 
    Width, 
    Height, 
    Format, 
    SwapChainFlags, 
    pCreationNodeMask, 
    tmp_ppPresentQueue
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain3", "ResizeBuffers1", &ret, {
    {"BufferCount", {(void*)&orig_BufferCount, (void*)&BufferCount}},
    {"Width", {(void*)&orig_Width, (void*)&Width}},
    {"Height", {(void*)&orig_Height, (void*)&Height}},
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"SwapChainFlags", {(void*)&orig_SwapChainFlags, (void*)&SwapChainFlags}},
    {"pCreationNodeMask", {(void*)&orig_pCreationNodeMask, (void*)&pCreationNodeMask}},
    {"ppPresentQueue", {(void*)&orig_ppPresentQueue, (void*)&ppPresentQueue}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetSourceSize(
  UINT Width, 
  UINT Height
) {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Width = Width;
  auto orig_Height = Height;
  auto ret = m_pIDXGISwapChain2->SetSourceSize(
    Width, 
    Height
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "SetSourceSize", &ret, {
    {"Width", {(void*)&orig_Width, (void*)&Width}},
    {"Height", {(void*)&orig_Height, (void*)&Height}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetSourceSize(
  UINT * pWidth, 
  UINT * pHeight
) {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pWidth = pWidth;
  auto orig_pHeight = pHeight;
  auto ret = m_pIDXGISwapChain2->GetSourceSize(
    pWidth, 
    pHeight
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "GetSourceSize", &ret, {
    {"pWidth", {(void*)&orig_pWidth, (void*)&pWidth}},
    {"pHeight", {(void*)&orig_pHeight, (void*)&pHeight}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetMaximumFrameLatency(
  UINT MaxLatency
) {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_MaxLatency = MaxLatency;
  auto ret = m_pIDXGISwapChain2->SetMaximumFrameLatency(
    MaxLatency
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "SetMaximumFrameLatency", &ret, {
    {"MaxLatency", {(void*)&orig_MaxLatency, (void*)&MaxLatency}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetMaximumFrameLatency(
  UINT * pMaxLatency
) {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pMaxLatency = pMaxLatency;
  auto ret = m_pIDXGISwapChain2->GetMaximumFrameLatency(
    pMaxLatency
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "GetMaximumFrameLatency", &ret, {
    {"pMaxLatency", {(void*)&orig_pMaxLatency, (void*)&pMaxLatency}},
  });
  return ret;
}
HANDLE __stdcall WrappedIDXGISwapChain4::GetFrameLatencyWaitableObject() {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGISwapChain2->GetFrameLatencyWaitableObject();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "GetFrameLatencyWaitableObject", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetMatrixTransform(
  const DXGI_MATRIX_3X2_F * pMatrix
) {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pMatrix = pMatrix;
  auto unwrapped_pMatrix = unwrap(pMatrix);
  auto ret = m_pIDXGISwapChain2->SetMatrixTransform(
    unwrapped_pMatrix
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "SetMatrixTransform", &ret, {
    {"pMatrix", {(void*)&orig_pMatrix, (void*)&pMatrix}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetMatrixTransform(
  DXGI_MATRIX_3X2_F * pMatrix
) {
  assert(m_pIDXGISwapChain2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pMatrix = pMatrix;
  auto ret = m_pIDXGISwapChain2->GetMatrixTransform(
    pMatrix
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain2", "GetMatrixTransform", &ret, {
    {"pMatrix", {(void*)&orig_pMatrix, (void*)&pMatrix}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetDesc1(
  DXGI_SWAP_CHAIN_DESC1 * pDesc
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGISwapChain1->GetDesc1(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetDesc1", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetFullscreenDesc(
  DXGI_SWAP_CHAIN_FULLSCREEN_DESC * pDesc
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGISwapChain1->GetFullscreenDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetFullscreenDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetHwnd(
  HWND * pHwnd
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pHwnd = pHwnd;
  auto ret = m_pIDXGISwapChain1->GetHwnd(
    pHwnd
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetHwnd", &ret, {
    {"pHwnd", {(void*)&orig_pHwnd, (void*)&pHwnd}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetCoreWindow(
  const IID & refiid, 
  void ** ppUnk
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_refiid = refiid;
  auto orig_ppUnk = ppUnk;
  auto ret = m_pIDXGISwapChain1->GetCoreWindow(
    refiid, 
    ppUnk
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppUnk)
    HandleWrap(refiid, (void**)ppUnk);
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetCoreWindow", &ret, {
    {"refiid", {(void*)&orig_refiid, (void*)&refiid}},
    {"ppUnk", {(void*)&orig_ppUnk, (void*)&ppUnk}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::Present1(
  UINT SyncInterval, 
  UINT PresentFlags, 
  const DXGI_PRESENT_PARAMETERS * pPresentParameters
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_SyncInterval = SyncInterval;
  auto orig_PresentFlags = PresentFlags;
  auto orig_pPresentParameters = pPresentParameters;
  auto unwrapped_pPresentParameters = unwrap(pPresentParameters);
  auto ret = m_pIDXGISwapChain1->Present1(
    SyncInterval, 
    PresentFlags, 
    unwrapped_pPresentParameters
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "Present1", &ret, {
    {"SyncInterval", {(void*)&orig_SyncInterval, (void*)&SyncInterval}},
    {"PresentFlags", {(void*)&orig_PresentFlags, (void*)&PresentFlags}},
    {"pPresentParameters", {(void*)&orig_pPresentParameters, (void*)&pPresentParameters}},
  });
  return ret;
}
BOOL __stdcall WrappedIDXGISwapChain4::IsTemporaryMonoSupported() {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGISwapChain1->IsTemporaryMonoSupported();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "IsTemporaryMonoSupported", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetRestrictToOutput(
  IDXGIOutput ** ppRestrictToOutput
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppRestrictToOutput = ppRestrictToOutput;
  auto ret = m_pIDXGISwapChain1->GetRestrictToOutput(
    ppRestrictToOutput
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppRestrictToOutput && *ppRestrictToOutput ) *ppRestrictToOutput = getWrapper<IDXGIOutput, WrappedIDXGIOutput5>(*ppRestrictToOutput);
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetRestrictToOutput", &ret, {
    {"ppRestrictToOutput", {(void*)&orig_ppRestrictToOutput, (void*)&ppRestrictToOutput}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetBackgroundColor(
  const DXGI_RGBA * pColor
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pColor = pColor;
  auto unwrapped_pColor = unwrap(pColor);
  auto ret = m_pIDXGISwapChain1->SetBackgroundColor(
    unwrapped_pColor
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "SetBackgroundColor", &ret, {
    {"pColor", {(void*)&orig_pColor, (void*)&pColor}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetBackgroundColor(
  DXGI_RGBA * pColor
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pColor = pColor;
  auto ret = m_pIDXGISwapChain1->GetBackgroundColor(
    pColor
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetBackgroundColor", &ret, {
    {"pColor", {(void*)&orig_pColor, (void*)&pColor}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetRotation(
  DXGI_MODE_ROTATION Rotation
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Rotation = Rotation;
  auto ret = m_pIDXGISwapChain1->SetRotation(
    Rotation
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "SetRotation", &ret, {
    {"Rotation", {(void*)&orig_Rotation, (void*)&Rotation}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetRotation(
  DXGI_MODE_ROTATION * pRotation
) {
  assert(m_pIDXGISwapChain1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRotation = pRotation;
  auto ret = m_pIDXGISwapChain1->GetRotation(
    pRotation
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain1", "GetRotation", &ret, {
    {"pRotation", {(void*)&orig_pRotation, (void*)&pRotation}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::Present(
  UINT SyncInterval, 
  UINT Flags
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_SyncInterval = SyncInterval;
  auto orig_Flags = Flags;
  auto ret = m_pIDXGISwapChain->Present(
    SyncInterval, 
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "Present", &ret, {
    {"SyncInterval", {(void*)&orig_SyncInterval, (void*)&SyncInterval}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetBuffer(
  UINT Buffer, 
  const IID & riid, 
  void ** ppSurface
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Buffer = Buffer;
  auto orig_riid = riid;
  auto orig_ppSurface = ppSurface;
  auto ret = m_pIDXGISwapChain->GetBuffer(
    Buffer, 
    riid, 
    ppSurface
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppSurface);
    }
  }
  dumpMethodEvent((void*)this, "IDXGISwapChain", "GetBuffer", &ret, {
    {"Buffer", {(void*)&orig_Buffer, (void*)&Buffer}},
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppSurface", {(void*)&orig_ppSurface, (void*)&ppSurface}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetFullscreenState(
  BOOL Fullscreen, 
  IDXGIOutput * pTarget
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Fullscreen = Fullscreen;
  auto orig_pTarget = pTarget;
  auto unwrapped_pTarget = unwrap(pTarget);
  auto ret = m_pIDXGISwapChain->SetFullscreenState(
    Fullscreen, 
    unwrapped_pTarget
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "SetFullscreenState", &ret, {
    {"Fullscreen", {(void*)&orig_Fullscreen, (void*)&Fullscreen}},
    {"pTarget", {(void*)&orig_pTarget, (void*)&pTarget}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetFullscreenState(
  BOOL * pFullscreen, 
  IDXGIOutput ** ppTarget
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFullscreen = pFullscreen;
  auto orig_ppTarget = ppTarget;
  auto ret = m_pIDXGISwapChain->GetFullscreenState(
    pFullscreen, 
    ppTarget
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppTarget && *ppTarget ) *ppTarget = getWrapper<IDXGIOutput, WrappedIDXGIOutput5>(*ppTarget);
  dumpMethodEvent((void*)this, "IDXGISwapChain", "GetFullscreenState", &ret, {
    {"pFullscreen", {(void*)&orig_pFullscreen, (void*)&pFullscreen}},
    {"ppTarget", {(void*)&orig_ppTarget, (void*)&ppTarget}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetDesc(
  DXGI_SWAP_CHAIN_DESC * pDesc
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pIDXGISwapChain->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::ResizeBuffers(
  UINT BufferCount, 
  UINT Width, 
  UINT Height, 
  DXGI_FORMAT NewFormat, 
  UINT SwapChainFlags
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_BufferCount = BufferCount;
  auto orig_Width = Width;
  auto orig_Height = Height;
  auto orig_NewFormat = NewFormat;
  auto orig_SwapChainFlags = SwapChainFlags;
  auto ret = m_pIDXGISwapChain->ResizeBuffers(
    BufferCount, 
    Width, 
    Height, 
    NewFormat, 
    SwapChainFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "ResizeBuffers", &ret, {
    {"BufferCount", {(void*)&orig_BufferCount, (void*)&BufferCount}},
    {"Width", {(void*)&orig_Width, (void*)&Width}},
    {"Height", {(void*)&orig_Height, (void*)&Height}},
    {"NewFormat", {(void*)&orig_NewFormat, (void*)&NewFormat}},
    {"SwapChainFlags", {(void*)&orig_SwapChainFlags, (void*)&SwapChainFlags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::ResizeTarget(
  const DXGI_MODE_DESC * pNewTargetParameters
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pNewTargetParameters = pNewTargetParameters;
  auto unwrapped_pNewTargetParameters = unwrap(pNewTargetParameters);
  auto ret = m_pIDXGISwapChain->ResizeTarget(
    unwrapped_pNewTargetParameters
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "ResizeTarget", &ret, {
    {"pNewTargetParameters", {(void*)&orig_pNewTargetParameters, (void*)&pNewTargetParameters}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetContainingOutput(
  IDXGIOutput ** ppOutput
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppOutput = ppOutput;
  auto ret = m_pIDXGISwapChain->GetContainingOutput(
    ppOutput
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppOutput && *ppOutput ) *ppOutput = getWrapper<IDXGIOutput, WrappedIDXGIOutput5>(*ppOutput);
  dumpMethodEvent((void*)this, "IDXGISwapChain", "GetContainingOutput", &ret, {
    {"ppOutput", {(void*)&orig_ppOutput, (void*)&ppOutput}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetFrameStatistics(
  DXGI_FRAME_STATISTICS * pStats
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pStats = pStats;
  auto ret = m_pIDXGISwapChain->GetFrameStatistics(
    pStats
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "GetFrameStatistics", &ret, {
    {"pStats", {(void*)&orig_pStats, (void*)&pStats}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetLastPresentCount(
  UINT * pLastPresentCount
) {
  assert(m_pIDXGISwapChain);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLastPresentCount = pLastPresentCount;
  auto ret = m_pIDXGISwapChain->GetLastPresentCount(
    pLastPresentCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGISwapChain", "GetLastPresentCount", &ret, {
    {"pLastPresentCount", {(void*)&orig_pLastPresentCount, (void*)&pLastPresentCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetDevice(
  const IID & riid, 
  void ** ppDevice
) {
  assert(m_pIDXGIDeviceSubObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppDevice = ppDevice;
  auto ret = m_pIDXGIDeviceSubObject->GetDevice(
    riid, 
    ppDevice
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "IDXGIDeviceSubObject", "GetDevice", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGISwapChain4::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGISwapChain4)) {
      *ppvObject = (IDXGISwapChain4*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGISwapChain3)) {
      *ppvObject = (IDXGISwapChain3*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGISwapChain2)) {
      *ppvObject = (IDXGISwapChain2*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGISwapChain1)) {
      *ppvObject = (IDXGISwapChain1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGISwapChain)) {
      *ppvObject = (IDXGISwapChain*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDeviceSubObject)) {
      *ppvObject = (IDXGIDeviceSubObject*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGISwapChain4::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGISwapChain4::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::OfferResources1(
  UINT NumResources, 
  IDXGIResource *const * ppResources, 
  DXGI_OFFER_RESOURCE_PRIORITY Priority, 
  UINT Flags
) {
  assert(m_pIDXGIDevice4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumResources = NumResources;
  auto orig_ppResources = ppResources;
  auto orig_Priority = Priority;
  auto orig_Flags = Flags;
  IDXGIResource  *tmp_ppResources[0x80];
  for (uint32_t i = 0; i < NumResources; i++) tmp_ppResources[i] = unwrap(ppResources[i]);
  auto ret = m_pIDXGIDevice4->OfferResources1(
    NumResources, 
    tmp_ppResources, 
    Priority, 
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice4", "OfferResources1", &ret, {
    {"NumResources", {(void*)&orig_NumResources, (void*)&NumResources}},
    {"ppResources", {(void*)&orig_ppResources, (void*)&ppResources}},
    {"Priority", {(void*)&orig_Priority, (void*)&Priority}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::ReclaimResources1(
  UINT NumResources, 
  IDXGIResource *const * ppResources, 
  DXGI_RECLAIM_RESOURCE_RESULTS * pResults
) {
  assert(m_pIDXGIDevice4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumResources = NumResources;
  auto orig_ppResources = ppResources;
  auto orig_pResults = pResults;
  IDXGIResource  *tmp_ppResources[0x80];
  for (uint32_t i = 0; i < NumResources; i++) tmp_ppResources[i] = unwrap(ppResources[i]);
  auto ret = m_pIDXGIDevice4->ReclaimResources1(
    NumResources, 
    tmp_ppResources, 
    pResults
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice4", "ReclaimResources1", &ret, {
    {"NumResources", {(void*)&orig_NumResources, (void*)&NumResources}},
    {"ppResources", {(void*)&orig_ppResources, (void*)&ppResources}},
    {"pResults", {(void*)&orig_pResults, (void*)&pResults}},
  });
  return ret;
}
void __stdcall WrappedIDXGIDevice4::Trim() {
  assert(m_pIDXGIDevice3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pIDXGIDevice3->Trim();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice3", "Trim", nullptr, {
  });
}
HRESULT __stdcall WrappedIDXGIDevice4::OfferResources(
  UINT NumResources, 
  IDXGIResource *const * ppResources, 
  DXGI_OFFER_RESOURCE_PRIORITY Priority
) {
  assert(m_pIDXGIDevice2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumResources = NumResources;
  auto orig_ppResources = ppResources;
  auto orig_Priority = Priority;
  IDXGIResource  *tmp_ppResources[0x80];
  for (uint32_t i = 0; i < NumResources; i++) tmp_ppResources[i] = unwrap(ppResources[i]);
  auto ret = m_pIDXGIDevice2->OfferResources(
    NumResources, 
    tmp_ppResources, 
    Priority
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice2", "OfferResources", &ret, {
    {"NumResources", {(void*)&orig_NumResources, (void*)&NumResources}},
    {"ppResources", {(void*)&orig_ppResources, (void*)&ppResources}},
    {"Priority", {(void*)&orig_Priority, (void*)&Priority}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::ReclaimResources(
  UINT NumResources, 
  IDXGIResource *const * ppResources, 
  BOOL * pDiscarded
) {
  assert(m_pIDXGIDevice2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_NumResources = NumResources;
  auto orig_ppResources = ppResources;
  auto orig_pDiscarded = pDiscarded;
  IDXGIResource  *tmp_ppResources[0x80];
  for (uint32_t i = 0; i < NumResources; i++) tmp_ppResources[i] = unwrap(ppResources[i]);
  auto ret = m_pIDXGIDevice2->ReclaimResources(
    NumResources, 
    tmp_ppResources, 
    pDiscarded
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice2", "ReclaimResources", &ret, {
    {"NumResources", {(void*)&orig_NumResources, (void*)&NumResources}},
    {"ppResources", {(void*)&orig_ppResources, (void*)&ppResources}},
    {"pDiscarded", {(void*)&orig_pDiscarded, (void*)&pDiscarded}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::EnqueueSetEvent(
  HANDLE hEvent
) {
  assert(m_pIDXGIDevice2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hEvent = hEvent;
  auto ret = m_pIDXGIDevice2->EnqueueSetEvent(
    hEvent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice2", "EnqueueSetEvent", &ret, {
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::SetMaximumFrameLatency(
  UINT MaxLatency
) {
  assert(m_pIDXGIDevice1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_MaxLatency = MaxLatency;
  auto ret = m_pIDXGIDevice1->SetMaximumFrameLatency(
    MaxLatency
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice1", "SetMaximumFrameLatency", &ret, {
    {"MaxLatency", {(void*)&orig_MaxLatency, (void*)&MaxLatency}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::GetMaximumFrameLatency(
  UINT * pMaxLatency
) {
  assert(m_pIDXGIDevice1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pMaxLatency = pMaxLatency;
  auto ret = m_pIDXGIDevice1->GetMaximumFrameLatency(
    pMaxLatency
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice1", "GetMaximumFrameLatency", &ret, {
    {"pMaxLatency", {(void*)&orig_pMaxLatency, (void*)&pMaxLatency}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::GetAdapter(
  IDXGIAdapter ** pAdapter
) {
  assert(m_pIDXGIDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAdapter = pAdapter;
  auto ret = m_pIDXGIDevice->GetAdapter(
    pAdapter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && pAdapter && *pAdapter ) *pAdapter = getWrapper<IDXGIAdapter, WrappedIDXGIAdapter3>(*pAdapter);
  dumpMethodEvent((void*)this, "IDXGIDevice", "GetAdapter", &ret, {
    {"pAdapter", {(void*)&orig_pAdapter, (void*)&pAdapter}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::CreateSurface(
  const DXGI_SURFACE_DESC * pDesc, 
  UINT NumSurfaces, 
  DXGI_USAGE Usage, 
  const DXGI_SHARED_RESOURCE * pSharedResource, 
  IDXGISurface ** ppSurface
) {
  assert(m_pIDXGIDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_NumSurfaces = NumSurfaces;
  auto orig_Usage = Usage;
  auto orig_pSharedResource = pSharedResource;
  auto orig_ppSurface = ppSurface;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pSharedResource = unwrap(pSharedResource);
  auto ret = m_pIDXGIDevice->CreateSurface(
    unwrapped_pDesc, 
    NumSurfaces, 
    Usage, 
    unwrapped_pSharedResource, 
    ppSurface
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSurface && *ppSurface ) *ppSurface = getWrapper<IDXGISurface, WrappedIDXGISurface2>(*ppSurface);
  dumpMethodEvent((void*)this, "IDXGIDevice", "CreateSurface", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"NumSurfaces", {(void*)&orig_NumSurfaces, (void*)&NumSurfaces}},
    {"Usage", {(void*)&orig_Usage, (void*)&Usage}},
    {"pSharedResource", {(void*)&orig_pSharedResource, (void*)&pSharedResource}},
    {"ppSurface", {(void*)&orig_ppSurface, (void*)&ppSurface}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::QueryResourceResidency(
  struct IUnknown *const * ppResources, 
  DXGI_RESIDENCY * pResidencyStatus, 
  UINT NumResources
) {
  assert(m_pIDXGIDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppResources = ppResources;
  auto orig_pResidencyStatus = pResidencyStatus;
  auto orig_NumResources = NumResources;
  struct IUnknown  *tmp_ppResources[0x80];
  for (uint32_t i = 0; i < NumResources; i++) tmp_ppResources[i] = unwrap(ppResources[i]);
  auto ret = m_pIDXGIDevice->QueryResourceResidency(
    tmp_ppResources, 
    pResidencyStatus, 
    NumResources
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice", "QueryResourceResidency", &ret, {
    {"ppResources", {(void*)&orig_ppResources, (void*)&ppResources}},
    {"pResidencyStatus", {(void*)&orig_pResidencyStatus, (void*)&pResidencyStatus}},
    {"NumResources", {(void*)&orig_NumResources, (void*)&NumResources}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::SetGPUThreadPriority(
  INT Priority
) {
  assert(m_pIDXGIDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Priority = Priority;
  auto ret = m_pIDXGIDevice->SetGPUThreadPriority(
    Priority
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice", "SetGPUThreadPriority", &ret, {
    {"Priority", {(void*)&orig_Priority, (void*)&Priority}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::GetGPUThreadPriority(
  INT * pPriority
) {
  assert(m_pIDXGIDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pPriority = pPriority;
  auto ret = m_pIDXGIDevice->GetGPUThreadPriority(
    pPriority
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIDevice", "GetGPUThreadPriority", &ret, {
    {"pPriority", {(void*)&orig_pPriority, (void*)&pPriority}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIDevice4::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIDevice4)) {
      *ppvObject = (IDXGIDevice4*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDevice3)) {
      *ppvObject = (IDXGIDevice3*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDevice2)) {
      *ppvObject = (IDXGIDevice2*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDevice1)) {
      *ppvObject = (IDXGIDevice1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIDevice)) {
      *ppvObject = (IDXGIDevice*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIDevice4::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIDevice4::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::CheckFeatureSupport(
  DXGI_FEATURE Feature, 
  void * pFeatureSupportData, 
  UINT FeatureSupportDataSize
) {
  assert(m_pIDXGIFactory5);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Feature = Feature;
  auto orig_pFeatureSupportData = pFeatureSupportData;
  auto orig_FeatureSupportDataSize = FeatureSupportDataSize;
  auto unwrapped_pFeatureSupportData = unwrap(pFeatureSupportData);
  auto ret = m_pIDXGIFactory5->CheckFeatureSupport(
    Feature, 
    unwrapped_pFeatureSupportData, 
    FeatureSupportDataSize
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory5", "CheckFeatureSupport", &ret, {
    {"Feature", {(void*)&orig_Feature, (void*)&Feature}},
    {"pFeatureSupportData", {(void*)&orig_pFeatureSupportData, (void*)&pFeatureSupportData}},
    {"FeatureSupportDataSize", {(void*)&orig_FeatureSupportDataSize, (void*)&FeatureSupportDataSize}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::EnumAdapterByLuid(
  LUID AdapterLuid, 
  const IID & riid, 
  void ** ppvAdapter
) {
  assert(m_pIDXGIFactory4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_AdapterLuid = AdapterLuid;
  auto orig_riid = riid;
  auto orig_ppvAdapter = ppvAdapter;
  auto ret = m_pIDXGIFactory4->EnumAdapterByLuid(
    AdapterLuid, 
    riid, 
    ppvAdapter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppvAdapter);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIFactory4", "EnumAdapterByLuid", &ret, {
    {"AdapterLuid", {(void*)&orig_AdapterLuid, (void*)&AdapterLuid}},
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvAdapter", {(void*)&orig_ppvAdapter, (void*)&ppvAdapter}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::EnumWarpAdapter(
  const IID & riid, 
  void ** ppvAdapter
) {
  assert(m_pIDXGIFactory4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvAdapter = ppvAdapter;
  auto ret = m_pIDXGIFactory4->EnumWarpAdapter(
    riid, 
    ppvAdapter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppvAdapter);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIFactory4", "EnumWarpAdapter", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvAdapter", {(void*)&orig_ppvAdapter, (void*)&ppvAdapter}},
  });
  return ret;
}
UINT __stdcall WrappedIDXGIFactory5::GetCreationFlags() {
  assert(m_pIDXGIFactory3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIFactory3->GetCreationFlags();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory3", "GetCreationFlags", &ret, {
  });
  return ret;
}
BOOL __stdcall WrappedIDXGIFactory5::IsWindowedStereoEnabled() {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIFactory2->IsWindowedStereoEnabled();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "IsWindowedStereoEnabled", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::CreateSwapChainForHwnd(
  struct IUnknown * pDevice, 
  HWND hWnd, 
  const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
  const DXGI_SWAP_CHAIN_FULLSCREEN_DESC * pFullscreenDesc, 
  IDXGIOutput * pRestrictToOutput, 
  IDXGISwapChain1 ** ppSwapChain
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_hWnd = hWnd;
  auto orig_pDesc = pDesc;
  auto orig_pFullscreenDesc = pFullscreenDesc;
  auto orig_pRestrictToOutput = pRestrictToOutput;
  auto orig_ppSwapChain = ppSwapChain;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pFullscreenDesc = unwrap(pFullscreenDesc);
  auto unwrapped_pRestrictToOutput = unwrap(pRestrictToOutput);
  auto ret = m_pIDXGIFactory2->CreateSwapChainForHwnd(
    unwrapped_pDevice, 
    hWnd, 
    unwrapped_pDesc, 
    unwrapped_pFullscreenDesc, 
    unwrapped_pRestrictToOutput, 
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGISwapChain1, WrappedIDXGISwapChain4>(*ppSwapChain);
  dumpMethodEvent((void*)this, "IDXGIFactory2", "CreateSwapChainForHwnd", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"hWnd", {(void*)&orig_hWnd, (void*)&hWnd}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pFullscreenDesc", {(void*)&orig_pFullscreenDesc, (void*)&pFullscreenDesc}},
    {"pRestrictToOutput", {(void*)&orig_pRestrictToOutput, (void*)&pRestrictToOutput}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::CreateSwapChainForCoreWindow(
  struct IUnknown * pDevice, 
  struct IUnknown * pWindow, 
  const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
  IDXGIOutput * pRestrictToOutput, 
  IDXGISwapChain1 ** ppSwapChain
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_pWindow = pWindow;
  auto orig_pDesc = pDesc;
  auto orig_pRestrictToOutput = pRestrictToOutput;
  auto orig_ppSwapChain = ppSwapChain;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto unwrapped_pWindow = unwrap(pWindow);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pRestrictToOutput = unwrap(pRestrictToOutput);
  auto ret = m_pIDXGIFactory2->CreateSwapChainForCoreWindow(
    unwrapped_pDevice, 
    unwrapped_pWindow, 
    unwrapped_pDesc, 
    unwrapped_pRestrictToOutput, 
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGISwapChain1, WrappedIDXGISwapChain4>(*ppSwapChain);
  dumpMethodEvent((void*)this, "IDXGIFactory2", "CreateSwapChainForCoreWindow", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"pWindow", {(void*)&orig_pWindow, (void*)&pWindow}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pRestrictToOutput", {(void*)&orig_pRestrictToOutput, (void*)&pRestrictToOutput}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::GetSharedResourceAdapterLuid(
  HANDLE hResource, 
  LUID * pLuid
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hResource = hResource;
  auto orig_pLuid = pLuid;
  auto ret = m_pIDXGIFactory2->GetSharedResourceAdapterLuid(
    hResource, 
    pLuid
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "GetSharedResourceAdapterLuid", &ret, {
    {"hResource", {(void*)&orig_hResource, (void*)&hResource}},
    {"pLuid", {(void*)&orig_pLuid, (void*)&pLuid}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::RegisterStereoStatusWindow(
  HWND WindowHandle, 
  UINT wMsg, 
  DWORD * pdwCookie
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_WindowHandle = WindowHandle;
  auto orig_wMsg = wMsg;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pIDXGIFactory2->RegisterStereoStatusWindow(
    WindowHandle, 
    wMsg, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "RegisterStereoStatusWindow", &ret, {
    {"WindowHandle", {(void*)&orig_WindowHandle, (void*)&WindowHandle}},
    {"wMsg", {(void*)&orig_wMsg, (void*)&wMsg}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::RegisterStereoStatusEvent(
  HANDLE hEvent, 
  DWORD * pdwCookie
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hEvent = hEvent;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pIDXGIFactory2->RegisterStereoStatusEvent(
    hEvent, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "RegisterStereoStatusEvent", &ret, {
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
void __stdcall WrappedIDXGIFactory5::UnregisterStereoStatus(
  DWORD dwCookie
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_dwCookie = dwCookie;
  m_pIDXGIFactory2->UnregisterStereoStatus(
    dwCookie
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "UnregisterStereoStatus", nullptr, {
    {"dwCookie", {(void*)&orig_dwCookie, (void*)&dwCookie}},
  });
}
HRESULT __stdcall WrappedIDXGIFactory5::RegisterOcclusionStatusWindow(
  HWND WindowHandle, 
  UINT wMsg, 
  DWORD * pdwCookie
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_WindowHandle = WindowHandle;
  auto orig_wMsg = wMsg;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pIDXGIFactory2->RegisterOcclusionStatusWindow(
    WindowHandle, 
    wMsg, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "RegisterOcclusionStatusWindow", &ret, {
    {"WindowHandle", {(void*)&orig_WindowHandle, (void*)&WindowHandle}},
    {"wMsg", {(void*)&orig_wMsg, (void*)&wMsg}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::RegisterOcclusionStatusEvent(
  HANDLE hEvent, 
  DWORD * pdwCookie
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hEvent = hEvent;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pIDXGIFactory2->RegisterOcclusionStatusEvent(
    hEvent, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "RegisterOcclusionStatusEvent", &ret, {
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
void __stdcall WrappedIDXGIFactory5::UnregisterOcclusionStatus(
  DWORD dwCookie
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_dwCookie = dwCookie;
  m_pIDXGIFactory2->UnregisterOcclusionStatus(
    dwCookie
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory2", "UnregisterOcclusionStatus", nullptr, {
    {"dwCookie", {(void*)&orig_dwCookie, (void*)&dwCookie}},
  });
}
HRESULT __stdcall WrappedIDXGIFactory5::CreateSwapChainForComposition(
  struct IUnknown * pDevice, 
  const DXGI_SWAP_CHAIN_DESC1 * pDesc, 
  IDXGIOutput * pRestrictToOutput, 
  IDXGISwapChain1 ** ppSwapChain
) {
  assert(m_pIDXGIFactory2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_pDesc = pDesc;
  auto orig_pRestrictToOutput = pRestrictToOutput;
  auto orig_ppSwapChain = ppSwapChain;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pRestrictToOutput = unwrap(pRestrictToOutput);
  auto ret = m_pIDXGIFactory2->CreateSwapChainForComposition(
    unwrapped_pDevice, 
    unwrapped_pDesc, 
    unwrapped_pRestrictToOutput, 
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGISwapChain1, WrappedIDXGISwapChain4>(*ppSwapChain);
  dumpMethodEvent((void*)this, "IDXGIFactory2", "CreateSwapChainForComposition", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pRestrictToOutput", {(void*)&orig_pRestrictToOutput, (void*)&pRestrictToOutput}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::EnumAdapters1(
  UINT Adapter, 
  IDXGIAdapter1 ** ppAdapter
) {
  assert(m_pIDXGIFactory1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Adapter = Adapter;
  auto orig_ppAdapter = ppAdapter;
  auto ret = m_pIDXGIFactory1->EnumAdapters1(
    Adapter, 
    ppAdapter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppAdapter && *ppAdapter ) *ppAdapter = getWrapper<IDXGIAdapter1, WrappedIDXGIAdapter3>(*ppAdapter);
  dumpMethodEvent((void*)this, "IDXGIFactory1", "EnumAdapters1", &ret, {
    {"Adapter", {(void*)&orig_Adapter, (void*)&Adapter}},
    {"ppAdapter", {(void*)&orig_ppAdapter, (void*)&ppAdapter}},
  });
  return ret;
}
BOOL __stdcall WrappedIDXGIFactory5::IsCurrent() {
  assert(m_pIDXGIFactory1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pIDXGIFactory1->IsCurrent();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory1", "IsCurrent", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::EnumAdapters(
  UINT Adapter, 
  IDXGIAdapter ** ppAdapter
) {
  assert(m_pIDXGIFactory);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Adapter = Adapter;
  auto orig_ppAdapter = ppAdapter;
  auto ret = m_pIDXGIFactory->EnumAdapters(
    Adapter, 
    ppAdapter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppAdapter && *ppAdapter ) *ppAdapter = getWrapper<IDXGIAdapter, WrappedIDXGIAdapter3>(*ppAdapter);
  dumpMethodEvent((void*)this, "IDXGIFactory", "EnumAdapters", &ret, {
    {"Adapter", {(void*)&orig_Adapter, (void*)&Adapter}},
    {"ppAdapter", {(void*)&orig_ppAdapter, (void*)&ppAdapter}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::MakeWindowAssociation(
  HWND WindowHandle, 
  UINT Flags
) {
  assert(m_pIDXGIFactory);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_WindowHandle = WindowHandle;
  auto orig_Flags = Flags;
  auto ret = m_pIDXGIFactory->MakeWindowAssociation(
    WindowHandle, 
    Flags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory", "MakeWindowAssociation", &ret, {
    {"WindowHandle", {(void*)&orig_WindowHandle, (void*)&WindowHandle}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::GetWindowAssociation(
  HWND * pWindowHandle
) {
  assert(m_pIDXGIFactory);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pWindowHandle = pWindowHandle;
  auto ret = m_pIDXGIFactory->GetWindowAssociation(
    pWindowHandle
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIFactory", "GetWindowAssociation", &ret, {
    {"pWindowHandle", {(void*)&orig_pWindowHandle, (void*)&pWindowHandle}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::CreateSwapChain(
  struct IUnknown * pDevice, 
  DXGI_SWAP_CHAIN_DESC * pDesc, 
  IDXGISwapChain ** ppSwapChain
) {
  assert(m_pIDXGIFactory);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDevice = pDevice;
  auto orig_pDesc = pDesc;
  auto orig_ppSwapChain = ppSwapChain;
  auto unwrapped_pDevice = unwrap(pDevice);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pIDXGIFactory->CreateSwapChain(
    unwrapped_pDevice, 
    unwrapped_pDesc, 
    ppSwapChain
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain ) *ppSwapChain = getWrapper<IDXGISwapChain, WrappedIDXGISwapChain4>(*ppSwapChain);
  dumpMethodEvent((void*)this, "IDXGIFactory", "CreateSwapChain", &ret, {
    {"pDevice", {(void*)&orig_pDevice, (void*)&pDevice}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::CreateSoftwareAdapter(
  HMODULE Module, 
  IDXGIAdapter ** ppAdapter
) {
  assert(m_pIDXGIFactory);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Module = Module;
  auto orig_ppAdapter = ppAdapter;
  auto ret = m_pIDXGIFactory->CreateSoftwareAdapter(
    Module, 
    ppAdapter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppAdapter && *ppAdapter ) *ppAdapter = getWrapper<IDXGIAdapter, WrappedIDXGIAdapter3>(*ppAdapter);
  dumpMethodEvent((void*)this, "IDXGIFactory", "CreateSoftwareAdapter", &ret, {
    {"Module", {(void*)&orig_Module, (void*)&Module}},
    {"ppAdapter", {(void*)&orig_ppAdapter, (void*)&ppAdapter}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::SetPrivateData(
  const GUID & Name, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pIDXGIObject->SetPrivateData(
    Name, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::SetPrivateDataInterface(
  const GUID & Name, 
  const struct IUnknown * pUnknown
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pUnknown = pUnknown;
  auto unwrapped_pUnknown = unwrap(pUnknown);
  auto ret = m_pIDXGIObject->SetPrivateDataInterface(
    Name, 
    unwrapped_pUnknown
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "SetPrivateDataInterface", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pUnknown", {(void*)&orig_pUnknown, (void*)&pUnknown}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::GetPrivateData(
  const GUID & Name, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pIDXGIObject->GetPrivateData(
    Name, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "IDXGIObject", "GetPrivateData", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::GetParent(
  const IID & riid, 
  void ** ppParent
) {
  assert(m_pIDXGIObject);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppParent = ppParent;
  auto ret = m_pIDXGIObject->GetParent(
    riid, 
    ppParent
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  {
    if(!ret) {
      HandleWrap(riid, ppParent);
    }
  }
  dumpMethodEvent((void*)this, "IDXGIObject", "GetParent", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppParent", {(void*)&orig_ppParent, (void*)&ppParent}},
  });
  return ret;
}
HRESULT __stdcall WrappedIDXGIFactory5::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(IDXGIFactory5)) {
      *ppvObject = (IDXGIFactory5*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIFactory4)) {
      *ppvObject = (IDXGIFactory4*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIFactory3)) {
      *ppvObject = (IDXGIFactory3*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIFactory2)) {
      *ppvObject = (IDXGIFactory2*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIFactory1)) {
      *ppvObject = (IDXGIFactory1*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIFactory)) {
      *ppvObject = (IDXGIFactory*)this;
      return ret;
    }
    if(riid == __uuidof(IDXGIObject)) {
      *ppvObject = (IDXGIObject*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIFactory5::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedIDXGIFactory5::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::OpenSharedFence(
  HANDLE hFence, 
  const IID & ReturnedInterface, 
  void ** ppFence
) {
  assert(m_pID3D11Device5);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hFence = hFence;
  auto orig_ReturnedInterface = ReturnedInterface;
  auto orig_ppFence = ppFence;
  auto ret = m_pID3D11Device5->OpenSharedFence(
    hFence, 
    ReturnedInterface, 
    ppFence
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppFence)
    HandleWrap(ReturnedInterface, (void**)ppFence);
  dumpMethodEvent((void*)this, "ID3D11Device5", "OpenSharedFence", &ret, {
    {"hFence", {(void*)&orig_hFence, (void*)&hFence}},
    {"ReturnedInterface", {(void*)&orig_ReturnedInterface, (void*)&ReturnedInterface}},
    {"ppFence", {(void*)&orig_ppFence, (void*)&ppFence}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateFence(
  UINT64 InitialValue, 
  D3D11_FENCE_FLAG Flags, 
  const IID & ReturnedInterface, 
  void ** ppFence
) {
  assert(m_pID3D11Device5);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_InitialValue = InitialValue;
  auto orig_Flags = Flags;
  auto orig_ReturnedInterface = ReturnedInterface;
  auto orig_ppFence = ppFence;
  auto ret = m_pID3D11Device5->CreateFence(
    InitialValue, 
    Flags, 
    ReturnedInterface, 
    ppFence
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppFence)
    HandleWrap(ReturnedInterface, (void**)ppFence);
  dumpMethodEvent((void*)this, "ID3D11Device5", "CreateFence", &ret, {
    {"InitialValue", {(void*)&orig_InitialValue, (void*)&InitialValue}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"ReturnedInterface", {(void*)&orig_ReturnedInterface, (void*)&ReturnedInterface}},
    {"ppFence", {(void*)&orig_ppFence, (void*)&ppFence}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::RegisterDeviceRemovedEvent(
  HANDLE hEvent, 
  DWORD * pdwCookie
) {
  assert(m_pID3D11Device4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hEvent = hEvent;
  auto orig_pdwCookie = pdwCookie;
  auto ret = m_pID3D11Device4->RegisterDeviceRemovedEvent(
    hEvent, 
    pdwCookie
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device4", "RegisterDeviceRemovedEvent", &ret, {
    {"hEvent", {(void*)&orig_hEvent, (void*)&hEvent}},
    {"pdwCookie", {(void*)&orig_pdwCookie, (void*)&pdwCookie}},
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::UnregisterDeviceRemoved(
  DWORD dwCookie
) {
  assert(m_pID3D11Device4);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_dwCookie = dwCookie;
  m_pID3D11Device4->UnregisterDeviceRemoved(
    dwCookie
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device4", "UnregisterDeviceRemoved", nullptr, {
    {"dwCookie", {(void*)&orig_dwCookie, (void*)&dwCookie}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::CreateTexture2D1(
  const D3D11_TEXTURE2D_DESC1 * pDesc1, 
  const D3D11_SUBRESOURCE_DATA * pInitialData, 
  ID3D11Texture2D1 ** ppTexture2D
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc1 = pDesc1;
  auto orig_pInitialData = pInitialData;
  auto orig_ppTexture2D = ppTexture2D;
  auto unwrapped_pDesc1 = unwrap(pDesc1);
  auto ret = m_pID3D11Device3->CreateTexture2D1(
    unwrapped_pDesc1, 
    pInitialData, 
    ppTexture2D
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppTexture2D && *ppTexture2D ) *ppTexture2D = getWrapper<ID3D11Texture2D1, WrappedID3D11Texture2D1>(*ppTexture2D);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateTexture2D1", &ret, {
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
    {"pInitialData", {(void*)&orig_pInitialData, (void*)&pInitialData}},
    {"ppTexture2D", {(void*)&orig_ppTexture2D, (void*)&ppTexture2D}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateTexture3D1(
  const D3D11_TEXTURE3D_DESC1 * pDesc1, 
  const D3D11_SUBRESOURCE_DATA * pInitialData, 
  ID3D11Texture3D1 ** ppTexture3D
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc1 = pDesc1;
  auto orig_pInitialData = pInitialData;
  auto orig_ppTexture3D = ppTexture3D;
  auto unwrapped_pDesc1 = unwrap(pDesc1);
  auto ret = m_pID3D11Device3->CreateTexture3D1(
    unwrapped_pDesc1, 
    pInitialData, 
    ppTexture3D
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppTexture3D && *ppTexture3D ) *ppTexture3D = getWrapper<ID3D11Texture3D1, WrappedID3D11Texture3D1>(*ppTexture3D);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateTexture3D1", &ret, {
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
    {"pInitialData", {(void*)&orig_pInitialData, (void*)&pInitialData}},
    {"ppTexture3D", {(void*)&orig_ppTexture3D, (void*)&ppTexture3D}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateRasterizerState2(
  const D3D11_RASTERIZER_DESC2 * pRasterizerDesc, 
  ID3D11RasterizerState2 ** ppRasterizerState
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRasterizerDesc = pRasterizerDesc;
  auto orig_ppRasterizerState = ppRasterizerState;
  auto unwrapped_pRasterizerDesc = unwrap(pRasterizerDesc);
  auto ret = m_pID3D11Device3->CreateRasterizerState2(
    unwrapped_pRasterizerDesc, 
    ppRasterizerState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppRasterizerState && *ppRasterizerState ) *ppRasterizerState = getWrapper<ID3D11RasterizerState2, WrappedID3D11RasterizerState2>(*ppRasterizerState);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateRasterizerState2", &ret, {
    {"pRasterizerDesc", {(void*)&orig_pRasterizerDesc, (void*)&pRasterizerDesc}},
    {"ppRasterizerState", {(void*)&orig_ppRasterizerState, (void*)&ppRasterizerState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateShaderResourceView1(
  ID3D11Resource * pResource, 
  const D3D11_SHADER_RESOURCE_VIEW_DESC1 * pDesc1, 
  ID3D11ShaderResourceView1 ** ppSRView1
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc1 = pDesc1;
  auto orig_ppSRView1 = ppSRView1;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc1 = unwrap(pDesc1);
  auto ret = m_pID3D11Device3->CreateShaderResourceView1(
    unwrapped_pResource, 
    unwrapped_pDesc1, 
    ppSRView1
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSRView1 && *ppSRView1 ) *ppSRView1 = getWrapper<ID3D11ShaderResourceView1, WrappedID3D11ShaderResourceView1>(*ppSRView1);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateShaderResourceView1", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
    {"ppSRView1", {(void*)&orig_ppSRView1, (void*)&ppSRView1}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateUnorderedAccessView1(
  ID3D11Resource * pResource, 
  const D3D11_UNORDERED_ACCESS_VIEW_DESC1 * pDesc1, 
  ID3D11UnorderedAccessView1 ** ppUAView1
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc1 = pDesc1;
  auto orig_ppUAView1 = ppUAView1;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc1 = unwrap(pDesc1);
  auto ret = m_pID3D11Device3->CreateUnorderedAccessView1(
    unwrapped_pResource, 
    unwrapped_pDesc1, 
    ppUAView1
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppUAView1 && *ppUAView1 ) *ppUAView1 = getWrapper<ID3D11UnorderedAccessView1, WrappedID3D11UnorderedAccessView1>(*ppUAView1);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateUnorderedAccessView1", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
    {"ppUAView1", {(void*)&orig_ppUAView1, (void*)&ppUAView1}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateRenderTargetView1(
  ID3D11Resource * pResource, 
  const D3D11_RENDER_TARGET_VIEW_DESC1 * pDesc1, 
  ID3D11RenderTargetView1 ** ppRTView1
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc1 = pDesc1;
  auto orig_ppRTView1 = ppRTView1;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc1 = unwrap(pDesc1);
  auto ret = m_pID3D11Device3->CreateRenderTargetView1(
    unwrapped_pResource, 
    unwrapped_pDesc1, 
    ppRTView1
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppRTView1 && *ppRTView1 ) *ppRTView1 = getWrapper<ID3D11RenderTargetView1, WrappedID3D11RenderTargetView1>(*ppRTView1);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateRenderTargetView1", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc1", {(void*)&orig_pDesc1, (void*)&pDesc1}},
    {"ppRTView1", {(void*)&orig_ppRTView1, (void*)&ppRTView1}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateQuery1(
  const D3D11_QUERY_DESC1 * pQueryDesc1, 
  ID3D11Query1 ** ppQuery1
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pQueryDesc1 = pQueryDesc1;
  auto orig_ppQuery1 = ppQuery1;
  auto unwrapped_pQueryDesc1 = unwrap(pQueryDesc1);
  auto ret = m_pID3D11Device3->CreateQuery1(
    unwrapped_pQueryDesc1, 
    ppQuery1
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppQuery1 && *ppQuery1 ) *ppQuery1 = getWrapper<ID3D11Query1, WrappedID3D11Query1>(*ppQuery1);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateQuery1", &ret, {
    {"pQueryDesc1", {(void*)&orig_pQueryDesc1, (void*)&pQueryDesc1}},
    {"ppQuery1", {(void*)&orig_ppQuery1, (void*)&ppQuery1}},
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::GetImmediateContext3(
  ID3D11DeviceContext3 ** ppImmediateContext
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppImmediateContext = ppImmediateContext;
  m_pID3D11Device3->GetImmediateContext3(
    ppImmediateContext
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppImmediateContext && *ppImmediateContext ) *ppImmediateContext = getWrapper<ID3D11DeviceContext3, WrappedID3D11DeviceContext4>(*ppImmediateContext);
  dumpMethodEvent((void*)this, "ID3D11Device3", "GetImmediateContext3", nullptr, {
    {"ppImmediateContext", {(void*)&orig_ppImmediateContext, (void*)&ppImmediateContext}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::CreateDeferredContext3(
  UINT ContextFlags, 
  ID3D11DeviceContext3 ** ppDeferredContext
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ContextFlags = ContextFlags;
  auto orig_ppDeferredContext = ppDeferredContext;
  auto ret = m_pID3D11Device3->CreateDeferredContext3(
    ContextFlags, 
    ppDeferredContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDeferredContext && *ppDeferredContext ) *ppDeferredContext = getWrapper<ID3D11DeviceContext3, WrappedID3D11DeviceContext4>(*ppDeferredContext);
  dumpMethodEvent((void*)this, "ID3D11Device3", "CreateDeferredContext3", &ret, {
    {"ContextFlags", {(void*)&orig_ContextFlags, (void*)&ContextFlags}},
    {"ppDeferredContext", {(void*)&orig_ppDeferredContext, (void*)&ppDeferredContext}},
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::WriteToSubresource(
  ID3D11Resource * pDstResource, 
  UINT DstSubresource, 
  const D3D11_BOX * pDstBox, 
  const void * pSrcData, 
  UINT SrcRowPitch, 
  UINT SrcDepthPitch
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstResource = pDstResource;
  auto orig_DstSubresource = DstSubresource;
  auto orig_pDstBox = pDstBox;
  auto orig_pSrcData = pSrcData;
  auto orig_SrcRowPitch = SrcRowPitch;
  auto orig_SrcDepthPitch = SrcDepthPitch;
  auto unwrapped_pDstResource = unwrap(pDstResource);
  auto unwrapped_pDstBox = unwrap(pDstBox);
  auto unwrapped_pSrcData = unwrap(pSrcData);
  m_pID3D11Device3->WriteToSubresource(
    unwrapped_pDstResource, 
    DstSubresource, 
    unwrapped_pDstBox, 
    unwrapped_pSrcData, 
    SrcRowPitch, 
    SrcDepthPitch
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device3", "WriteToSubresource", nullptr, {
    {"pDstResource", {(void*)&orig_pDstResource, (void*)&pDstResource}},
    {"DstSubresource", {(void*)&orig_DstSubresource, (void*)&DstSubresource}},
    {"pDstBox", {(void*)&orig_pDstBox, (void*)&pDstBox}},
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcRowPitch", {(void*)&orig_SrcRowPitch, (void*)&SrcRowPitch}},
    {"SrcDepthPitch", {(void*)&orig_SrcDepthPitch, (void*)&SrcDepthPitch}},
  });
}
void __stdcall WrappedID3D11Device5::ReadFromSubresource(
  void * pDstData, 
  UINT DstRowPitch, 
  UINT DstDepthPitch, 
  ID3D11Resource * pSrcResource, 
  UINT SrcSubresource, 
  const D3D11_BOX * pSrcBox
) {
  assert(m_pID3D11Device3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDstData = pDstData;
  auto orig_DstRowPitch = DstRowPitch;
  auto orig_DstDepthPitch = DstDepthPitch;
  auto orig_pSrcResource = pSrcResource;
  auto orig_SrcSubresource = SrcSubresource;
  auto orig_pSrcBox = pSrcBox;
  auto unwrapped_pSrcResource = unwrap(pSrcResource);
  auto unwrapped_pSrcBox = unwrap(pSrcBox);
  m_pID3D11Device3->ReadFromSubresource(
    pDstData, 
    DstRowPitch, 
    DstDepthPitch, 
    unwrapped_pSrcResource, 
    SrcSubresource, 
    unwrapped_pSrcBox
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device3", "ReadFromSubresource", nullptr, {
    {"pDstData", {(void*)&orig_pDstData, (void*)&pDstData}},
    {"DstRowPitch", {(void*)&orig_DstRowPitch, (void*)&DstRowPitch}},
    {"DstDepthPitch", {(void*)&orig_DstDepthPitch, (void*)&DstDepthPitch}},
    {"pSrcResource", {(void*)&orig_pSrcResource, (void*)&pSrcResource}},
    {"SrcSubresource", {(void*)&orig_SrcSubresource, (void*)&SrcSubresource}},
    {"pSrcBox", {(void*)&orig_pSrcBox, (void*)&pSrcBox}},
  });
}
void __stdcall WrappedID3D11Device5::GetImmediateContext2(
  ID3D11DeviceContext2 ** ppImmediateContext
) {
  assert(m_pID3D11Device2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppImmediateContext = ppImmediateContext;
  m_pID3D11Device2->GetImmediateContext2(
    ppImmediateContext
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppImmediateContext && *ppImmediateContext ) *ppImmediateContext = getWrapper<ID3D11DeviceContext2, WrappedID3D11DeviceContext4>(*ppImmediateContext);
  dumpMethodEvent((void*)this, "ID3D11Device2", "GetImmediateContext2", nullptr, {
    {"ppImmediateContext", {(void*)&orig_ppImmediateContext, (void*)&ppImmediateContext}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::CreateDeferredContext2(
  UINT ContextFlags, 
  ID3D11DeviceContext2 ** ppDeferredContext
) {
  assert(m_pID3D11Device2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ContextFlags = ContextFlags;
  auto orig_ppDeferredContext = ppDeferredContext;
  auto ret = m_pID3D11Device2->CreateDeferredContext2(
    ContextFlags, 
    ppDeferredContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDeferredContext && *ppDeferredContext ) *ppDeferredContext = getWrapper<ID3D11DeviceContext2, WrappedID3D11DeviceContext4>(*ppDeferredContext);
  dumpMethodEvent((void*)this, "ID3D11Device2", "CreateDeferredContext2", &ret, {
    {"ContextFlags", {(void*)&orig_ContextFlags, (void*)&ContextFlags}},
    {"ppDeferredContext", {(void*)&orig_ppDeferredContext, (void*)&ppDeferredContext}},
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::GetResourceTiling(
  ID3D11Resource * pTiledResource, 
  UINT * pNumTilesForEntireResource, 
  D3D11_PACKED_MIP_DESC * pPackedMipDesc, 
  D3D11_TILE_SHAPE * pStandardTileShapeForNonPackedMips, 
  UINT * pNumSubresourceTilings, 
  UINT FirstSubresourceTilingToGet, 
  D3D11_SUBRESOURCE_TILING * pSubresourceTilingsForNonPackedMips
) {
  assert(m_pID3D11Device2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pTiledResource = pTiledResource;
  auto orig_pNumTilesForEntireResource = pNumTilesForEntireResource;
  auto orig_pPackedMipDesc = pPackedMipDesc;
  auto orig_pStandardTileShapeForNonPackedMips = pStandardTileShapeForNonPackedMips;
  auto orig_pNumSubresourceTilings = pNumSubresourceTilings;
  auto orig_FirstSubresourceTilingToGet = FirstSubresourceTilingToGet;
  auto orig_pSubresourceTilingsForNonPackedMips = pSubresourceTilingsForNonPackedMips;
  auto unwrapped_pTiledResource = unwrap(pTiledResource);
  auto unwrapped_pNumSubresourceTilings = unwrap(pNumSubresourceTilings);
  m_pID3D11Device2->GetResourceTiling(
    unwrapped_pTiledResource, 
    pNumTilesForEntireResource, 
    pPackedMipDesc, 
    pStandardTileShapeForNonPackedMips, 
    unwrapped_pNumSubresourceTilings, 
    FirstSubresourceTilingToGet, 
    pSubresourceTilingsForNonPackedMips
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device2", "GetResourceTiling", nullptr, {
    {"pTiledResource", {(void*)&orig_pTiledResource, (void*)&pTiledResource}},
    {"pNumTilesForEntireResource", {(void*)&orig_pNumTilesForEntireResource, (void*)&pNumTilesForEntireResource}},
    {"pPackedMipDesc", {(void*)&orig_pPackedMipDesc, (void*)&pPackedMipDesc}},
    {"pStandardTileShapeForNonPackedMips", {(void*)&orig_pStandardTileShapeForNonPackedMips, (void*)&pStandardTileShapeForNonPackedMips}},
    {"pNumSubresourceTilings", {(void*)&orig_pNumSubresourceTilings, (void*)&pNumSubresourceTilings}},
    {"FirstSubresourceTilingToGet", {(void*)&orig_FirstSubresourceTilingToGet, (void*)&FirstSubresourceTilingToGet}},
    {"pSubresourceTilingsForNonPackedMips", {(void*)&orig_pSubresourceTilingsForNonPackedMips, (void*)&pSubresourceTilingsForNonPackedMips}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::CheckMultisampleQualityLevels1(
  DXGI_FORMAT Format, 
  UINT SampleCount, 
  UINT Flags, 
  UINT * pNumQualityLevels
) {
  assert(m_pID3D11Device2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Format = Format;
  auto orig_SampleCount = SampleCount;
  auto orig_Flags = Flags;
  auto orig_pNumQualityLevels = pNumQualityLevels;
  auto ret = m_pID3D11Device2->CheckMultisampleQualityLevels1(
    Format, 
    SampleCount, 
    Flags, 
    pNumQualityLevels
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device2", "CheckMultisampleQualityLevels1", &ret, {
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"SampleCount", {(void*)&orig_SampleCount, (void*)&SampleCount}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pNumQualityLevels", {(void*)&orig_pNumQualityLevels, (void*)&pNumQualityLevels}},
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::GetImmediateContext1(
  ID3D11DeviceContext1 ** ppImmediateContext
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppImmediateContext = ppImmediateContext;
  m_pID3D11Device1->GetImmediateContext1(
    ppImmediateContext
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppImmediateContext && *ppImmediateContext ) *ppImmediateContext = getWrapper<ID3D11DeviceContext1, WrappedID3D11DeviceContext4>(*ppImmediateContext);
  dumpMethodEvent((void*)this, "ID3D11Device1", "GetImmediateContext1", nullptr, {
    {"ppImmediateContext", {(void*)&orig_ppImmediateContext, (void*)&ppImmediateContext}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::CreateDeferredContext1(
  UINT ContextFlags, 
  ID3D11DeviceContext1 ** ppDeferredContext
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ContextFlags = ContextFlags;
  auto orig_ppDeferredContext = ppDeferredContext;
  auto ret = m_pID3D11Device1->CreateDeferredContext1(
    ContextFlags, 
    ppDeferredContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDeferredContext && *ppDeferredContext ) *ppDeferredContext = getWrapper<ID3D11DeviceContext1, WrappedID3D11DeviceContext4>(*ppDeferredContext);
  dumpMethodEvent((void*)this, "ID3D11Device1", "CreateDeferredContext1", &ret, {
    {"ContextFlags", {(void*)&orig_ContextFlags, (void*)&ContextFlags}},
    {"ppDeferredContext", {(void*)&orig_ppDeferredContext, (void*)&ppDeferredContext}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateBlendState1(
  const D3D11_BLEND_DESC1 * pBlendStateDesc, 
  ID3D11BlendState1 ** ppBlendState
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBlendStateDesc = pBlendStateDesc;
  auto orig_ppBlendState = ppBlendState;
  auto unwrapped_pBlendStateDesc = unwrap(pBlendStateDesc);
  auto ret = m_pID3D11Device1->CreateBlendState1(
    unwrapped_pBlendStateDesc, 
    ppBlendState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppBlendState && *ppBlendState ) *ppBlendState = getWrapper<ID3D11BlendState1, WrappedID3D11BlendState1>(*ppBlendState);
  dumpMethodEvent((void*)this, "ID3D11Device1", "CreateBlendState1", &ret, {
    {"pBlendStateDesc", {(void*)&orig_pBlendStateDesc, (void*)&pBlendStateDesc}},
    {"ppBlendState", {(void*)&orig_ppBlendState, (void*)&ppBlendState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateRasterizerState1(
  const D3D11_RASTERIZER_DESC1 * pRasterizerDesc, 
  ID3D11RasterizerState1 ** ppRasterizerState
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRasterizerDesc = pRasterizerDesc;
  auto orig_ppRasterizerState = ppRasterizerState;
  auto unwrapped_pRasterizerDesc = unwrap(pRasterizerDesc);
  auto ret = m_pID3D11Device1->CreateRasterizerState1(
    unwrapped_pRasterizerDesc, 
    ppRasterizerState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppRasterizerState && *ppRasterizerState ) *ppRasterizerState = getWrapper<ID3D11RasterizerState1, WrappedID3D11RasterizerState2>(*ppRasterizerState);
  dumpMethodEvent((void*)this, "ID3D11Device1", "CreateRasterizerState1", &ret, {
    {"pRasterizerDesc", {(void*)&orig_pRasterizerDesc, (void*)&pRasterizerDesc}},
    {"ppRasterizerState", {(void*)&orig_ppRasterizerState, (void*)&ppRasterizerState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateDeviceContextState(
  UINT Flags, 
  const D3D_FEATURE_LEVEL * pFeatureLevels, 
  UINT FeatureLevels, 
  UINT SDKVersion, 
  const IID & EmulatedInterface, 
  D3D_FEATURE_LEVEL * pChosenFeatureLevel, 
  ID3DDeviceContextState ** ppContextState
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Flags = Flags;
  auto orig_pFeatureLevels = pFeatureLevels;
  auto orig_FeatureLevels = FeatureLevels;
  auto orig_SDKVersion = SDKVersion;
  auto orig_EmulatedInterface = EmulatedInterface;
  auto orig_pChosenFeatureLevel = pChosenFeatureLevel;
  auto orig_ppContextState = ppContextState;
  auto ret = m_pID3D11Device1->CreateDeviceContextState(
    Flags, 
    pFeatureLevels, 
    FeatureLevels, 
    SDKVersion, 
    EmulatedInterface, 
    pChosenFeatureLevel, 
    ppContextState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppContextState && *ppContextState ) *ppContextState = getWrapper<ID3DDeviceContextState, WrappedID3DDeviceContextState>(*ppContextState);
  dumpMethodEvent((void*)this, "ID3D11Device1", "CreateDeviceContextState", &ret, {
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pFeatureLevels", {(void*)&orig_pFeatureLevels, (void*)&pFeatureLevels}},
    {"FeatureLevels", {(void*)&orig_FeatureLevels, (void*)&FeatureLevels}},
    {"SDKVersion", {(void*)&orig_SDKVersion, (void*)&SDKVersion}},
    {"EmulatedInterface", {(void*)&orig_EmulatedInterface, (void*)&EmulatedInterface}},
    {"pChosenFeatureLevel", {(void*)&orig_pChosenFeatureLevel, (void*)&pChosenFeatureLevel}},
    {"ppContextState", {(void*)&orig_ppContextState, (void*)&ppContextState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::OpenSharedResource1(
  HANDLE hResource, 
  const IID & returnedInterface, 
  void ** ppResource
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hResource = hResource;
  auto orig_returnedInterface = returnedInterface;
  auto orig_ppResource = ppResource;
  auto ret = m_pID3D11Device1->OpenSharedResource1(
    hResource, 
    returnedInterface, 
    ppResource
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(returnedInterface, (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11Device1", "OpenSharedResource1", &ret, {
    {"hResource", {(void*)&orig_hResource, (void*)&hResource}},
    {"returnedInterface", {(void*)&orig_returnedInterface, (void*)&returnedInterface}},
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::OpenSharedResourceByName(
  LPCWSTR lpName, 
  DWORD dwDesiredAccess, 
  const IID & returnedInterface, 
  void ** ppResource
) {
  assert(m_pID3D11Device1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_lpName = lpName;
  auto orig_dwDesiredAccess = dwDesiredAccess;
  auto orig_returnedInterface = returnedInterface;
  auto orig_ppResource = ppResource;
  auto ret = m_pID3D11Device1->OpenSharedResourceByName(
    lpName, 
    dwDesiredAccess, 
    returnedInterface, 
    ppResource
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(returnedInterface, (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11Device1", "OpenSharedResourceByName", &ret, {
    {"lpName", {(void*)&orig_lpName, (void*)&lpName}},
    {"dwDesiredAccess", {(void*)&orig_dwDesiredAccess, (void*)&dwDesiredAccess}},
    {"returnedInterface", {(void*)&orig_returnedInterface, (void*)&returnedInterface}},
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateBuffer(
  const D3D11_BUFFER_DESC * pDesc, 
  const D3D11_SUBRESOURCE_DATA * pInitialData, 
  ID3D11Buffer ** ppBuffer
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_pInitialData = pInitialData;
  auto orig_ppBuffer = ppBuffer;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pInitialData = unwrap(pInitialData);
  auto ret = m_pID3D11Device->CreateBuffer(
    unwrapped_pDesc, 
    unwrapped_pInitialData, 
    ppBuffer
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppBuffer && *ppBuffer ) *ppBuffer = getWrapper<ID3D11Buffer, WrappedID3D11Buffer>(*ppBuffer);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateBuffer", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pInitialData", {(void*)&orig_pInitialData, (void*)&pInitialData}},
    {"ppBuffer", {(void*)&orig_ppBuffer, (void*)&ppBuffer}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateTexture1D(
  const D3D11_TEXTURE1D_DESC * pDesc, 
  const D3D11_SUBRESOURCE_DATA * pInitialData, 
  ID3D11Texture1D ** ppTexture1D
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_pInitialData = pInitialData;
  auto orig_ppTexture1D = ppTexture1D;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateTexture1D(
    unwrapped_pDesc, 
    pInitialData, 
    ppTexture1D
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppTexture1D && *ppTexture1D ) *ppTexture1D = getWrapper<ID3D11Texture1D, WrappedID3D11Texture1D>(*ppTexture1D);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateTexture1D", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pInitialData", {(void*)&orig_pInitialData, (void*)&pInitialData}},
    {"ppTexture1D", {(void*)&orig_ppTexture1D, (void*)&ppTexture1D}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateTexture2D(
  const D3D11_TEXTURE2D_DESC * pDesc, 
  const D3D11_SUBRESOURCE_DATA * pInitialData, 
  ID3D11Texture2D ** ppTexture2D
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_pInitialData = pInitialData;
  auto orig_ppTexture2D = ppTexture2D;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateTexture2D(
    unwrapped_pDesc, 
    pInitialData, 
    ppTexture2D
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppTexture2D && *ppTexture2D ) *ppTexture2D = getWrapper<ID3D11Texture2D, WrappedID3D11Texture2D1>(*ppTexture2D);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateTexture2D", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pInitialData", {(void*)&orig_pInitialData, (void*)&pInitialData}},
    {"ppTexture2D", {(void*)&orig_ppTexture2D, (void*)&ppTexture2D}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateTexture3D(
  const D3D11_TEXTURE3D_DESC * pDesc, 
  const D3D11_SUBRESOURCE_DATA * pInitialData, 
  ID3D11Texture3D ** ppTexture3D
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_pInitialData = pInitialData;
  auto orig_ppTexture3D = ppTexture3D;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateTexture3D(
    unwrapped_pDesc, 
    pInitialData, 
    ppTexture3D
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppTexture3D && *ppTexture3D ) *ppTexture3D = getWrapper<ID3D11Texture3D, WrappedID3D11Texture3D1>(*ppTexture3D);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateTexture3D", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pInitialData", {(void*)&orig_pInitialData, (void*)&pInitialData}},
    {"ppTexture3D", {(void*)&orig_ppTexture3D, (void*)&ppTexture3D}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateShaderResourceView(
  ID3D11Resource * pResource, 
  const D3D11_SHADER_RESOURCE_VIEW_DESC * pDesc, 
  ID3D11ShaderResourceView ** ppSRView
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc = pDesc;
  auto orig_ppSRView = ppSRView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateShaderResourceView(
    unwrapped_pResource, 
    unwrapped_pDesc, 
    ppSRView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSRView && *ppSRView ) *ppSRView = getWrapper<ID3D11ShaderResourceView, WrappedID3D11ShaderResourceView1>(*ppSRView);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateShaderResourceView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppSRView", {(void*)&orig_ppSRView, (void*)&ppSRView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateUnorderedAccessView(
  ID3D11Resource * pResource, 
  const D3D11_UNORDERED_ACCESS_VIEW_DESC * pDesc, 
  ID3D11UnorderedAccessView ** ppUAView
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc = pDesc;
  auto orig_ppUAView = ppUAView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateUnorderedAccessView(
    unwrapped_pResource, 
    unwrapped_pDesc, 
    ppUAView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppUAView && *ppUAView ) *ppUAView = getWrapper<ID3D11UnorderedAccessView, WrappedID3D11UnorderedAccessView1>(*ppUAView);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateUnorderedAccessView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppUAView", {(void*)&orig_ppUAView, (void*)&ppUAView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateRenderTargetView(
  ID3D11Resource * pResource, 
  const D3D11_RENDER_TARGET_VIEW_DESC * pDesc, 
  ID3D11RenderTargetView ** ppRTView
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc = pDesc;
  auto orig_ppRTView = ppRTView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateRenderTargetView(
    unwrapped_pResource, 
    unwrapped_pDesc, 
    ppRTView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppRTView && *ppRTView ) *ppRTView = getWrapper<ID3D11RenderTargetView, WrappedID3D11RenderTargetView1>(*ppRTView);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateRenderTargetView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppRTView", {(void*)&orig_ppRTView, (void*)&ppRTView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateDepthStencilView(
  ID3D11Resource * pResource, 
  const D3D11_DEPTH_STENCIL_VIEW_DESC * pDesc, 
  ID3D11DepthStencilView ** ppDepthStencilView
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc = pDesc;
  auto orig_ppDepthStencilView = ppDepthStencilView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11Device->CreateDepthStencilView(
    unwrapped_pResource, 
    unwrapped_pDesc, 
    ppDepthStencilView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDepthStencilView && *ppDepthStencilView ) *ppDepthStencilView = getWrapper<ID3D11DepthStencilView, WrappedID3D11DepthStencilView>(*ppDepthStencilView);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateDepthStencilView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppDepthStencilView", {(void*)&orig_ppDepthStencilView, (void*)&ppDepthStencilView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateInputLayout(
  const D3D11_INPUT_ELEMENT_DESC * pInputElementDescs, 
  UINT NumElements, 
  const void * pShaderBytecodeWithInputSignature, 
  SIZE_T BytecodeLength, 
  ID3D11InputLayout ** ppInputLayout
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pInputElementDescs = pInputElementDescs;
  auto orig_NumElements = NumElements;
  auto orig_pShaderBytecodeWithInputSignature = pShaderBytecodeWithInputSignature;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_ppInputLayout = ppInputLayout;
  auto ret = m_pID3D11Device->CreateInputLayout(
    pInputElementDescs, 
    NumElements, 
    pShaderBytecodeWithInputSignature, 
    BytecodeLength, 
    ppInputLayout
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppInputLayout && *ppInputLayout ) *ppInputLayout = getWrapper<ID3D11InputLayout, WrappedID3D11InputLayout>(*ppInputLayout);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateInputLayout", &ret, {
    {"pInputElementDescs", {(void*)&orig_pInputElementDescs, (void*)&pInputElementDescs}},
    {"NumElements", {(void*)&orig_NumElements, (void*)&NumElements}},
    {"pShaderBytecodeWithInputSignature", {(void*)&orig_pShaderBytecodeWithInputSignature, (void*)&pShaderBytecodeWithInputSignature}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"ppInputLayout", {(void*)&orig_ppInputLayout, (void*)&ppInputLayout}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateVertexShader(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11VertexShader ** ppVertexShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppVertexShader = ppVertexShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreateVertexShader(
    pShaderBytecode, 
    BytecodeLength, 
    unwrapped_pClassLinkage, 
    ppVertexShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppVertexShader && *ppVertexShader ) *ppVertexShader = getWrapper<ID3D11VertexShader, WrappedID3D11VertexShader>(*ppVertexShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateVertexShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppVertexShader", {(void*)&orig_ppVertexShader, (void*)&ppVertexShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateGeometryShader(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11GeometryShader ** ppGeometryShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppGeometryShader = ppGeometryShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreateGeometryShader(
    pShaderBytecode, 
    BytecodeLength, 
    unwrapped_pClassLinkage, 
    ppGeometryShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppGeometryShader && *ppGeometryShader ) *ppGeometryShader = getWrapper<ID3D11GeometryShader, WrappedID3D11GeometryShader>(*ppGeometryShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateGeometryShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppGeometryShader", {(void*)&orig_ppGeometryShader, (void*)&ppGeometryShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateGeometryShaderWithStreamOutput(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  const D3D11_SO_DECLARATION_ENTRY * pSODeclaration, 
  UINT NumEntries, 
  const UINT * pBufferStrides, 
  UINT NumStrides, 
  UINT RasterizedStream, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11GeometryShader ** ppGeometryShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pSODeclaration = pSODeclaration;
  auto orig_NumEntries = NumEntries;
  auto orig_pBufferStrides = pBufferStrides;
  auto orig_NumStrides = NumStrides;
  auto orig_RasterizedStream = RasterizedStream;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppGeometryShader = ppGeometryShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreateGeometryShaderWithStreamOutput(
    pShaderBytecode, 
    BytecodeLength, 
    pSODeclaration, 
    NumEntries, 
    pBufferStrides, 
    NumStrides, 
    RasterizedStream, 
    unwrapped_pClassLinkage, 
    ppGeometryShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppGeometryShader && *ppGeometryShader ) *ppGeometryShader = getWrapper<ID3D11GeometryShader, WrappedID3D11GeometryShader>(*ppGeometryShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateGeometryShaderWithStreamOutput", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pSODeclaration", {(void*)&orig_pSODeclaration, (void*)&pSODeclaration}},
    {"NumEntries", {(void*)&orig_NumEntries, (void*)&NumEntries}},
    {"pBufferStrides", {(void*)&orig_pBufferStrides, (void*)&pBufferStrides}},
    {"NumStrides", {(void*)&orig_NumStrides, (void*)&NumStrides}},
    {"RasterizedStream", {(void*)&orig_RasterizedStream, (void*)&RasterizedStream}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppGeometryShader", {(void*)&orig_ppGeometryShader, (void*)&ppGeometryShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreatePixelShader(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11PixelShader ** ppPixelShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppPixelShader = ppPixelShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreatePixelShader(
    pShaderBytecode, 
    BytecodeLength, 
    unwrapped_pClassLinkage, 
    ppPixelShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppPixelShader && *ppPixelShader ) *ppPixelShader = getWrapper<ID3D11PixelShader, WrappedID3D11PixelShader>(*ppPixelShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreatePixelShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppPixelShader", {(void*)&orig_ppPixelShader, (void*)&ppPixelShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateHullShader(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11HullShader ** ppHullShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppHullShader = ppHullShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreateHullShader(
    pShaderBytecode, 
    BytecodeLength, 
    unwrapped_pClassLinkage, 
    ppHullShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppHullShader && *ppHullShader ) *ppHullShader = getWrapper<ID3D11HullShader, WrappedID3D11HullShader>(*ppHullShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateHullShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppHullShader", {(void*)&orig_ppHullShader, (void*)&ppHullShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateDomainShader(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11DomainShader ** ppDomainShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppDomainShader = ppDomainShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreateDomainShader(
    pShaderBytecode, 
    BytecodeLength, 
    unwrapped_pClassLinkage, 
    ppDomainShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDomainShader && *ppDomainShader ) *ppDomainShader = getWrapper<ID3D11DomainShader, WrappedID3D11DomainShader>(*ppDomainShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateDomainShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppDomainShader", {(void*)&orig_ppDomainShader, (void*)&ppDomainShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateComputeShader(
  const void * pShaderBytecode, 
  SIZE_T BytecodeLength, 
  ID3D11ClassLinkage * pClassLinkage, 
  ID3D11ComputeShader ** ppComputeShader
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_pClassLinkage = pClassLinkage;
  auto orig_ppComputeShader = ppComputeShader;
  auto unwrapped_pClassLinkage = unwrap(pClassLinkage);
  auto ret = m_pID3D11Device->CreateComputeShader(
    pShaderBytecode, 
    BytecodeLength, 
    unwrapped_pClassLinkage, 
    ppComputeShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppComputeShader && *ppComputeShader ) *ppComputeShader = getWrapper<ID3D11ComputeShader, WrappedID3D11ComputeShader>(*ppComputeShader);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateComputeShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"pClassLinkage", {(void*)&orig_pClassLinkage, (void*)&pClassLinkage}},
    {"ppComputeShader", {(void*)&orig_ppComputeShader, (void*)&ppComputeShader}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateClassLinkage(
  ID3D11ClassLinkage ** ppLinkage
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppLinkage = ppLinkage;
  auto ret = m_pID3D11Device->CreateClassLinkage(
    ppLinkage
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppLinkage && *ppLinkage ) *ppLinkage = getWrapper<ID3D11ClassLinkage, WrappedID3D11ClassLinkage>(*ppLinkage);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateClassLinkage", &ret, {
    {"ppLinkage", {(void*)&orig_ppLinkage, (void*)&ppLinkage}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateBlendState(
  const D3D11_BLEND_DESC * pBlendStateDesc, 
  ID3D11BlendState ** ppBlendState
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBlendStateDesc = pBlendStateDesc;
  auto orig_ppBlendState = ppBlendState;
  auto unwrapped_pBlendStateDesc = unwrap(pBlendStateDesc);
  auto ret = m_pID3D11Device->CreateBlendState(
    unwrapped_pBlendStateDesc, 
    ppBlendState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppBlendState && *ppBlendState ) *ppBlendState = getWrapper<ID3D11BlendState, WrappedID3D11BlendState1>(*ppBlendState);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateBlendState", &ret, {
    {"pBlendStateDesc", {(void*)&orig_pBlendStateDesc, (void*)&pBlendStateDesc}},
    {"ppBlendState", {(void*)&orig_ppBlendState, (void*)&ppBlendState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateDepthStencilState(
  const D3D11_DEPTH_STENCIL_DESC * pDepthStencilDesc, 
  ID3D11DepthStencilState ** ppDepthStencilState
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDepthStencilDesc = pDepthStencilDesc;
  auto orig_ppDepthStencilState = ppDepthStencilState;
  auto unwrapped_pDepthStencilDesc = unwrap(pDepthStencilDesc);
  auto ret = m_pID3D11Device->CreateDepthStencilState(
    unwrapped_pDepthStencilDesc, 
    ppDepthStencilState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDepthStencilState && *ppDepthStencilState ) *ppDepthStencilState = getWrapper<ID3D11DepthStencilState, WrappedID3D11DepthStencilState>(*ppDepthStencilState);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateDepthStencilState", &ret, {
    {"pDepthStencilDesc", {(void*)&orig_pDepthStencilDesc, (void*)&pDepthStencilDesc}},
    {"ppDepthStencilState", {(void*)&orig_ppDepthStencilState, (void*)&ppDepthStencilState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateRasterizerState(
  const D3D11_RASTERIZER_DESC * pRasterizerDesc, 
  ID3D11RasterizerState ** ppRasterizerState
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pRasterizerDesc = pRasterizerDesc;
  auto orig_ppRasterizerState = ppRasterizerState;
  auto unwrapped_pRasterizerDesc = unwrap(pRasterizerDesc);
  auto ret = m_pID3D11Device->CreateRasterizerState(
    unwrapped_pRasterizerDesc, 
    ppRasterizerState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppRasterizerState && *ppRasterizerState ) *ppRasterizerState = getWrapper<ID3D11RasterizerState, WrappedID3D11RasterizerState2>(*ppRasterizerState);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateRasterizerState", &ret, {
    {"pRasterizerDesc", {(void*)&orig_pRasterizerDesc, (void*)&pRasterizerDesc}},
    {"ppRasterizerState", {(void*)&orig_ppRasterizerState, (void*)&ppRasterizerState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateSamplerState(
  const D3D11_SAMPLER_DESC * pSamplerDesc, 
  ID3D11SamplerState ** ppSamplerState
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSamplerDesc = pSamplerDesc;
  auto orig_ppSamplerState = ppSamplerState;
  auto unwrapped_pSamplerDesc = unwrap(pSamplerDesc);
  auto ret = m_pID3D11Device->CreateSamplerState(
    unwrapped_pSamplerDesc, 
    ppSamplerState
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSamplerState && *ppSamplerState ) *ppSamplerState = getWrapper<ID3D11SamplerState, WrappedID3D11SamplerState>(*ppSamplerState);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateSamplerState", &ret, {
    {"pSamplerDesc", {(void*)&orig_pSamplerDesc, (void*)&pSamplerDesc}},
    {"ppSamplerState", {(void*)&orig_ppSamplerState, (void*)&ppSamplerState}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateQuery(
  const D3D11_QUERY_DESC * pQueryDesc, 
  ID3D11Query ** ppQuery
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pQueryDesc = pQueryDesc;
  auto orig_ppQuery = ppQuery;
  auto unwrapped_pQueryDesc = unwrap(pQueryDesc);
  auto ret = m_pID3D11Device->CreateQuery(
    unwrapped_pQueryDesc, 
    ppQuery
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppQuery && *ppQuery ) *ppQuery = getWrapper<ID3D11Query, WrappedID3D11Query1>(*ppQuery);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateQuery", &ret, {
    {"pQueryDesc", {(void*)&orig_pQueryDesc, (void*)&pQueryDesc}},
    {"ppQuery", {(void*)&orig_ppQuery, (void*)&ppQuery}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreatePredicate(
  const D3D11_QUERY_DESC * pPredicateDesc, 
  ID3D11Predicate ** ppPredicate
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pPredicateDesc = pPredicateDesc;
  auto orig_ppPredicate = ppPredicate;
  auto unwrapped_pPredicateDesc = unwrap(pPredicateDesc);
  auto ret = m_pID3D11Device->CreatePredicate(
    unwrapped_pPredicateDesc, 
    ppPredicate
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppPredicate && *ppPredicate ) *ppPredicate = getWrapper<ID3D11Predicate, WrappedID3D11Predicate>(*ppPredicate);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreatePredicate", &ret, {
    {"pPredicateDesc", {(void*)&orig_pPredicateDesc, (void*)&pPredicateDesc}},
    {"ppPredicate", {(void*)&orig_ppPredicate, (void*)&ppPredicate}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateCounter(
  const D3D11_COUNTER_DESC * pCounterDesc, 
  ID3D11Counter ** ppCounter
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCounterDesc = pCounterDesc;
  auto orig_ppCounter = ppCounter;
  auto unwrapped_pCounterDesc = unwrap(pCounterDesc);
  auto ret = m_pID3D11Device->CreateCounter(
    unwrapped_pCounterDesc, 
    ppCounter
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCounter && *ppCounter ) *ppCounter = getWrapper<ID3D11Counter, WrappedID3D11Counter>(*ppCounter);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateCounter", &ret, {
    {"pCounterDesc", {(void*)&orig_pCounterDesc, (void*)&pCounterDesc}},
    {"ppCounter", {(void*)&orig_ppCounter, (void*)&ppCounter}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CreateDeferredContext(
  UINT ContextFlags, 
  ID3D11DeviceContext ** ppDeferredContext
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ContextFlags = ContextFlags;
  auto orig_ppDeferredContext = ppDeferredContext;
  auto ret = m_pID3D11Device->CreateDeferredContext(
    ContextFlags, 
    ppDeferredContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDeferredContext && *ppDeferredContext ) *ppDeferredContext = getWrapper<ID3D11DeviceContext, WrappedID3D11DeviceContext4>(*ppDeferredContext);
  dumpMethodEvent((void*)this, "ID3D11Device", "CreateDeferredContext", &ret, {
    {"ContextFlags", {(void*)&orig_ContextFlags, (void*)&ContextFlags}},
    {"ppDeferredContext", {(void*)&orig_ppDeferredContext, (void*)&ppDeferredContext}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::OpenSharedResource(
  HANDLE hResource, 
  const IID & ReturnedInterface, 
  void ** ppResource
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_hResource = hResource;
  auto orig_ReturnedInterface = ReturnedInterface;
  auto orig_ppResource = ppResource;
  auto ret = m_pID3D11Device->OpenSharedResource(
    hResource, 
    ReturnedInterface, 
    ppResource
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(*ppResource)
    HandleWrap(ReturnedInterface, (void**)ppResource);
  dumpMethodEvent((void*)this, "ID3D11Device", "OpenSharedResource", &ret, {
    {"hResource", {(void*)&orig_hResource, (void*)&hResource}},
    {"ReturnedInterface", {(void*)&orig_ReturnedInterface, (void*)&ReturnedInterface}},
    {"ppResource", {(void*)&orig_ppResource, (void*)&ppResource}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CheckFormatSupport(
  DXGI_FORMAT Format, 
  UINT * pFormatSupport
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Format = Format;
  auto orig_pFormatSupport = pFormatSupport;
  auto ret = m_pID3D11Device->CheckFormatSupport(
    Format, 
    pFormatSupport
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "CheckFormatSupport", &ret, {
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"pFormatSupport", {(void*)&orig_pFormatSupport, (void*)&pFormatSupport}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CheckMultisampleQualityLevels(
  DXGI_FORMAT Format, 
  UINT SampleCount, 
  UINT * pNumQualityLevels
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Format = Format;
  auto orig_SampleCount = SampleCount;
  auto orig_pNumQualityLevels = pNumQualityLevels;
  auto ret = m_pID3D11Device->CheckMultisampleQualityLevels(
    Format, 
    SampleCount, 
    pNumQualityLevels
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "CheckMultisampleQualityLevels", &ret, {
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"SampleCount", {(void*)&orig_SampleCount, (void*)&SampleCount}},
    {"pNumQualityLevels", {(void*)&orig_pNumQualityLevels, (void*)&pNumQualityLevels}},
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::CheckCounterInfo(
  D3D11_COUNTER_INFO * pCounterInfo
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCounterInfo = pCounterInfo;
  m_pID3D11Device->CheckCounterInfo(
    pCounterInfo
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "CheckCounterInfo", nullptr, {
    {"pCounterInfo", {(void*)&orig_pCounterInfo, (void*)&pCounterInfo}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::CheckCounter(
  const D3D11_COUNTER_DESC * pDesc, 
  D3D11_COUNTER_TYPE * pType, 
  UINT * pActiveCounters, 
  LPSTR szName, 
  UINT * pNameLength, 
  LPSTR szUnits, 
  UINT * pUnitsLength, 
  LPSTR szDescription, 
  UINT * pDescriptionLength
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_pType = pType;
  auto orig_pActiveCounters = pActiveCounters;
  auto orig_szName = szName;
  auto orig_pNameLength = pNameLength;
  auto orig_szUnits = szUnits;
  auto orig_pUnitsLength = pUnitsLength;
  auto orig_szDescription = szDescription;
  auto orig_pDescriptionLength = pDescriptionLength;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto unwrapped_pNameLength = unwrap(pNameLength);
  auto unwrapped_pUnitsLength = unwrap(pUnitsLength);
  auto unwrapped_pDescriptionLength = unwrap(pDescriptionLength);
  auto ret = m_pID3D11Device->CheckCounter(
    unwrapped_pDesc, 
    pType, 
    pActiveCounters, 
    szName, 
    unwrapped_pNameLength, 
    szUnits, 
    unwrapped_pUnitsLength, 
    szDescription, 
    unwrapped_pDescriptionLength
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "CheckCounter", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pType", {(void*)&orig_pType, (void*)&pType}},
    {"pActiveCounters", {(void*)&orig_pActiveCounters, (void*)&pActiveCounters}},
    {"szName", {(void*)&orig_szName, (void*)&szName}},
    {"pNameLength", {(void*)&orig_pNameLength, (void*)&pNameLength}},
    {"szUnits", {(void*)&orig_szUnits, (void*)&szUnits}},
    {"pUnitsLength", {(void*)&orig_pUnitsLength, (void*)&pUnitsLength}},
    {"szDescription", {(void*)&orig_szDescription, (void*)&szDescription}},
    {"pDescriptionLength", {(void*)&orig_pDescriptionLength, (void*)&pDescriptionLength}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::CheckFeatureSupport(
  D3D11_FEATURE Feature, 
  void * pFeatureSupportData, 
  UINT FeatureSupportDataSize
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Feature = Feature;
  auto orig_pFeatureSupportData = pFeatureSupportData;
  auto orig_FeatureSupportDataSize = FeatureSupportDataSize;
  auto ret = m_pID3D11Device->CheckFeatureSupport(
    Feature, 
    pFeatureSupportData, 
    FeatureSupportDataSize
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "CheckFeatureSupport", &ret, {
    {"Feature", {(void*)&orig_Feature, (void*)&Feature}},
    {"pFeatureSupportData", {(void*)&orig_pFeatureSupportData, (void*)&pFeatureSupportData}},
    {"FeatureSupportDataSize", {(void*)&orig_FeatureSupportDataSize, (void*)&FeatureSupportDataSize}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11Device->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11Device->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11Device->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
D3D_FEATURE_LEVEL __stdcall WrappedID3D11Device5::GetFeatureLevel() {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Device->GetFeatureLevel();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "GetFeatureLevel", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11Device5::GetCreationFlags() {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Device->GetCreationFlags();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "GetCreationFlags", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::GetDeviceRemovedReason() {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Device->GetDeviceRemovedReason();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "GetDeviceRemovedReason", &ret, {
  });
  return ret;
}
void __stdcall WrappedID3D11Device5::GetImmediateContext(
  ID3D11DeviceContext ** ppImmediateContext
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppImmediateContext = ppImmediateContext;
  m_pID3D11Device->GetImmediateContext(
    ppImmediateContext
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if (true && ppImmediateContext && *ppImmediateContext ) *ppImmediateContext = getWrapper<ID3D11DeviceContext, WrappedID3D11DeviceContext4>(*ppImmediateContext);
  dumpMethodEvent((void*)this, "ID3D11Device", "GetImmediateContext", nullptr, {
    {"ppImmediateContext", {(void*)&orig_ppImmediateContext, (void*)&ppImmediateContext}},
  });
}
HRESULT __stdcall WrappedID3D11Device5::SetExceptionMode(
  UINT RaiseFlags
) {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_RaiseFlags = RaiseFlags;
  auto ret = m_pID3D11Device->SetExceptionMode(
    RaiseFlags
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "SetExceptionMode", &ret, {
    {"RaiseFlags", {(void*)&orig_RaiseFlags, (void*)&RaiseFlags}},
  });
  return ret;
}
UINT __stdcall WrappedID3D11Device5::GetExceptionMode() {
  assert(m_pID3D11Device);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Device->GetExceptionMode();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Device", "GetExceptionMode", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Device5::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Device5)) {
      *ppvObject = (ID3D11Device5*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Device4)) {
      *ppvObject = (ID3D11Device4*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Device3)) {
      *ppvObject = (ID3D11Device3*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Device2)) {
      *ppvObject = (ID3D11Device2*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Device1)) {
      *ppvObject = (ID3D11Device1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11Device)) {
      *ppvObject = (ID3D11Device*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Device5::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Device5::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
void __stdcall WrappedID3D11Multithread::Enter() {
  assert(m_pID3D11Multithread);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11Multithread->Enter();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Multithread", "Enter", nullptr, {
  });
}
void __stdcall WrappedID3D11Multithread::Leave() {
  assert(m_pID3D11Multithread);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  m_pID3D11Multithread->Leave();
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Multithread", "Leave", nullptr, {
  });
}
BOOL __stdcall WrappedID3D11Multithread::SetMultithreadProtected(
  BOOL bMTProtect
) {
  assert(m_pID3D11Multithread);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_bMTProtect = bMTProtect;
  auto ret = m_pID3D11Multithread->SetMultithreadProtected(
    bMTProtect
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Multithread", "SetMultithreadProtected", &ret, {
    {"bMTProtect", {(void*)&orig_bMTProtect, (void*)&bMTProtect}},
  });
  return ret;
}
BOOL __stdcall WrappedID3D11Multithread::GetMultithreadProtected() {
  assert(m_pID3D11Multithread);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11Multithread->GetMultithreadProtected();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Multithread", "GetMultithreadProtected", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Multithread::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Multithread)) {
      *ppvObject = (ID3D11Multithread*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Multithread::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Multithread::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CheckFeatureSupport(
  D3D11_FEATURE_VIDEO Feature, 
  void * pFeatureSupportData, 
  UINT FeatureSupportDataSize
) {
  assert(m_pID3D11VideoDevice2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Feature = Feature;
  auto orig_pFeatureSupportData = pFeatureSupportData;
  auto orig_FeatureSupportDataSize = FeatureSupportDataSize;
  auto ret = m_pID3D11VideoDevice2->CheckFeatureSupport(
    Feature, 
    pFeatureSupportData, 
    FeatureSupportDataSize
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice2", "CheckFeatureSupport", &ret, {
    {"Feature", {(void*)&orig_Feature, (void*)&Feature}},
    {"pFeatureSupportData", {(void*)&orig_pFeatureSupportData, (void*)&pFeatureSupportData}},
    {"FeatureSupportDataSize", {(void*)&orig_FeatureSupportDataSize, (void*)&FeatureSupportDataSize}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::NegotiateCryptoSessionKeyExchangeMT(
  ID3D11CryptoSession * pCryptoSession, 
  D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS flags, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoDevice2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_flags = flags;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11VideoDevice2->NegotiateCryptoSessionKeyExchangeMT(
    unwrapped_pCryptoSession, 
    flags, 
    DataSize, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice2", "NegotiateCryptoSessionKeyExchangeMT", &ret, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"flags", {(void*)&orig_flags, (void*)&flags}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::GetCryptoSessionPrivateDataSize(
  const GUID * pCryptoType, 
  const GUID * pDecoderProfile, 
  const GUID * pKeyExchangeType, 
  UINT * pPrivateInputSize, 
  UINT * pPrivateOutputSize
) {
  assert(m_pID3D11VideoDevice1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoType = pCryptoType;
  auto orig_pDecoderProfile = pDecoderProfile;
  auto orig_pKeyExchangeType = pKeyExchangeType;
  auto orig_pPrivateInputSize = pPrivateInputSize;
  auto orig_pPrivateOutputSize = pPrivateOutputSize;
  auto unwrapped_pCryptoType = unwrap(pCryptoType);
  auto unwrapped_pDecoderProfile = unwrap(pDecoderProfile);
  auto unwrapped_pKeyExchangeType = unwrap(pKeyExchangeType);
  auto ret = m_pID3D11VideoDevice1->GetCryptoSessionPrivateDataSize(
    unwrapped_pCryptoType, 
    unwrapped_pDecoderProfile, 
    unwrapped_pKeyExchangeType, 
    pPrivateInputSize, 
    pPrivateOutputSize
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice1", "GetCryptoSessionPrivateDataSize", &ret, {
    {"pCryptoType", {(void*)&orig_pCryptoType, (void*)&pCryptoType}},
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
    {"pKeyExchangeType", {(void*)&orig_pKeyExchangeType, (void*)&pKeyExchangeType}},
    {"pPrivateInputSize", {(void*)&orig_pPrivateInputSize, (void*)&pPrivateInputSize}},
    {"pPrivateOutputSize", {(void*)&orig_pPrivateOutputSize, (void*)&pPrivateOutputSize}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::GetVideoDecoderCaps(
  const GUID * pDecoderProfile, 
  UINT SampleWidth, 
  UINT SampleHeight, 
  const DXGI_RATIONAL * pFrameRate, 
  UINT BitRate, 
  const GUID * pCryptoType, 
  UINT * pDecoderCaps
) {
  assert(m_pID3D11VideoDevice1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoderProfile = pDecoderProfile;
  auto orig_SampleWidth = SampleWidth;
  auto orig_SampleHeight = SampleHeight;
  auto orig_pFrameRate = pFrameRate;
  auto orig_BitRate = BitRate;
  auto orig_pCryptoType = pCryptoType;
  auto orig_pDecoderCaps = pDecoderCaps;
  auto unwrapped_pDecoderProfile = unwrap(pDecoderProfile);
  auto unwrapped_pFrameRate = unwrap(pFrameRate);
  auto unwrapped_pCryptoType = unwrap(pCryptoType);
  auto ret = m_pID3D11VideoDevice1->GetVideoDecoderCaps(
    unwrapped_pDecoderProfile, 
    SampleWidth, 
    SampleHeight, 
    unwrapped_pFrameRate, 
    BitRate, 
    unwrapped_pCryptoType, 
    pDecoderCaps
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice1", "GetVideoDecoderCaps", &ret, {
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
    {"SampleWidth", {(void*)&orig_SampleWidth, (void*)&SampleWidth}},
    {"SampleHeight", {(void*)&orig_SampleHeight, (void*)&SampleHeight}},
    {"pFrameRate", {(void*)&orig_pFrameRate, (void*)&pFrameRate}},
    {"BitRate", {(void*)&orig_BitRate, (void*)&BitRate}},
    {"pCryptoType", {(void*)&orig_pCryptoType, (void*)&pCryptoType}},
    {"pDecoderCaps", {(void*)&orig_pDecoderCaps, (void*)&pDecoderCaps}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CheckVideoDecoderDownsampling(
  const D3D11_VIDEO_DECODER_DESC * pInputDesc, 
  DXGI_COLOR_SPACE_TYPE InputColorSpace, 
  const D3D11_VIDEO_DECODER_CONFIG * pInputConfig, 
  const DXGI_RATIONAL * pFrameRate, 
  const D3D11_VIDEO_SAMPLE_DESC * pOutputDesc, 
  BOOL * pSupported, 
  BOOL * pRealTimeHint
) {
  assert(m_pID3D11VideoDevice1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pInputDesc = pInputDesc;
  auto orig_InputColorSpace = InputColorSpace;
  auto orig_pInputConfig = pInputConfig;
  auto orig_pFrameRate = pFrameRate;
  auto orig_pOutputDesc = pOutputDesc;
  auto orig_pSupported = pSupported;
  auto orig_pRealTimeHint = pRealTimeHint;
  auto unwrapped_pInputDesc = unwrap(pInputDesc);
  auto unwrapped_pInputConfig = unwrap(pInputConfig);
  auto unwrapped_pFrameRate = unwrap(pFrameRate);
  auto unwrapped_pOutputDesc = unwrap(pOutputDesc);
  auto ret = m_pID3D11VideoDevice1->CheckVideoDecoderDownsampling(
    unwrapped_pInputDesc, 
    InputColorSpace, 
    unwrapped_pInputConfig, 
    unwrapped_pFrameRate, 
    unwrapped_pOutputDesc, 
    pSupported, 
    pRealTimeHint
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice1", "CheckVideoDecoderDownsampling", &ret, {
    {"pInputDesc", {(void*)&orig_pInputDesc, (void*)&pInputDesc}},
    {"InputColorSpace", {(void*)&orig_InputColorSpace, (void*)&InputColorSpace}},
    {"pInputConfig", {(void*)&orig_pInputConfig, (void*)&pInputConfig}},
    {"pFrameRate", {(void*)&orig_pFrameRate, (void*)&pFrameRate}},
    {"pOutputDesc", {(void*)&orig_pOutputDesc, (void*)&pOutputDesc}},
    {"pSupported", {(void*)&orig_pSupported, (void*)&pSupported}},
    {"pRealTimeHint", {(void*)&orig_pRealTimeHint, (void*)&pRealTimeHint}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::RecommendVideoDecoderDownsampleParameters(
  const D3D11_VIDEO_DECODER_DESC * pInputDesc, 
  DXGI_COLOR_SPACE_TYPE InputColorSpace, 
  const D3D11_VIDEO_DECODER_CONFIG * pInputConfig, 
  const DXGI_RATIONAL * pFrameRate, 
  D3D11_VIDEO_SAMPLE_DESC * pRecommendedOutputDesc
) {
  assert(m_pID3D11VideoDevice1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pInputDesc = pInputDesc;
  auto orig_InputColorSpace = InputColorSpace;
  auto orig_pInputConfig = pInputConfig;
  auto orig_pFrameRate = pFrameRate;
  auto orig_pRecommendedOutputDesc = pRecommendedOutputDesc;
  auto unwrapped_pInputDesc = unwrap(pInputDesc);
  auto unwrapped_pInputConfig = unwrap(pInputConfig);
  auto unwrapped_pFrameRate = unwrap(pFrameRate);
  auto ret = m_pID3D11VideoDevice1->RecommendVideoDecoderDownsampleParameters(
    unwrapped_pInputDesc, 
    InputColorSpace, 
    unwrapped_pInputConfig, 
    unwrapped_pFrameRate, 
    pRecommendedOutputDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice1", "RecommendVideoDecoderDownsampleParameters", &ret, {
    {"pInputDesc", {(void*)&orig_pInputDesc, (void*)&pInputDesc}},
    {"InputColorSpace", {(void*)&orig_InputColorSpace, (void*)&InputColorSpace}},
    {"pInputConfig", {(void*)&orig_pInputConfig, (void*)&pInputConfig}},
    {"pFrameRate", {(void*)&orig_pFrameRate, (void*)&pFrameRate}},
    {"pRecommendedOutputDesc", {(void*)&orig_pRecommendedOutputDesc, (void*)&pRecommendedOutputDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateVideoDecoder(
  const D3D11_VIDEO_DECODER_DESC * pVideoDesc, 
  const D3D11_VIDEO_DECODER_CONFIG * pConfig, 
  ID3D11VideoDecoder ** ppDecoder
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoDesc = pVideoDesc;
  auto orig_pConfig = pConfig;
  auto orig_ppDecoder = ppDecoder;
  auto unwrapped_pVideoDesc = unwrap(pVideoDesc);
  auto unwrapped_pConfig = unwrap(pConfig);
  auto ret = m_pID3D11VideoDevice->CreateVideoDecoder(
    unwrapped_pVideoDesc, 
    unwrapped_pConfig, 
    ppDecoder
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDecoder && *ppDecoder ) *ppDecoder = getWrapper<ID3D11VideoDecoder, WrappedID3D11VideoDecoder>(*ppDecoder);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateVideoDecoder", &ret, {
    {"pVideoDesc", {(void*)&orig_pVideoDesc, (void*)&pVideoDesc}},
    {"pConfig", {(void*)&orig_pConfig, (void*)&pConfig}},
    {"ppDecoder", {(void*)&orig_ppDecoder, (void*)&ppDecoder}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateVideoProcessor(
  ID3D11VideoProcessorEnumerator * pEnum, 
  UINT RateConversionIndex, 
  ID3D11VideoProcessor ** ppVideoProcessor
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pEnum = pEnum;
  auto orig_RateConversionIndex = RateConversionIndex;
  auto orig_ppVideoProcessor = ppVideoProcessor;
  auto unwrapped_pEnum = unwrap(pEnum);
  auto ret = m_pID3D11VideoDevice->CreateVideoProcessor(
    unwrapped_pEnum, 
    RateConversionIndex, 
    ppVideoProcessor
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppVideoProcessor && *ppVideoProcessor ) *ppVideoProcessor = getWrapper<ID3D11VideoProcessor, WrappedID3D11VideoProcessor>(*ppVideoProcessor);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateVideoProcessor", &ret, {
    {"pEnum", {(void*)&orig_pEnum, (void*)&pEnum}},
    {"RateConversionIndex", {(void*)&orig_RateConversionIndex, (void*)&RateConversionIndex}},
    {"ppVideoProcessor", {(void*)&orig_ppVideoProcessor, (void*)&ppVideoProcessor}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateAuthenticatedChannel(
  D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType, 
  ID3D11AuthenticatedChannel ** ppAuthenticatedChannel
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ChannelType = ChannelType;
  auto orig_ppAuthenticatedChannel = ppAuthenticatedChannel;
  auto ret = m_pID3D11VideoDevice->CreateAuthenticatedChannel(
    ChannelType, 
    ppAuthenticatedChannel
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppAuthenticatedChannel && *ppAuthenticatedChannel ) *ppAuthenticatedChannel = getWrapper<ID3D11AuthenticatedChannel, WrappedID3D11AuthenticatedChannel>(*ppAuthenticatedChannel);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateAuthenticatedChannel", &ret, {
    {"ChannelType", {(void*)&orig_ChannelType, (void*)&ChannelType}},
    {"ppAuthenticatedChannel", {(void*)&orig_ppAuthenticatedChannel, (void*)&ppAuthenticatedChannel}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateCryptoSession(
  const GUID * pCryptoType, 
  const GUID * pDecoderProfile, 
  const GUID * pKeyExchangeType, 
  ID3D11CryptoSession ** ppCryptoSession
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoType = pCryptoType;
  auto orig_pDecoderProfile = pDecoderProfile;
  auto orig_pKeyExchangeType = pKeyExchangeType;
  auto orig_ppCryptoSession = ppCryptoSession;
  auto unwrapped_pCryptoType = unwrap(pCryptoType);
  auto unwrapped_pDecoderProfile = unwrap(pDecoderProfile);
  auto unwrapped_pKeyExchangeType = unwrap(pKeyExchangeType);
  auto ret = m_pID3D11VideoDevice->CreateCryptoSession(
    unwrapped_pCryptoType, 
    unwrapped_pDecoderProfile, 
    unwrapped_pKeyExchangeType, 
    ppCryptoSession
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCryptoSession && *ppCryptoSession ) *ppCryptoSession = getWrapper<ID3D11CryptoSession, WrappedID3D11CryptoSession>(*ppCryptoSession);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateCryptoSession", &ret, {
    {"pCryptoType", {(void*)&orig_pCryptoType, (void*)&pCryptoType}},
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
    {"pKeyExchangeType", {(void*)&orig_pKeyExchangeType, (void*)&pKeyExchangeType}},
    {"ppCryptoSession", {(void*)&orig_ppCryptoSession, (void*)&ppCryptoSession}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateVideoDecoderOutputView(
  ID3D11Resource * pResource, 
  const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC * pDesc, 
  ID3D11VideoDecoderOutputView ** ppVDOVView
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pDesc = pDesc;
  auto orig_ppVDOVView = ppVDOVView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11VideoDevice->CreateVideoDecoderOutputView(
    unwrapped_pResource, 
    unwrapped_pDesc, 
    ppVDOVView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppVDOVView && *ppVDOVView ) *ppVDOVView = getWrapper<ID3D11VideoDecoderOutputView, WrappedID3D11VideoDecoderOutputView>(*ppVDOVView);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateVideoDecoderOutputView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppVDOVView", {(void*)&orig_ppVDOVView, (void*)&ppVDOVView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateVideoProcessorInputView(
  ID3D11Resource * pResource, 
  ID3D11VideoProcessorEnumerator * pEnum, 
  const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC * pDesc, 
  ID3D11VideoProcessorInputView ** ppVPIView
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pEnum = pEnum;
  auto orig_pDesc = pDesc;
  auto orig_ppVPIView = ppVPIView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pEnum = unwrap(pEnum);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11VideoDevice->CreateVideoProcessorInputView(
    unwrapped_pResource, 
    unwrapped_pEnum, 
    unwrapped_pDesc, 
    ppVPIView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppVPIView && *ppVPIView ) *ppVPIView = getWrapper<ID3D11VideoProcessorInputView, WrappedID3D11VideoProcessorInputView>(*ppVPIView);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateVideoProcessorInputView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pEnum", {(void*)&orig_pEnum, (void*)&pEnum}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppVPIView", {(void*)&orig_ppVPIView, (void*)&ppVPIView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateVideoProcessorOutputView(
  ID3D11Resource * pResource, 
  ID3D11VideoProcessorEnumerator * pEnum, 
  const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC * pDesc, 
  ID3D11VideoProcessorOutputView ** ppVPOView
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pResource = pResource;
  auto orig_pEnum = pEnum;
  auto orig_pDesc = pDesc;
  auto orig_ppVPOView = ppVPOView;
  auto unwrapped_pResource = unwrap(pResource);
  auto unwrapped_pEnum = unwrap(pEnum);
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11VideoDevice->CreateVideoProcessorOutputView(
    unwrapped_pResource, 
    unwrapped_pEnum, 
    unwrapped_pDesc, 
    ppVPOView
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppVPOView && *ppVPOView ) *ppVPOView = getWrapper<ID3D11VideoProcessorOutputView, WrappedID3D11VideoProcessorOutputView>(*ppVPOView);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateVideoProcessorOutputView", &ret, {
    {"pResource", {(void*)&orig_pResource, (void*)&pResource}},
    {"pEnum", {(void*)&orig_pEnum, (void*)&pEnum}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppVPOView", {(void*)&orig_ppVPOView, (void*)&ppVPOView}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CreateVideoProcessorEnumerator(
  const D3D11_VIDEO_PROCESSOR_CONTENT_DESC * pDesc, 
  ID3D11VideoProcessorEnumerator ** ppEnum
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_ppEnum = ppEnum;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11VideoDevice->CreateVideoProcessorEnumerator(
    unwrapped_pDesc, 
    ppEnum
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppEnum && *ppEnum ) *ppEnum = getWrapper<ID3D11VideoProcessorEnumerator, WrappedID3D11VideoProcessorEnumerator1>(*ppEnum);
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CreateVideoProcessorEnumerator", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"ppEnum", {(void*)&orig_ppEnum, (void*)&ppEnum}},
  });
  return ret;
}
UINT __stdcall WrappedID3D11VideoDevice2::GetVideoDecoderProfileCount() {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11VideoDevice->GetVideoDecoderProfileCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "GetVideoDecoderProfileCount", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::GetVideoDecoderProfile(
  UINT Index, 
  GUID * pDecoderProfile
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto orig_pDecoderProfile = pDecoderProfile;
  auto ret = m_pID3D11VideoDevice->GetVideoDecoderProfile(
    Index, 
    pDecoderProfile
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "GetVideoDecoderProfile", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CheckVideoDecoderFormat(
  const GUID * pDecoderProfile, 
  DXGI_FORMAT Format, 
  BOOL * pSupported
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoderProfile = pDecoderProfile;
  auto orig_Format = Format;
  auto orig_pSupported = pSupported;
  auto unwrapped_pDecoderProfile = unwrap(pDecoderProfile);
  auto ret = m_pID3D11VideoDevice->CheckVideoDecoderFormat(
    unwrapped_pDecoderProfile, 
    Format, 
    pSupported
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CheckVideoDecoderFormat", &ret, {
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"pSupported", {(void*)&orig_pSupported, (void*)&pSupported}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::GetVideoDecoderConfigCount(
  const D3D11_VIDEO_DECODER_DESC * pDesc, 
  UINT * pCount
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_pCount = pCount;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11VideoDevice->GetVideoDecoderConfigCount(
    unwrapped_pDesc, 
    pCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "GetVideoDecoderConfigCount", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"pCount", {(void*)&orig_pCount, (void*)&pCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::GetVideoDecoderConfig(
  const D3D11_VIDEO_DECODER_DESC * pDesc, 
  UINT Index, 
  D3D11_VIDEO_DECODER_CONFIG * pConfig
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto orig_Index = Index;
  auto orig_pConfig = pConfig;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11VideoDevice->GetVideoDecoderConfig(
    unwrapped_pDesc, 
    Index, 
    pConfig
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "GetVideoDecoderConfig", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
    {"Index", {(void*)&orig_Index, (void*)&Index}},
    {"pConfig", {(void*)&orig_pConfig, (void*)&pConfig}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::GetContentProtectionCaps(
  const GUID * pCryptoType, 
  const GUID * pDecoderProfile, 
  D3D11_VIDEO_CONTENT_PROTECTION_CAPS * pCaps
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoType = pCryptoType;
  auto orig_pDecoderProfile = pDecoderProfile;
  auto orig_pCaps = pCaps;
  auto unwrapped_pCryptoType = unwrap(pCryptoType);
  auto unwrapped_pDecoderProfile = unwrap(pDecoderProfile);
  auto ret = m_pID3D11VideoDevice->GetContentProtectionCaps(
    unwrapped_pCryptoType, 
    unwrapped_pDecoderProfile, 
    pCaps
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "GetContentProtectionCaps", &ret, {
    {"pCryptoType", {(void*)&orig_pCryptoType, (void*)&pCryptoType}},
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
    {"pCaps", {(void*)&orig_pCaps, (void*)&pCaps}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::CheckCryptoKeyExchange(
  const GUID * pCryptoType, 
  const GUID * pDecoderProfile, 
  UINT Index, 
  GUID * pKeyExchangeType
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoType = pCryptoType;
  auto orig_pDecoderProfile = pDecoderProfile;
  auto orig_Index = Index;
  auto orig_pKeyExchangeType = pKeyExchangeType;
  auto unwrapped_pCryptoType = unwrap(pCryptoType);
  auto unwrapped_pDecoderProfile = unwrap(pDecoderProfile);
  auto ret = m_pID3D11VideoDevice->CheckCryptoKeyExchange(
    unwrapped_pCryptoType, 
    unwrapped_pDecoderProfile, 
    Index, 
    pKeyExchangeType
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "CheckCryptoKeyExchange", &ret, {
    {"pCryptoType", {(void*)&orig_pCryptoType, (void*)&pCryptoType}},
    {"pDecoderProfile", {(void*)&orig_pDecoderProfile, (void*)&pDecoderProfile}},
    {"Index", {(void*)&orig_Index, (void*)&Index}},
    {"pKeyExchangeType", {(void*)&orig_pKeyExchangeType, (void*)&pKeyExchangeType}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11VideoDevice->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11VideoDevice);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11VideoDevice->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoDevice", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoDevice2::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoDevice2)) {
      *ppvObject = (ID3D11VideoDevice2*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11VideoDevice1)) {
      *ppvObject = (ID3D11VideoDevice1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11VideoDevice)) {
      *ppvObject = (ID3D11VideoDevice*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoDevice2::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoDevice2::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::DecoderBeginFrame1(
  ID3D11VideoDecoder * pDecoder, 
  ID3D11VideoDecoderOutputView * pView, 
  UINT ContentKeySize, 
  const void * pContentKey, 
  UINT NumComponentHistograms, 
  const UINT * pHistogramOffsets, 
  ID3D11Buffer *const * ppHistogramBuffers
) {
  assert(m_pID3D11VideoContext3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_pView = pView;
  auto orig_ContentKeySize = ContentKeySize;
  auto orig_pContentKey = pContentKey;
  auto orig_NumComponentHistograms = NumComponentHistograms;
  auto orig_pHistogramOffsets = pHistogramOffsets;
  auto orig_ppHistogramBuffers = ppHistogramBuffers;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto unwrapped_pView = unwrap(pView);
  ID3D11Buffer  *tmp_ppHistogramBuffers[0x80];
  for (uint32_t i = 0; i < NumComponentHistograms; i++) tmp_ppHistogramBuffers[i] = unwrap(ppHistogramBuffers[i]);
  auto ret = m_pID3D11VideoContext3->DecoderBeginFrame1(
    unwrapped_pDecoder, 
    unwrapped_pView, 
    ContentKeySize, 
    pContentKey, 
    NumComponentHistograms, 
    pHistogramOffsets, 
    tmp_ppHistogramBuffers
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext3", "DecoderBeginFrame1", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"pView", {(void*)&orig_pView, (void*)&pView}},
    {"ContentKeySize", {(void*)&orig_ContentKeySize, (void*)&ContentKeySize}},
    {"pContentKey", {(void*)&orig_pContentKey, (void*)&pContentKey}},
    {"NumComponentHistograms", {(void*)&orig_NumComponentHistograms, (void*)&NumComponentHistograms}},
    {"pHistogramOffsets", {(void*)&orig_pHistogramOffsets, (void*)&pHistogramOffsets}},
    {"ppHistogramBuffers", {(void*)&orig_ppHistogramBuffers, (void*)&ppHistogramBuffers}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::SubmitDecoderBuffers2(
  ID3D11VideoDecoder * pDecoder, 
  UINT NumBuffers, 
  const D3D11_VIDEO_DECODER_BUFFER_DESC2 * pBufferDesc
) {
  assert(m_pID3D11VideoContext3);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_NumBuffers = NumBuffers;
  auto orig_pBufferDesc = pBufferDesc;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto ret = m_pID3D11VideoContext3->SubmitDecoderBuffers2(
    unwrapped_pDecoder, 
    NumBuffers, 
    pBufferDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext3", "SubmitDecoderBuffers2", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"pBufferDesc", {(void*)&orig_pBufferDesc, (void*)&pBufferDesc}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputHDRMetaData(
  ID3D11VideoProcessor * pVideoProcessor, 
  DXGI_HDR_METADATA_TYPE Type, 
  UINT Size, 
  const void * pHDRMetaData
) {
  assert(m_pID3D11VideoContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_Type = Type;
  auto orig_Size = Size;
  auto orig_pHDRMetaData = pHDRMetaData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext2->VideoProcessorSetOutputHDRMetaData(
    unwrapped_pVideoProcessor, 
    Type, 
    Size, 
    pHDRMetaData
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext2", "VideoProcessorSetOutputHDRMetaData", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"Type", {(void*)&orig_Type, (void*)&Type}},
    {"Size", {(void*)&orig_Size, (void*)&Size}},
    {"pHDRMetaData", {(void*)&orig_pHDRMetaData, (void*)&pHDRMetaData}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputHDRMetaData(
  ID3D11VideoProcessor * pVideoProcessor, 
  DXGI_HDR_METADATA_TYPE * pType, 
  UINT Size, 
  void * pMetaData
) {
  assert(m_pID3D11VideoContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pType = pType;
  auto orig_Size = Size;
  auto orig_pMetaData = pMetaData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext2->VideoProcessorGetOutputHDRMetaData(
    unwrapped_pVideoProcessor, 
    pType, 
    Size, 
    pMetaData
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext2", "VideoProcessorGetOutputHDRMetaData", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pType", {(void*)&orig_pType, (void*)&pType}},
    {"Size", {(void*)&orig_Size, (void*)&Size}},
    {"pMetaData", {(void*)&orig_pMetaData, (void*)&pMetaData}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamHDRMetaData(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  DXGI_HDR_METADATA_TYPE Type, 
  UINT Size, 
  const void * pHDRMetaData
) {
  assert(m_pID3D11VideoContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Type = Type;
  auto orig_Size = Size;
  auto orig_pHDRMetaData = pHDRMetaData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext2->VideoProcessorSetStreamHDRMetaData(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Type, 
    Size, 
    pHDRMetaData
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext2", "VideoProcessorSetStreamHDRMetaData", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Type", {(void*)&orig_Type, (void*)&Type}},
    {"Size", {(void*)&orig_Size, (void*)&Size}},
    {"pHDRMetaData", {(void*)&orig_pHDRMetaData, (void*)&pHDRMetaData}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamHDRMetaData(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  DXGI_HDR_METADATA_TYPE * pType, 
  UINT Size, 
  void * pMetaData
) {
  assert(m_pID3D11VideoContext2);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pType = pType;
  auto orig_Size = Size;
  auto orig_pMetaData = pMetaData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext2->VideoProcessorGetStreamHDRMetaData(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pType, 
    Size, 
    pMetaData
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext2", "VideoProcessorGetStreamHDRMetaData", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pType", {(void*)&orig_pType, (void*)&pType}},
    {"Size", {(void*)&orig_Size, (void*)&Size}},
    {"pMetaData", {(void*)&orig_pMetaData, (void*)&pMetaData}},
  });
}
HRESULT __stdcall WrappedID3D11VideoContext3::SubmitDecoderBuffers1(
  ID3D11VideoDecoder * pDecoder, 
  UINT NumBuffers, 
  const D3D11_VIDEO_DECODER_BUFFER_DESC1 * pBufferDesc
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_NumBuffers = NumBuffers;
  auto orig_pBufferDesc = pBufferDesc;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto ret = m_pID3D11VideoContext1->SubmitDecoderBuffers1(
    unwrapped_pDecoder, 
    NumBuffers, 
    pBufferDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "SubmitDecoderBuffers1", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"pBufferDesc", {(void*)&orig_pBufferDesc, (void*)&pBufferDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::GetDataForNewHardwareKey(
  ID3D11CryptoSession * pCryptoSession, 
  UINT PrivateInputSize, 
  const void * pPrivatInputData, 
  UINT64 * pPrivateOutputData
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_PrivateInputSize = PrivateInputSize;
  auto orig_pPrivatInputData = pPrivatInputData;
  auto orig_pPrivateOutputData = pPrivateOutputData;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto ret = m_pID3D11VideoContext1->GetDataForNewHardwareKey(
    unwrapped_pCryptoSession, 
    PrivateInputSize, 
    pPrivatInputData, 
    pPrivateOutputData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "GetDataForNewHardwareKey", &ret, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"PrivateInputSize", {(void*)&orig_PrivateInputSize, (void*)&PrivateInputSize}},
    {"pPrivatInputData", {(void*)&orig_pPrivatInputData, (void*)&pPrivatInputData}},
    {"pPrivateOutputData", {(void*)&orig_pPrivateOutputData, (void*)&pPrivateOutputData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::CheckCryptoSessionStatus(
  ID3D11CryptoSession * pCryptoSession, 
  D3D11_CRYPTO_SESSION_STATUS * pStatus
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_pStatus = pStatus;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto ret = m_pID3D11VideoContext1->CheckCryptoSessionStatus(
    unwrapped_pCryptoSession, 
    pStatus
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "CheckCryptoSessionStatus", &ret, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"pStatus", {(void*)&orig_pStatus, (void*)&pStatus}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::DecoderEnableDownsampling(
  ID3D11VideoDecoder * pDecoder, 
  DXGI_COLOR_SPACE_TYPE InputColorSpace, 
  const D3D11_VIDEO_SAMPLE_DESC * pOutputDesc, 
  UINT ReferenceFrameCount
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_InputColorSpace = InputColorSpace;
  auto orig_pOutputDesc = pOutputDesc;
  auto orig_ReferenceFrameCount = ReferenceFrameCount;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto unwrapped_pOutputDesc = unwrap(pOutputDesc);
  auto ret = m_pID3D11VideoContext1->DecoderEnableDownsampling(
    unwrapped_pDecoder, 
    InputColorSpace, 
    unwrapped_pOutputDesc, 
    ReferenceFrameCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "DecoderEnableDownsampling", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"InputColorSpace", {(void*)&orig_InputColorSpace, (void*)&InputColorSpace}},
    {"pOutputDesc", {(void*)&orig_pOutputDesc, (void*)&pOutputDesc}},
    {"ReferenceFrameCount", {(void*)&orig_ReferenceFrameCount, (void*)&ReferenceFrameCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::DecoderUpdateDownsampling(
  ID3D11VideoDecoder * pDecoder, 
  const D3D11_VIDEO_SAMPLE_DESC * pOutputDesc
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_pOutputDesc = pOutputDesc;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto unwrapped_pOutputDesc = unwrap(pOutputDesc);
  auto ret = m_pID3D11VideoContext1->DecoderUpdateDownsampling(
    unwrapped_pDecoder, 
    unwrapped_pOutputDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "DecoderUpdateDownsampling", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"pOutputDesc", {(void*)&orig_pOutputDesc, (void*)&pOutputDesc}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputColorSpace1(
  ID3D11VideoProcessor * pVideoProcessor, 
  DXGI_COLOR_SPACE_TYPE ColorSpace
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_ColorSpace = ColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorSetOutputColorSpace1(
    unwrapped_pVideoProcessor, 
    ColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorSetOutputColorSpace1", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"ColorSpace", {(void*)&orig_ColorSpace, (void*)&ColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputShaderUsage(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL ShaderUsage
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_ShaderUsage = ShaderUsage;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorSetOutputShaderUsage(
    unwrapped_pVideoProcessor, 
    ShaderUsage
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorSetOutputShaderUsage", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"ShaderUsage", {(void*)&orig_ShaderUsage, (void*)&ShaderUsage}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputColorSpace1(
  ID3D11VideoProcessor * pVideoProcessor, 
  DXGI_COLOR_SPACE_TYPE * pColorSpace
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pColorSpace = pColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorGetOutputColorSpace1(
    unwrapped_pVideoProcessor, 
    pColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorGetOutputColorSpace1", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pColorSpace", {(void*)&orig_pColorSpace, (void*)&pColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputShaderUsage(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL * pShaderUsage
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pShaderUsage = pShaderUsage;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorGetOutputShaderUsage(
    unwrapped_pVideoProcessor, 
    pShaderUsage
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorGetOutputShaderUsage", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pShaderUsage", {(void*)&orig_pShaderUsage, (void*)&pShaderUsage}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamColorSpace1(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  DXGI_COLOR_SPACE_TYPE ColorSpace
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_ColorSpace = ColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorSetStreamColorSpace1(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    ColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorSetStreamColorSpace1", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"ColorSpace", {(void*)&orig_ColorSpace, (void*)&ColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamMirror(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  BOOL FlipHorizontal, 
  BOOL FlipVertical
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_FlipHorizontal = FlipHorizontal;
  auto orig_FlipVertical = FlipVertical;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorSetStreamMirror(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    FlipHorizontal, 
    FlipVertical
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorSetStreamMirror", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"FlipHorizontal", {(void*)&orig_FlipHorizontal, (void*)&FlipHorizontal}},
    {"FlipVertical", {(void*)&orig_FlipVertical, (void*)&FlipVertical}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamColorSpace1(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  DXGI_COLOR_SPACE_TYPE * pColorSpace
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pColorSpace = pColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorGetStreamColorSpace1(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorGetStreamColorSpace1", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pColorSpace", {(void*)&orig_pColorSpace, (void*)&pColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamMirror(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnable, 
  BOOL * pFlipHorizontal, 
  BOOL * pFlipVertical
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnable = pEnable;
  auto orig_pFlipHorizontal = pFlipHorizontal;
  auto orig_pFlipVertical = pFlipVertical;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext1->VideoProcessorGetStreamMirror(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnable, 
    pFlipHorizontal, 
    pFlipVertical
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorGetStreamMirror", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnable", {(void*)&orig_pEnable, (void*)&pEnable}},
    {"pFlipHorizontal", {(void*)&orig_pFlipHorizontal, (void*)&pFlipHorizontal}},
    {"pFlipVertical", {(void*)&orig_pFlipVertical, (void*)&pFlipVertical}},
  });
}
HRESULT __stdcall WrappedID3D11VideoContext3::VideoProcessorGetBehaviorHints(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT OutputWidth, 
  UINT OutputHeight, 
  DXGI_FORMAT OutputFormat, 
  UINT StreamCount, 
  const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT * pStreams, 
  UINT * pBehaviorHints
) {
  assert(m_pID3D11VideoContext1);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_OutputWidth = OutputWidth;
  auto orig_OutputHeight = OutputHeight;
  auto orig_OutputFormat = OutputFormat;
  auto orig_StreamCount = StreamCount;
  auto orig_pStreams = pStreams;
  auto orig_pBehaviorHints = pBehaviorHints;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto ret = m_pID3D11VideoContext1->VideoProcessorGetBehaviorHints(
    unwrapped_pVideoProcessor, 
    OutputWidth, 
    OutputHeight, 
    OutputFormat, 
    StreamCount, 
    pStreams, 
    pBehaviorHints
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext1", "VideoProcessorGetBehaviorHints", &ret, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"OutputWidth", {(void*)&orig_OutputWidth, (void*)&OutputWidth}},
    {"OutputHeight", {(void*)&orig_OutputHeight, (void*)&OutputHeight}},
    {"OutputFormat", {(void*)&orig_OutputFormat, (void*)&OutputFormat}},
    {"StreamCount", {(void*)&orig_StreamCount, (void*)&StreamCount}},
    {"pStreams", {(void*)&orig_pStreams, (void*)&pStreams}},
    {"pBehaviorHints", {(void*)&orig_pBehaviorHints, (void*)&pBehaviorHints}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::GetDecoderBuffer(
  ID3D11VideoDecoder * pDecoder, 
  D3D11_VIDEO_DECODER_BUFFER_TYPE Type, 
  UINT * pBufferSize, 
  void ** ppBuffer
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_Type = Type;
  auto orig_pBufferSize = pBufferSize;
  auto orig_ppBuffer = ppBuffer;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto ret = m_pID3D11VideoContext->GetDecoderBuffer(
    unwrapped_pDecoder, 
    Type, 
    pBufferSize, 
    ppBuffer
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  assert(false && "Wrap not implemented; Emit Seg Fault");
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "GetDecoderBuffer", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"Type", {(void*)&orig_Type, (void*)&Type}},
    {"pBufferSize", {(void*)&orig_pBufferSize, (void*)&pBufferSize}},
    {"ppBuffer", {(void*)&orig_ppBuffer, (void*)&ppBuffer}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::ReleaseDecoderBuffer(
  ID3D11VideoDecoder * pDecoder, 
  D3D11_VIDEO_DECODER_BUFFER_TYPE Type
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_Type = Type;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto ret = m_pID3D11VideoContext->ReleaseDecoderBuffer(
    unwrapped_pDecoder, 
    Type
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "ReleaseDecoderBuffer", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"Type", {(void*)&orig_Type, (void*)&Type}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::DecoderBeginFrame(
  ID3D11VideoDecoder * pDecoder, 
  ID3D11VideoDecoderOutputView * pView, 
  UINT ContentKeySize, 
  const void * pContentKey
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_pView = pView;
  auto orig_ContentKeySize = ContentKeySize;
  auto orig_pContentKey = pContentKey;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto unwrapped_pView = unwrap(pView);
  auto ret = m_pID3D11VideoContext->DecoderBeginFrame(
    unwrapped_pDecoder, 
    unwrapped_pView, 
    ContentKeySize, 
    pContentKey
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "DecoderBeginFrame", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"pView", {(void*)&orig_pView, (void*)&pView}},
    {"ContentKeySize", {(void*)&orig_ContentKeySize, (void*)&ContentKeySize}},
    {"pContentKey", {(void*)&orig_pContentKey, (void*)&pContentKey}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::DecoderEndFrame(
  ID3D11VideoDecoder * pDecoder
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto ret = m_pID3D11VideoContext->DecoderEndFrame(
    unwrapped_pDecoder
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "DecoderEndFrame", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::SubmitDecoderBuffers(
  ID3D11VideoDecoder * pDecoder, 
  UINT NumBuffers, 
  const D3D11_VIDEO_DECODER_BUFFER_DESC * pBufferDesc
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_NumBuffers = NumBuffers;
  auto orig_pBufferDesc = pBufferDesc;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto ret = m_pID3D11VideoContext->SubmitDecoderBuffers(
    unwrapped_pDecoder, 
    NumBuffers, 
    pBufferDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "SubmitDecoderBuffers", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"NumBuffers", {(void*)&orig_NumBuffers, (void*)&NumBuffers}},
    {"pBufferDesc", {(void*)&orig_pBufferDesc, (void*)&pBufferDesc}},
  });
  return ret;
}
APP_DEPRECATED_HRESULT __stdcall WrappedID3D11VideoContext3::DecoderExtension(
  ID3D11VideoDecoder * pDecoder, 
  const D3D11_VIDEO_DECODER_EXTENSION * pExtensionData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDecoder = pDecoder;
  auto orig_pExtensionData = pExtensionData;
  auto unwrapped_pDecoder = unwrap(pDecoder);
  auto unwrapped_pExtensionData = unwrap(pExtensionData);
  auto ret = m_pID3D11VideoContext->DecoderExtension(
    unwrapped_pDecoder, 
    unwrapped_pExtensionData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "DecoderExtension", &ret, {
    {"pDecoder", {(void*)&orig_pDecoder, (void*)&pDecoder}},
    {"pExtensionData", {(void*)&orig_pExtensionData, (void*)&pExtensionData}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputTargetRect(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL Enable, 
  const RECT * pRect
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_Enable = Enable;
  auto orig_pRect = pRect;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pRect = unwrap(pRect);
  m_pID3D11VideoContext->VideoProcessorSetOutputTargetRect(
    unwrapped_pVideoProcessor, 
    Enable, 
    unwrapped_pRect
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputTargetRect", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputBackgroundColor(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL YCbCr, 
  const D3D11_VIDEO_COLOR * pColor
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_YCbCr = YCbCr;
  auto orig_pColor = pColor;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pColor = unwrap(pColor);
  m_pID3D11VideoContext->VideoProcessorSetOutputBackgroundColor(
    unwrapped_pVideoProcessor, 
    YCbCr, 
    unwrapped_pColor
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputBackgroundColor", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"YCbCr", {(void*)&orig_YCbCr, (void*)&YCbCr}},
    {"pColor", {(void*)&orig_pColor, (void*)&pColor}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputColorSpace(
  ID3D11VideoProcessor * pVideoProcessor, 
  const D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pColorSpace = pColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pColorSpace = unwrap(pColorSpace);
  m_pID3D11VideoContext->VideoProcessorSetOutputColorSpace(
    unwrapped_pVideoProcessor, 
    unwrapped_pColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputColorSpace", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pColorSpace", {(void*)&orig_pColorSpace, (void*)&pColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputAlphaFillMode(
  ID3D11VideoProcessor * pVideoProcessor, 
  D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE AlphaFillMode, 
  UINT StreamIndex
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_AlphaFillMode = AlphaFillMode;
  auto orig_StreamIndex = StreamIndex;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetOutputAlphaFillMode(
    unwrapped_pVideoProcessor, 
    AlphaFillMode, 
    StreamIndex
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputAlphaFillMode", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"AlphaFillMode", {(void*)&orig_AlphaFillMode, (void*)&AlphaFillMode}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputConstriction(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL Enable, 
  SIZE Size
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_Enable = Enable;
  auto orig_Size = Size;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetOutputConstriction(
    unwrapped_pVideoProcessor, 
    Enable, 
    Size
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputConstriction", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"Size", {(void*)&orig_Size, (void*)&Size}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputStereoMode(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL Enable
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_Enable = Enable;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetOutputStereoMode(
    unwrapped_pVideoProcessor, 
    Enable
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputStereoMode", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
  });
}
APP_DEPRECATED_HRESULT __stdcall WrappedID3D11VideoContext3::VideoProcessorSetOutputExtension(
  ID3D11VideoProcessor * pVideoProcessor, 
  const GUID * pExtensionGuid, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pExtensionGuid = pExtensionGuid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pExtensionGuid = unwrap(pExtensionGuid);
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11VideoContext->VideoProcessorSetOutputExtension(
    unwrapped_pVideoProcessor, 
    unwrapped_pExtensionGuid, 
    DataSize, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetOutputExtension", &ret, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pExtensionGuid", {(void*)&orig_pExtensionGuid, (void*)&pExtensionGuid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputTargetRect(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL * Enabled, 
  RECT * pRect
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_Enabled = Enabled;
  auto orig_pRect = pRect;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetOutputTargetRect(
    unwrapped_pVideoProcessor, 
    Enabled, 
    pRect
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputTargetRect", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"Enabled", {(void*)&orig_Enabled, (void*)&Enabled}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputBackgroundColor(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL * pYCbCr, 
  D3D11_VIDEO_COLOR * pColor
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pYCbCr = pYCbCr;
  auto orig_pColor = pColor;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetOutputBackgroundColor(
    unwrapped_pVideoProcessor, 
    pYCbCr, 
    pColor
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputBackgroundColor", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pYCbCr", {(void*)&orig_pYCbCr, (void*)&pYCbCr}},
    {"pColor", {(void*)&orig_pColor, (void*)&pColor}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputColorSpace(
  ID3D11VideoProcessor * pVideoProcessor, 
  D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pColorSpace = pColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetOutputColorSpace(
    unwrapped_pVideoProcessor, 
    pColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputColorSpace", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pColorSpace", {(void*)&orig_pColorSpace, (void*)&pColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputAlphaFillMode(
  ID3D11VideoProcessor * pVideoProcessor, 
  D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE * pAlphaFillMode, 
  UINT * pStreamIndex
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pAlphaFillMode = pAlphaFillMode;
  auto orig_pStreamIndex = pStreamIndex;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetOutputAlphaFillMode(
    unwrapped_pVideoProcessor, 
    pAlphaFillMode, 
    pStreamIndex
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputAlphaFillMode", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pAlphaFillMode", {(void*)&orig_pAlphaFillMode, (void*)&pAlphaFillMode}},
    {"pStreamIndex", {(void*)&orig_pStreamIndex, (void*)&pStreamIndex}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputConstriction(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL * pEnabled, 
  SIZE * pSize
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pEnabled = pEnabled;
  auto orig_pSize = pSize;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetOutputConstriction(
    unwrapped_pVideoProcessor, 
    pEnabled, 
    pSize
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputConstriction", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pSize", {(void*)&orig_pSize, (void*)&pSize}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputStereoMode(
  ID3D11VideoProcessor * pVideoProcessor, 
  BOOL * pEnabled
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pEnabled = pEnabled;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetOutputStereoMode(
    unwrapped_pVideoProcessor, 
    pEnabled
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputStereoMode", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
  });
}
APP_DEPRECATED_HRESULT __stdcall WrappedID3D11VideoContext3::VideoProcessorGetOutputExtension(
  ID3D11VideoProcessor * pVideoProcessor, 
  const GUID * pExtensionGuid, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pExtensionGuid = pExtensionGuid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pExtensionGuid = unwrap(pExtensionGuid);
  auto ret = m_pID3D11VideoContext->VideoProcessorGetOutputExtension(
    unwrapped_pVideoProcessor, 
    unwrapped_pExtensionGuid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetOutputExtension", &ret, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pExtensionGuid", {(void*)&orig_pExtensionGuid, (void*)&pExtensionGuid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamFrameFormat(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_FRAME_FORMAT FrameFormat
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_FrameFormat = FrameFormat;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamFrameFormat(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    FrameFormat
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamFrameFormat", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"FrameFormat", {(void*)&orig_FrameFormat, (void*)&FrameFormat}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamColorSpace(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  const D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pColorSpace = pColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pColorSpace = unwrap(pColorSpace);
  m_pID3D11VideoContext->VideoProcessorSetStreamColorSpace(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    unwrapped_pColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamColorSpace", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pColorSpace", {(void*)&orig_pColorSpace, (void*)&pColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamOutputRate(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_PROCESSOR_OUTPUT_RATE OutputRate, 
  BOOL RepeatFrame, 
  const DXGI_RATIONAL * pCustomRate
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_OutputRate = OutputRate;
  auto orig_RepeatFrame = RepeatFrame;
  auto orig_pCustomRate = pCustomRate;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pCustomRate = unwrap(pCustomRate);
  m_pID3D11VideoContext->VideoProcessorSetStreamOutputRate(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    OutputRate, 
    RepeatFrame, 
    unwrapped_pCustomRate
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamOutputRate", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"OutputRate", {(void*)&orig_OutputRate, (void*)&OutputRate}},
    {"RepeatFrame", {(void*)&orig_RepeatFrame, (void*)&RepeatFrame}},
    {"pCustomRate", {(void*)&orig_pCustomRate, (void*)&pCustomRate}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamSourceRect(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  const RECT * pRect
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_pRect = pRect;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pRect = unwrap(pRect);
  m_pID3D11VideoContext->VideoProcessorSetStreamSourceRect(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    unwrapped_pRect
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamSourceRect", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamDestRect(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  const RECT * pRect
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_pRect = pRect;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pRect = unwrap(pRect);
  m_pID3D11VideoContext->VideoProcessorSetStreamDestRect(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    unwrapped_pRect
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamDestRect", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamAlpha(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  FLOAT Alpha
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_Alpha = Alpha;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamAlpha(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    Alpha
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamAlpha", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"Alpha", {(void*)&orig_Alpha, (void*)&Alpha}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamPalette(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  UINT Count, 
  const UINT * pEntries
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Count = Count;
  auto orig_pEntries = pEntries;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamPalette(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Count, 
    pEntries
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamPalette", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Count", {(void*)&orig_Count, (void*)&Count}},
    {"pEntries", {(void*)&orig_pEntries, (void*)&pEntries}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamPixelAspectRatio(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  const DXGI_RATIONAL * pSourceAspectRatio, 
  const DXGI_RATIONAL * pDestinationAspectRatio
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_pSourceAspectRatio = pSourceAspectRatio;
  auto orig_pDestinationAspectRatio = pDestinationAspectRatio;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pSourceAspectRatio = unwrap(pSourceAspectRatio);
  auto unwrapped_pDestinationAspectRatio = unwrap(pDestinationAspectRatio);
  m_pID3D11VideoContext->VideoProcessorSetStreamPixelAspectRatio(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    unwrapped_pSourceAspectRatio, 
    unwrapped_pDestinationAspectRatio
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamPixelAspectRatio", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"pSourceAspectRatio", {(void*)&orig_pSourceAspectRatio, (void*)&pSourceAspectRatio}},
    {"pDestinationAspectRatio", {(void*)&orig_pDestinationAspectRatio, (void*)&pDestinationAspectRatio}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamLumaKey(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  FLOAT Lower, 
  FLOAT Upper
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_Lower = Lower;
  auto orig_Upper = Upper;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamLumaKey(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    Lower, 
    Upper
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamLumaKey", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"Lower", {(void*)&orig_Lower, (void*)&Lower}},
    {"Upper", {(void*)&orig_Upper, (void*)&Upper}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamStereoFormat(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  D3D11_VIDEO_PROCESSOR_STEREO_FORMAT Format, 
  BOOL LeftViewFrame0, 
  BOOL BaseViewFrame0, 
  D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE FlipMode, 
  int MonoOffset
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_Format = Format;
  auto orig_LeftViewFrame0 = LeftViewFrame0;
  auto orig_BaseViewFrame0 = BaseViewFrame0;
  auto orig_FlipMode = FlipMode;
  auto orig_MonoOffset = MonoOffset;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamStereoFormat(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    Format, 
    LeftViewFrame0, 
    BaseViewFrame0, 
    FlipMode, 
    MonoOffset
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamStereoFormat", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"Format", {(void*)&orig_Format, (void*)&Format}},
    {"LeftViewFrame0", {(void*)&orig_LeftViewFrame0, (void*)&LeftViewFrame0}},
    {"BaseViewFrame0", {(void*)&orig_BaseViewFrame0, (void*)&BaseViewFrame0}},
    {"FlipMode", {(void*)&orig_FlipMode, (void*)&FlipMode}},
    {"MonoOffset", {(void*)&orig_MonoOffset, (void*)&MonoOffset}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamAutoProcessingMode(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamAutoProcessingMode(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamAutoProcessingMode", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamFilter(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_PROCESSOR_FILTER Filter, 
  BOOL Enable, 
  int Level
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Filter = Filter;
  auto orig_Enable = Enable;
  auto orig_Level = Level;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamFilter(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Filter, 
    Enable, 
    Level
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamFilter", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Filter", {(void*)&orig_Filter, (void*)&Filter}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"Level", {(void*)&orig_Level, (void*)&Level}},
  });
}
APP_DEPRECATED_HRESULT __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamExtension(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  const GUID * pExtensionGuid, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pExtensionGuid = pExtensionGuid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pExtensionGuid = unwrap(pExtensionGuid);
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11VideoContext->VideoProcessorSetStreamExtension(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    unwrapped_pExtensionGuid, 
    DataSize, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamExtension", &ret, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pExtensionGuid", {(void*)&orig_pExtensionGuid, (void*)&pExtensionGuid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamFrameFormat(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_FRAME_FORMAT * pFrameFormat
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pFrameFormat = pFrameFormat;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamFrameFormat(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pFrameFormat
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamFrameFormat", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pFrameFormat", {(void*)&orig_pFrameFormat, (void*)&pFrameFormat}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamColorSpace(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_PROCESSOR_COLOR_SPACE * pColorSpace
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pColorSpace = pColorSpace;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamColorSpace(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pColorSpace
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamColorSpace", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pColorSpace", {(void*)&orig_pColorSpace, (void*)&pColorSpace}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamOutputRate(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_PROCESSOR_OUTPUT_RATE * pOutputRate, 
  BOOL * pRepeatFrame, 
  DXGI_RATIONAL * pCustomRate
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pOutputRate = pOutputRate;
  auto orig_pRepeatFrame = pRepeatFrame;
  auto orig_pCustomRate = pCustomRate;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamOutputRate(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pOutputRate, 
    pRepeatFrame, 
    pCustomRate
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamOutputRate", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pOutputRate", {(void*)&orig_pOutputRate, (void*)&pOutputRate}},
    {"pRepeatFrame", {(void*)&orig_pRepeatFrame, (void*)&pRepeatFrame}},
    {"pCustomRate", {(void*)&orig_pCustomRate, (void*)&pCustomRate}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamSourceRect(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnabled, 
  RECT * pRect
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnabled = pEnabled;
  auto orig_pRect = pRect;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamSourceRect(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnabled, 
    pRect
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamSourceRect", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamDestRect(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnabled, 
  RECT * pRect
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnabled = pEnabled;
  auto orig_pRect = pRect;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamDestRect(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnabled, 
    pRect
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamDestRect", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pRect", {(void*)&orig_pRect, (void*)&pRect}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamAlpha(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnabled, 
  FLOAT * pAlpha
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnabled = pEnabled;
  auto orig_pAlpha = pAlpha;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamAlpha(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnabled, 
    pAlpha
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamAlpha", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pAlpha", {(void*)&orig_pAlpha, (void*)&pAlpha}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamPalette(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  UINT Count, 
  UINT * pEntries
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Count = Count;
  auto orig_pEntries = pEntries;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamPalette(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Count, 
    pEntries
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamPalette", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Count", {(void*)&orig_Count, (void*)&Count}},
    {"pEntries", {(void*)&orig_pEntries, (void*)&pEntries}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamPixelAspectRatio(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnabled, 
  DXGI_RATIONAL * pSourceAspectRatio, 
  DXGI_RATIONAL * pDestinationAspectRatio
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnabled = pEnabled;
  auto orig_pSourceAspectRatio = pSourceAspectRatio;
  auto orig_pDestinationAspectRatio = pDestinationAspectRatio;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamPixelAspectRatio(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnabled, 
    pSourceAspectRatio, 
    pDestinationAspectRatio
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamPixelAspectRatio", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pSourceAspectRatio", {(void*)&orig_pSourceAspectRatio, (void*)&pSourceAspectRatio}},
    {"pDestinationAspectRatio", {(void*)&orig_pDestinationAspectRatio, (void*)&pDestinationAspectRatio}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamLumaKey(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnabled, 
  FLOAT * pLower, 
  FLOAT * pUpper
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnabled = pEnabled;
  auto orig_pLower = pLower;
  auto orig_pUpper = pUpper;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamLumaKey(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnabled, 
    pLower, 
    pUpper
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamLumaKey", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pLower", {(void*)&orig_pLower, (void*)&pLower}},
    {"pUpper", {(void*)&orig_pUpper, (void*)&pUpper}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamStereoFormat(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnable, 
  D3D11_VIDEO_PROCESSOR_STEREO_FORMAT * pFormat, 
  BOOL * pLeftViewFrame0, 
  BOOL * pBaseViewFrame0, 
  D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE * pFlipMode, 
  int * MonoOffset
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnable = pEnable;
  auto orig_pFormat = pFormat;
  auto orig_pLeftViewFrame0 = pLeftViewFrame0;
  auto orig_pBaseViewFrame0 = pBaseViewFrame0;
  auto orig_pFlipMode = pFlipMode;
  auto orig_MonoOffset = MonoOffset;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamStereoFormat(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnable, 
    pFormat, 
    pLeftViewFrame0, 
    pBaseViewFrame0, 
    pFlipMode, 
    MonoOffset
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamStereoFormat", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnable", {(void*)&orig_pEnable, (void*)&pEnable}},
    {"pFormat", {(void*)&orig_pFormat, (void*)&pFormat}},
    {"pLeftViewFrame0", {(void*)&orig_pLeftViewFrame0, (void*)&pLeftViewFrame0}},
    {"pBaseViewFrame0", {(void*)&orig_pBaseViewFrame0, (void*)&pBaseViewFrame0}},
    {"pFlipMode", {(void*)&orig_pFlipMode, (void*)&pFlipMode}},
    {"MonoOffset", {(void*)&orig_MonoOffset, (void*)&MonoOffset}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamAutoProcessingMode(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnabled
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnabled = pEnabled;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamAutoProcessingMode(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnabled
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamAutoProcessingMode", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamFilter(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  D3D11_VIDEO_PROCESSOR_FILTER Filter, 
  BOOL * pEnabled, 
  int * pLevel
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Filter = Filter;
  auto orig_pEnabled = pEnabled;
  auto orig_pLevel = pLevel;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamFilter(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Filter, 
    pEnabled, 
    pLevel
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamFilter", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Filter", {(void*)&orig_Filter, (void*)&Filter}},
    {"pEnabled", {(void*)&orig_pEnabled, (void*)&pEnabled}},
    {"pLevel", {(void*)&orig_pLevel, (void*)&pLevel}},
  });
}
APP_DEPRECATED_HRESULT __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamExtension(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  const GUID * pExtensionGuid, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pExtensionGuid = pExtensionGuid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pExtensionGuid = unwrap(pExtensionGuid);
  auto ret = m_pID3D11VideoContext->VideoProcessorGetStreamExtension(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    unwrapped_pExtensionGuid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamExtension", &ret, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pExtensionGuid", {(void*)&orig_pExtensionGuid, (void*)&pExtensionGuid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::VideoProcessorBlt(
  ID3D11VideoProcessor * pVideoProcessor, 
  ID3D11VideoProcessorOutputView * pView, 
  UINT OutputFrame, 
  UINT StreamCount, 
  const D3D11_VIDEO_PROCESSOR_STREAM * pStreams
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_pView = pView;
  auto orig_OutputFrame = OutputFrame;
  auto orig_StreamCount = StreamCount;
  auto orig_pStreams = pStreams;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  auto unwrapped_pView = unwrap(pView);
  auto ret = m_pID3D11VideoContext->VideoProcessorBlt(
    unwrapped_pVideoProcessor, 
    unwrapped_pView, 
    OutputFrame, 
    StreamCount, 
    pStreams
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorBlt", &ret, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"pView", {(void*)&orig_pView, (void*)&pView}},
    {"OutputFrame", {(void*)&orig_OutputFrame, (void*)&OutputFrame}},
    {"StreamCount", {(void*)&orig_StreamCount, (void*)&StreamCount}},
    {"pStreams", {(void*)&orig_pStreams, (void*)&pStreams}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::NegotiateCryptoSessionKeyExchange(
  ID3D11CryptoSession * pCryptoSession, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11VideoContext->NegotiateCryptoSessionKeyExchange(
    unwrapped_pCryptoSession, 
    DataSize, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "NegotiateCryptoSessionKeyExchange", &ret, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::EncryptionBlt(
  ID3D11CryptoSession * pCryptoSession, 
  ID3D11Texture2D * pSrcSurface, 
  ID3D11Texture2D * pDstSurface, 
  UINT IVSize, 
  void * pIV
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_pSrcSurface = pSrcSurface;
  auto orig_pDstSurface = pDstSurface;
  auto orig_IVSize = IVSize;
  auto orig_pIV = pIV;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto unwrapped_pSrcSurface = unwrap(pSrcSurface);
  auto unwrapped_pDstSurface = unwrap(pDstSurface);
  auto unwrapped_pIV = unwrap(pIV);
  m_pID3D11VideoContext->EncryptionBlt(
    unwrapped_pCryptoSession, 
    unwrapped_pSrcSurface, 
    unwrapped_pDstSurface, 
    IVSize, 
    unwrapped_pIV
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "EncryptionBlt", nullptr, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"pSrcSurface", {(void*)&orig_pSrcSurface, (void*)&pSrcSurface}},
    {"pDstSurface", {(void*)&orig_pDstSurface, (void*)&pDstSurface}},
    {"IVSize", {(void*)&orig_IVSize, (void*)&IVSize}},
    {"pIV", {(void*)&orig_pIV, (void*)&pIV}},
  });
}
void __stdcall WrappedID3D11VideoContext3::DecryptionBlt(
  ID3D11CryptoSession * pCryptoSession, 
  ID3D11Texture2D * pSrcSurface, 
  ID3D11Texture2D * pDstSurface, 
  D3D11_ENCRYPTED_BLOCK_INFO * pEncryptedBlockInfo, 
  UINT ContentKeySize, 
  const void * pContentKey, 
  UINT IVSize, 
  void * pIV
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_pSrcSurface = pSrcSurface;
  auto orig_pDstSurface = pDstSurface;
  auto orig_pEncryptedBlockInfo = pEncryptedBlockInfo;
  auto orig_ContentKeySize = ContentKeySize;
  auto orig_pContentKey = pContentKey;
  auto orig_IVSize = IVSize;
  auto orig_pIV = pIV;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto unwrapped_pSrcSurface = unwrap(pSrcSurface);
  auto unwrapped_pDstSurface = unwrap(pDstSurface);
  auto unwrapped_pEncryptedBlockInfo = unwrap(pEncryptedBlockInfo);
  auto unwrapped_pIV = unwrap(pIV);
  m_pID3D11VideoContext->DecryptionBlt(
    unwrapped_pCryptoSession, 
    unwrapped_pSrcSurface, 
    unwrapped_pDstSurface, 
    unwrapped_pEncryptedBlockInfo, 
    ContentKeySize, 
    pContentKey, 
    IVSize, 
    unwrapped_pIV
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "DecryptionBlt", nullptr, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"pSrcSurface", {(void*)&orig_pSrcSurface, (void*)&pSrcSurface}},
    {"pDstSurface", {(void*)&orig_pDstSurface, (void*)&pDstSurface}},
    {"pEncryptedBlockInfo", {(void*)&orig_pEncryptedBlockInfo, (void*)&pEncryptedBlockInfo}},
    {"ContentKeySize", {(void*)&orig_ContentKeySize, (void*)&ContentKeySize}},
    {"pContentKey", {(void*)&orig_pContentKey, (void*)&pContentKey}},
    {"IVSize", {(void*)&orig_IVSize, (void*)&IVSize}},
    {"pIV", {(void*)&orig_pIV, (void*)&pIV}},
  });
}
void __stdcall WrappedID3D11VideoContext3::StartSessionKeyRefresh(
  ID3D11CryptoSession * pCryptoSession, 
  UINT RandomNumberSize, 
  void * pRandomNumber
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_RandomNumberSize = RandomNumberSize;
  auto orig_pRandomNumber = pRandomNumber;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  m_pID3D11VideoContext->StartSessionKeyRefresh(
    unwrapped_pCryptoSession, 
    RandomNumberSize, 
    pRandomNumber
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "StartSessionKeyRefresh", nullptr, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"RandomNumberSize", {(void*)&orig_RandomNumberSize, (void*)&RandomNumberSize}},
    {"pRandomNumber", {(void*)&orig_pRandomNumber, (void*)&pRandomNumber}},
  });
}
void __stdcall WrappedID3D11VideoContext3::FinishSessionKeyRefresh(
  ID3D11CryptoSession * pCryptoSession
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  m_pID3D11VideoContext->FinishSessionKeyRefresh(
    unwrapped_pCryptoSession
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "FinishSessionKeyRefresh", nullptr, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
  });
}
HRESULT __stdcall WrappedID3D11VideoContext3::GetEncryptionBltKey(
  ID3D11CryptoSession * pCryptoSession, 
  UINT KeySize, 
  void * pReadbackKey
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pCryptoSession = pCryptoSession;
  auto orig_KeySize = KeySize;
  auto orig_pReadbackKey = pReadbackKey;
  auto unwrapped_pCryptoSession = unwrap(pCryptoSession);
  auto ret = m_pID3D11VideoContext->GetEncryptionBltKey(
    unwrapped_pCryptoSession, 
    KeySize, 
    pReadbackKey
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "GetEncryptionBltKey", &ret, {
    {"pCryptoSession", {(void*)&orig_pCryptoSession, (void*)&pCryptoSession}},
    {"KeySize", {(void*)&orig_KeySize, (void*)&KeySize}},
    {"pReadbackKey", {(void*)&orig_pReadbackKey, (void*)&pReadbackKey}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::NegotiateAuthenticatedChannelKeyExchange(
  ID3D11AuthenticatedChannel * pChannel, 
  UINT DataSize, 
  void * pData
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pChannel = pChannel;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto unwrapped_pChannel = unwrap(pChannel);
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11VideoContext->NegotiateAuthenticatedChannelKeyExchange(
    unwrapped_pChannel, 
    DataSize, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "NegotiateAuthenticatedChannelKeyExchange", &ret, {
    {"pChannel", {(void*)&orig_pChannel, (void*)&pChannel}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::QueryAuthenticatedChannel(
  ID3D11AuthenticatedChannel * pChannel, 
  UINT InputSize, 
  const void * pInput, 
  UINT OutputSize, 
  void * pOutput
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pChannel = pChannel;
  auto orig_InputSize = InputSize;
  auto orig_pInput = pInput;
  auto orig_OutputSize = OutputSize;
  auto orig_pOutput = pOutput;
  auto unwrapped_pChannel = unwrap(pChannel);
  auto ret = m_pID3D11VideoContext->QueryAuthenticatedChannel(
    unwrapped_pChannel, 
    InputSize, 
    pInput, 
    OutputSize, 
    pOutput
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "QueryAuthenticatedChannel", &ret, {
    {"pChannel", {(void*)&orig_pChannel, (void*)&pChannel}},
    {"InputSize", {(void*)&orig_InputSize, (void*)&InputSize}},
    {"pInput", {(void*)&orig_pInput, (void*)&pInput}},
    {"OutputSize", {(void*)&orig_OutputSize, (void*)&OutputSize}},
    {"pOutput", {(void*)&orig_pOutput, (void*)&pOutput}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::ConfigureAuthenticatedChannel(
  ID3D11AuthenticatedChannel * pChannel, 
  UINT InputSize, 
  const void * pInput, 
  D3D11_AUTHENTICATED_CONFIGURE_OUTPUT * pOutput
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pChannel = pChannel;
  auto orig_InputSize = InputSize;
  auto orig_pInput = pInput;
  auto orig_pOutput = pOutput;
  auto unwrapped_pChannel = unwrap(pChannel);
  auto ret = m_pID3D11VideoContext->ConfigureAuthenticatedChannel(
    unwrapped_pChannel, 
    InputSize, 
    pInput, 
    pOutput
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "ConfigureAuthenticatedChannel", &ret, {
    {"pChannel", {(void*)&orig_pChannel, (void*)&pChannel}},
    {"InputSize", {(void*)&orig_InputSize, (void*)&InputSize}},
    {"pInput", {(void*)&orig_pInput, (void*)&pInput}},
    {"pOutput", {(void*)&orig_pOutput, (void*)&pOutput}},
  });
  return ret;
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorSetStreamRotation(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL Enable, 
  D3D11_VIDEO_PROCESSOR_ROTATION Rotation
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_Enable = Enable;
  auto orig_Rotation = Rotation;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorSetStreamRotation(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    Enable, 
    Rotation
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorSetStreamRotation", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"Enable", {(void*)&orig_Enable, (void*)&Enable}},
    {"Rotation", {(void*)&orig_Rotation, (void*)&Rotation}},
  });
}
void __stdcall WrappedID3D11VideoContext3::VideoProcessorGetStreamRotation(
  ID3D11VideoProcessor * pVideoProcessor, 
  UINT StreamIndex, 
  BOOL * pEnable, 
  D3D11_VIDEO_PROCESSOR_ROTATION * pRotation
) {
  assert(m_pID3D11VideoContext);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pVideoProcessor = pVideoProcessor;
  auto orig_StreamIndex = StreamIndex;
  auto orig_pEnable = pEnable;
  auto orig_pRotation = pRotation;
  auto unwrapped_pVideoProcessor = unwrap(pVideoProcessor);
  m_pID3D11VideoContext->VideoProcessorGetStreamRotation(
    unwrapped_pVideoProcessor, 
    StreamIndex, 
    pEnable, 
    pRotation
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11VideoContext", "VideoProcessorGetStreamRotation", nullptr, {
    {"pVideoProcessor", {(void*)&orig_pVideoProcessor, (void*)&pVideoProcessor}},
    {"StreamIndex", {(void*)&orig_StreamIndex, (void*)&StreamIndex}},
    {"pEnable", {(void*)&orig_pEnable, (void*)&pEnable}},
    {"pRotation", {(void*)&orig_pRotation, (void*)&pRotation}},
  });
}
void __stdcall WrappedID3D11VideoContext3::GetDevice(
  ID3D11Device ** ppDevice
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppDevice = ppDevice;
  m_pID3D11DeviceChild->GetDevice(
    ppDevice
  );
  if (recursionFlag)
    return;
  getRecursionFlag() = false;
  if(*ppDevice)
    HandleWrap(__uuidof(ID3D11Device), (void**)ppDevice);
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetDevice", nullptr, {
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
  });
}
HRESULT __stdcall WrappedID3D11VideoContext3::GetPrivateData(
  const GUID & guid, 
  UINT * pDataSize, 
  void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pDataSize = pDataSize;
  auto orig_pData = pData;
  auto unwrapped_pDataSize = unwrap(pDataSize);
  auto ret = m_pID3D11DeviceChild->GetPrivateData(
    guid, 
    unwrapped_pDataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "GetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pDataSize", {(void*)&orig_pDataSize, (void*)&pDataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::SetPrivateData(
  const GUID & guid, 
  UINT DataSize, 
  const void * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_DataSize = DataSize;
  auto orig_pData = pData;
  auto ret = m_pID3D11DeviceChild->SetPrivateData(
    guid, 
    DataSize, 
    pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateData", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"DataSize", {(void*)&orig_DataSize, (void*)&DataSize}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::SetPrivateDataInterface(
  const GUID & guid, 
  const struct IUnknown * pData
) {
  assert(m_pID3D11DeviceChild);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_guid = guid;
  auto orig_pData = pData;
  auto unwrapped_pData = unwrap(pData);
  auto ret = m_pID3D11DeviceChild->SetPrivateDataInterface(
    guid, 
    unwrapped_pData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11DeviceChild", "SetPrivateDataInterface", &ret, {
    {"guid", {(void*)&orig_guid, (void*)&guid}},
    {"pData", {(void*)&orig_pData, (void*)&pData}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11VideoContext3::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11VideoContext3)) {
      *ppvObject = (ID3D11VideoContext3*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11VideoContext2)) {
      *ppvObject = (ID3D11VideoContext2*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11VideoContext1)) {
      *ppvObject = (ID3D11VideoContext1*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11VideoContext)) {
      *ppvObject = (ID3D11VideoContext*)this;
      return ret;
    }
    if(riid == __uuidof(ID3D11DeviceChild)) {
      *ppvObject = (ID3D11DeviceChild*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoContext3::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11VideoContext3::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflectionType::GetDesc(
  D3D11_SHADER_TYPE_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflectionType->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
struct ID3D11ShaderReflectionType * __stdcall WrappedID3D11ShaderReflectionType::GetMemberTypeByIndex(
  UINT Index
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D11ShaderReflectionType->GetMemberTypeByIndex(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetMemberTypeByIndex", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
struct ID3D11ShaderReflectionType * __stdcall WrappedID3D11ShaderReflectionType::GetMemberTypeByName(
  LPCSTR Name
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D11ShaderReflectionType->GetMemberTypeByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetMemberTypeByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
LPCSTR __stdcall WrappedID3D11ShaderReflectionType::GetMemberTypeName(
  UINT Index
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D11ShaderReflectionType->GetMemberTypeName(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetMemberTypeName", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflectionType::IsEqual(
  struct ID3D11ShaderReflectionType * pType
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pType = pType;
  auto unwrapped_pType = unwrap(pType);
  auto ret = m_pID3D11ShaderReflectionType->IsEqual(
    unwrapped_pType
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "IsEqual", &ret, {
    {"pType", {(void*)&orig_pType, (void*)&pType}},
  });
  return ret;
}
struct ID3D11ShaderReflectionType * __stdcall WrappedID3D11ShaderReflectionType::GetSubType() {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflectionType->GetSubType();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetSubType", &ret, {
  });
  return ret;
}
struct ID3D11ShaderReflectionType * __stdcall WrappedID3D11ShaderReflectionType::GetBaseClass() {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflectionType->GetBaseClass();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetBaseClass", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflectionType::GetNumInterfaces() {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflectionType->GetNumInterfaces();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetNumInterfaces", &ret, {
  });
  return ret;
}
struct ID3D11ShaderReflectionType * __stdcall WrappedID3D11ShaderReflectionType::GetInterfaceByIndex(
  UINT uIndex
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uIndex = uIndex;
  auto ret = m_pID3D11ShaderReflectionType->GetInterfaceByIndex(
    uIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "GetInterfaceByIndex", &ret, {
    {"uIndex", {(void*)&orig_uIndex, (void*)&uIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflectionType::IsOfType(
  struct ID3D11ShaderReflectionType * pType
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pType = pType;
  auto unwrapped_pType = unwrap(pType);
  auto ret = m_pID3D11ShaderReflectionType->IsOfType(
    unwrapped_pType
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "IsOfType", &ret, {
    {"pType", {(void*)&orig_pType, (void*)&pType}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflectionType::ImplementsInterface(
  struct ID3D11ShaderReflectionType * pBase
) {
  assert(m_pID3D11ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBase = pBase;
  auto unwrapped_pBase = unwrap(pBase);
  auto ret = m_pID3D11ShaderReflectionType->ImplementsInterface(
    unwrapped_pBase
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionType", "ImplementsInterface", &ret, {
    {"pBase", {(void*)&orig_pBase, (void*)&pBase}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflectionVariable::GetDesc(
  D3D11_SHADER_VARIABLE_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflectionVariable->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionVariable", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11ShaderReflectionType * __stdcall WrappedID3D11ShaderReflectionVariable::GetType() {
  assert(m_pID3D11ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflectionVariable->GetType();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionVariable", "GetType", &ret, {
  });
  return ret;
}
ID3D11ShaderReflectionConstantBuffer * __stdcall WrappedID3D11ShaderReflectionVariable::GetBuffer() {
  assert(m_pID3D11ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflectionVariable->GetBuffer();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionVariable", "GetBuffer", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflectionVariable::GetInterfaceSlot(
  UINT uArrayIndex
) {
  assert(m_pID3D11ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uArrayIndex = uArrayIndex;
  auto ret = m_pID3D11ShaderReflectionVariable->GetInterfaceSlot(
    uArrayIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionVariable", "GetInterfaceSlot", &ret, {
    {"uArrayIndex", {(void*)&orig_uArrayIndex, (void*)&uArrayIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflectionConstantBuffer::GetDesc(
  D3D11_SHADER_BUFFER_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflectionConstantBuffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D11ShaderReflectionConstantBuffer->GetDesc(
    unwrapped_pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionConstantBuffer", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11ShaderReflectionVariable * __stdcall WrappedID3D11ShaderReflectionConstantBuffer::GetVariableByIndex(
  UINT Index
) {
  assert(m_pID3D11ShaderReflectionConstantBuffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D11ShaderReflectionConstantBuffer->GetVariableByIndex(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionConstantBuffer", "GetVariableByIndex", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
ID3D11ShaderReflectionVariable * __stdcall WrappedID3D11ShaderReflectionConstantBuffer::GetVariableByName(
  LPCSTR Name
) {
  assert(m_pID3D11ShaderReflectionConstantBuffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D11ShaderReflectionConstantBuffer->GetVariableByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflectionConstantBuffer", "GetVariableByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11ShaderReflection)) {
      *ppvObject = (ID3D11ShaderReflection*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ShaderReflection::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ShaderReflection::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetDesc(
  D3D11_SHADER_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11ShaderReflectionConstantBuffer * __stdcall WrappedID3D11ShaderReflection::GetConstantBufferByIndex(
  UINT Index
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D11ShaderReflection->GetConstantBufferByIndex(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetConstantBufferByIndex", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
ID3D11ShaderReflectionConstantBuffer * __stdcall WrappedID3D11ShaderReflection::GetConstantBufferByName(
  LPCSTR Name
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D11ShaderReflection->GetConstantBufferByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetConstantBufferByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetResourceBindingDesc(
  UINT ResourceIndex, 
  D3D11_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ResourceIndex = ResourceIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflection->GetResourceBindingDesc(
    ResourceIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetResourceBindingDesc", &ret, {
    {"ResourceIndex", {(void*)&orig_ResourceIndex, (void*)&ResourceIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetInputParameterDesc(
  UINT ParameterIndex, 
  D3D11_SIGNATURE_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflection->GetInputParameterDesc(
    ParameterIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetInputParameterDesc", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetOutputParameterDesc(
  UINT ParameterIndex, 
  D3D11_SIGNATURE_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflection->GetOutputParameterDesc(
    ParameterIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetOutputParameterDesc", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetPatchConstantParameterDesc(
  UINT ParameterIndex, 
  D3D11_SIGNATURE_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflection->GetPatchConstantParameterDesc(
    ParameterIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetPatchConstantParameterDesc", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11ShaderReflectionVariable * __stdcall WrappedID3D11ShaderReflection::GetVariableByName(
  LPCSTR Name
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D11ShaderReflection->GetVariableByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetVariableByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetResourceBindingDescByName(
  LPCSTR Name, 
  D3D11_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11ShaderReflection->GetResourceBindingDescByName(
    Name, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetResourceBindingDescByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflection::GetMovInstructionCount() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetMovInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetMovInstructionCount", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflection::GetMovcInstructionCount() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetMovcInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetMovcInstructionCount", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflection::GetConversionInstructionCount() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetConversionInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetConversionInstructionCount", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflection::GetBitwiseInstructionCount() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetBitwiseInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetBitwiseInstructionCount", &ret, {
  });
  return ret;
}
D3D_PRIMITIVE __stdcall WrappedID3D11ShaderReflection::GetGSInputPrimitive() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetGSInputPrimitive();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetGSInputPrimitive", &ret, {
  });
  return ret;
}
BOOL __stdcall WrappedID3D11ShaderReflection::IsSampleFrequencyShader() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->IsSampleFrequencyShader();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "IsSampleFrequencyShader", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflection::GetNumInterfaceSlots() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetNumInterfaceSlots();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetNumInterfaceSlots", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ShaderReflection::GetMinFeatureLevel(
  enum D3D_FEATURE_LEVEL * pLevel
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLevel = pLevel;
  auto ret = m_pID3D11ShaderReflection->GetMinFeatureLevel(
    pLevel
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetMinFeatureLevel", &ret, {
    {"pLevel", {(void*)&orig_pLevel, (void*)&pLevel}},
  });
  return ret;
}
UINT __stdcall WrappedID3D11ShaderReflection::GetThreadGroupSize(
  UINT * pSizeX, 
  UINT * pSizeY, 
  UINT * pSizeZ
) {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSizeX = pSizeX;
  auto orig_pSizeY = pSizeY;
  auto orig_pSizeZ = pSizeZ;
  auto ret = m_pID3D11ShaderReflection->GetThreadGroupSize(
    pSizeX, 
    pSizeY, 
    pSizeZ
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetThreadGroupSize", &ret, {
    {"pSizeX", {(void*)&orig_pSizeX, (void*)&pSizeX}},
    {"pSizeY", {(void*)&orig_pSizeY, (void*)&pSizeY}},
    {"pSizeZ", {(void*)&orig_pSizeZ, (void*)&pSizeZ}},
  });
  return ret;
}
UINT64 __stdcall WrappedID3D11ShaderReflection::GetRequiresFlags() {
  assert(m_pID3D11ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D11ShaderReflection->GetRequiresFlags();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ShaderReflection", "GetRequiresFlags", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11LibraryReflection::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11LibraryReflection)) {
      *ppvObject = (ID3D11LibraryReflection*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11LibraryReflection::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11LibraryReflection::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11LibraryReflection::GetDesc(
  D3D11_LIBRARY_DESC * pDesc
) {
  assert(m_pID3D11LibraryReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11LibraryReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11LibraryReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11FunctionReflection * __stdcall WrappedID3D11LibraryReflection::GetFunctionByIndex(
  INT FunctionIndex
) {
  assert(m_pID3D11LibraryReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_FunctionIndex = FunctionIndex;
  auto ret = m_pID3D11LibraryReflection->GetFunctionByIndex(
    FunctionIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11LibraryReflection", "GetFunctionByIndex", &ret, {
    {"FunctionIndex", {(void*)&orig_FunctionIndex, (void*)&FunctionIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionReflection::GetDesc(
  D3D11_FUNCTION_DESC * pDesc
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11FunctionReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11ShaderReflectionConstantBuffer * __stdcall WrappedID3D11FunctionReflection::GetConstantBufferByIndex(
  UINT BufferIndex
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_BufferIndex = BufferIndex;
  auto ret = m_pID3D11FunctionReflection->GetConstantBufferByIndex(
    BufferIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetConstantBufferByIndex", &ret, {
    {"BufferIndex", {(void*)&orig_BufferIndex, (void*)&BufferIndex}},
  });
  return ret;
}
ID3D11ShaderReflectionConstantBuffer * __stdcall WrappedID3D11FunctionReflection::GetConstantBufferByName(
  LPCSTR Name
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D11FunctionReflection->GetConstantBufferByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetConstantBufferByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionReflection::GetResourceBindingDesc(
  UINT ResourceIndex, 
  D3D11_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ResourceIndex = ResourceIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11FunctionReflection->GetResourceBindingDesc(
    ResourceIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetResourceBindingDesc", &ret, {
    {"ResourceIndex", {(void*)&orig_ResourceIndex, (void*)&ResourceIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11ShaderReflectionVariable * __stdcall WrappedID3D11FunctionReflection::GetVariableByName(
  LPCSTR Name
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D11FunctionReflection->GetVariableByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetVariableByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionReflection::GetResourceBindingDescByName(
  LPCSTR Name, 
  D3D11_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11FunctionReflection->GetResourceBindingDescByName(
    Name, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetResourceBindingDescByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D11FunctionParameterReflection * __stdcall WrappedID3D11FunctionReflection::GetFunctionParameter(
  INT ParameterIndex
) {
  assert(m_pID3D11FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto ret = m_pID3D11FunctionReflection->GetFunctionParameter(
    ParameterIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionReflection", "GetFunctionParameter", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionParameterReflection::GetDesc(
  D3D11_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D11FunctionParameterReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D11FunctionParameterReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionParameterReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Module::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Module)) {
      *ppvObject = (ID3D11Module*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Module::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Module::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11Module::CreateInstance(
  LPCSTR pNamespace, 
  struct ID3D11ModuleInstance ** ppModuleInstance
) {
  assert(m_pID3D11Module);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pNamespace = pNamespace;
  auto orig_ppModuleInstance = ppModuleInstance;
  auto ret = m_pID3D11Module->CreateInstance(
    pNamespace, 
    ppModuleInstance
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppModuleInstance && *ppModuleInstance ) *ppModuleInstance = getWrapper<ID3D11ModuleInstance, WrappedID3D11ModuleInstance>(*ppModuleInstance);
  dumpMethodEvent((void*)this, "ID3D11Module", "CreateInstance", &ret, {
    {"pNamespace", {(void*)&orig_pNamespace, (void*)&pNamespace}},
    {"ppModuleInstance", {(void*)&orig_ppModuleInstance, (void*)&ppModuleInstance}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11ModuleInstance)) {
      *ppvObject = (ID3D11ModuleInstance*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ModuleInstance::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11ModuleInstance::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindConstantBuffer(
  UINT uSrcSlot, 
  UINT uDstSlot, 
  UINT cbDstOffset
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uSrcSlot = uSrcSlot;
  auto orig_uDstSlot = uDstSlot;
  auto orig_cbDstOffset = cbDstOffset;
  auto ret = m_pID3D11ModuleInstance->BindConstantBuffer(
    uSrcSlot, 
    uDstSlot, 
    cbDstOffset
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindConstantBuffer", &ret, {
    {"uSrcSlot", {(void*)&orig_uSrcSlot, (void*)&uSrcSlot}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"cbDstOffset", {(void*)&orig_cbDstOffset, (void*)&cbDstOffset}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindConstantBufferByName(
  LPCSTR pName, 
  UINT uDstSlot, 
  UINT cbDstOffset
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pName = pName;
  auto orig_uDstSlot = uDstSlot;
  auto orig_cbDstOffset = cbDstOffset;
  auto ret = m_pID3D11ModuleInstance->BindConstantBufferByName(
    pName, 
    uDstSlot, 
    cbDstOffset
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindConstantBufferByName", &ret, {
    {"pName", {(void*)&orig_pName, (void*)&pName}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"cbDstOffset", {(void*)&orig_cbDstOffset, (void*)&cbDstOffset}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindResource(
  UINT uSrcSlot, 
  UINT uDstSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uSrcSlot = uSrcSlot;
  auto orig_uDstSlot = uDstSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindResource(
    uSrcSlot, 
    uDstSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindResource", &ret, {
    {"uSrcSlot", {(void*)&orig_uSrcSlot, (void*)&uSrcSlot}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindResourceByName(
  LPCSTR pName, 
  UINT uDstSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pName = pName;
  auto orig_uDstSlot = uDstSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindResourceByName(
    pName, 
    uDstSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindResourceByName", &ret, {
    {"pName", {(void*)&orig_pName, (void*)&pName}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindSampler(
  UINT uSrcSlot, 
  UINT uDstSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uSrcSlot = uSrcSlot;
  auto orig_uDstSlot = uDstSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindSampler(
    uSrcSlot, 
    uDstSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindSampler", &ret, {
    {"uSrcSlot", {(void*)&orig_uSrcSlot, (void*)&uSrcSlot}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindSamplerByName(
  LPCSTR pName, 
  UINT uDstSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pName = pName;
  auto orig_uDstSlot = uDstSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindSamplerByName(
    pName, 
    uDstSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindSamplerByName", &ret, {
    {"pName", {(void*)&orig_pName, (void*)&pName}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindUnorderedAccessView(
  UINT uSrcSlot, 
  UINT uDstSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uSrcSlot = uSrcSlot;
  auto orig_uDstSlot = uDstSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindUnorderedAccessView(
    uSrcSlot, 
    uDstSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindUnorderedAccessView", &ret, {
    {"uSrcSlot", {(void*)&orig_uSrcSlot, (void*)&uSrcSlot}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindUnorderedAccessViewByName(
  LPCSTR pName, 
  UINT uDstSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pName = pName;
  auto orig_uDstSlot = uDstSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindUnorderedAccessViewByName(
    pName, 
    uDstSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindUnorderedAccessViewByName", &ret, {
    {"pName", {(void*)&orig_pName, (void*)&pName}},
    {"uDstSlot", {(void*)&orig_uDstSlot, (void*)&uDstSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindResourceAsUnorderedAccessView(
  UINT uSrcSrvSlot, 
  UINT uDstUavSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uSrcSrvSlot = uSrcSrvSlot;
  auto orig_uDstUavSlot = uDstUavSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindResourceAsUnorderedAccessView(
    uSrcSrvSlot, 
    uDstUavSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindResourceAsUnorderedAccessView", &ret, {
    {"uSrcSrvSlot", {(void*)&orig_uSrcSrvSlot, (void*)&uSrcSrvSlot}},
    {"uDstUavSlot", {(void*)&orig_uDstUavSlot, (void*)&uDstUavSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11ModuleInstance::BindResourceAsUnorderedAccessViewByName(
  LPCSTR pSrvName, 
  UINT uDstUavSlot, 
  UINT uCount
) {
  assert(m_pID3D11ModuleInstance);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrvName = pSrvName;
  auto orig_uDstUavSlot = uDstUavSlot;
  auto orig_uCount = uCount;
  auto ret = m_pID3D11ModuleInstance->BindResourceAsUnorderedAccessViewByName(
    pSrvName, 
    uDstUavSlot, 
    uCount
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11ModuleInstance", "BindResourceAsUnorderedAccessViewByName", &ret, {
    {"pSrvName", {(void*)&orig_pSrvName, (void*)&pSrvName}},
    {"uDstUavSlot", {(void*)&orig_uDstUavSlot, (void*)&uDstUavSlot}},
    {"uCount", {(void*)&orig_uCount, (void*)&uCount}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Linker::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11Linker)) {
      *ppvObject = (ID3D11Linker*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Linker::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11Linker::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11Linker::Link(
  struct ID3D11ModuleInstance * pEntry, 
  LPCSTR pEntryName, 
  LPCSTR pTargetName, 
  UINT uFlags, 
  ID3DBlob ** ppShaderBlob, 
  ID3DBlob ** ppErrorBuffer
) {
  assert(m_pID3D11Linker);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pEntry = pEntry;
  auto orig_pEntryName = pEntryName;
  auto orig_pTargetName = pTargetName;
  auto orig_uFlags = uFlags;
  auto orig_ppShaderBlob = ppShaderBlob;
  auto orig_ppErrorBuffer = ppErrorBuffer;
  auto unwrapped_pEntry = unwrap(pEntry);
  auto ret = m_pID3D11Linker->Link(
    unwrapped_pEntry, 
    pEntryName, 
    pTargetName, 
    uFlags, 
    ppShaderBlob, 
    ppErrorBuffer
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Linker", "Link", &ret, {
    {"pEntry", {(void*)&orig_pEntry, (void*)&pEntry}},
    {"pEntryName", {(void*)&orig_pEntryName, (void*)&pEntryName}},
    {"pTargetName", {(void*)&orig_pTargetName, (void*)&pTargetName}},
    {"uFlags", {(void*)&orig_uFlags, (void*)&uFlags}},
    {"ppShaderBlob", {(void*)&orig_ppShaderBlob, (void*)&ppShaderBlob}},
    {"ppErrorBuffer", {(void*)&orig_ppErrorBuffer, (void*)&ppErrorBuffer}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Linker::UseLibrary(
  struct ID3D11ModuleInstance * pLibraryMI
) {
  assert(m_pID3D11Linker);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLibraryMI = pLibraryMI;
  auto unwrapped_pLibraryMI = unwrap(pLibraryMI);
  auto ret = m_pID3D11Linker->UseLibrary(
    unwrapped_pLibraryMI
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Linker", "UseLibrary", &ret, {
    {"pLibraryMI", {(void*)&orig_pLibraryMI, (void*)&pLibraryMI}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11Linker::AddClipPlaneFromCBuffer(
  UINT uCBufferSlot, 
  UINT uCBufferEntry
) {
  assert(m_pID3D11Linker);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uCBufferSlot = uCBufferSlot;
  auto orig_uCBufferEntry = uCBufferEntry;
  auto ret = m_pID3D11Linker->AddClipPlaneFromCBuffer(
    uCBufferSlot, 
    uCBufferEntry
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11Linker", "AddClipPlaneFromCBuffer", &ret, {
    {"uCBufferSlot", {(void*)&orig_uCBufferSlot, (void*)&uCBufferSlot}},
    {"uCBufferEntry", {(void*)&orig_uCBufferEntry, (void*)&uCBufferEntry}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11LinkingNode::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11LinkingNode)) {
      *ppvObject = (ID3D11LinkingNode*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11LinkingNode::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11LinkingNode::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D11FunctionLinkingGraph)) {
      *ppvObject = (ID3D11FunctionLinkingGraph*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D11FunctionLinkingGraph::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D11FunctionLinkingGraph::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::CreateModuleInstance(
  struct ID3D11ModuleInstance ** ppModuleInstance, 
  ID3DBlob ** ppErrorBuffer
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppModuleInstance = ppModuleInstance;
  auto orig_ppErrorBuffer = ppErrorBuffer;
  auto ret = m_pID3D11FunctionLinkingGraph->CreateModuleInstance(
    ppModuleInstance, 
    ppErrorBuffer
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppModuleInstance && *ppModuleInstance ) *ppModuleInstance = getWrapper<ID3D11ModuleInstance, WrappedID3D11ModuleInstance>(*ppModuleInstance);
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "CreateModuleInstance", &ret, {
    {"ppModuleInstance", {(void*)&orig_ppModuleInstance, (void*)&ppModuleInstance}},
    {"ppErrorBuffer", {(void*)&orig_ppErrorBuffer, (void*)&ppErrorBuffer}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::SetInputSignature(
  const D3D11_PARAMETER_DESC * pInputParameters, 
  UINT cInputParameters, 
  struct ID3D11LinkingNode ** ppInputNode
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pInputParameters = pInputParameters;
  auto orig_cInputParameters = cInputParameters;
  auto orig_ppInputNode = ppInputNode;
  auto unwrapped_pInputParameters = unwrap(pInputParameters);
  auto ret = m_pID3D11FunctionLinkingGraph->SetInputSignature(
    unwrapped_pInputParameters, 
    cInputParameters, 
    ppInputNode
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppInputNode && *ppInputNode ) *ppInputNode = getWrapper<ID3D11LinkingNode, WrappedID3D11LinkingNode>(*ppInputNode);
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "SetInputSignature", &ret, {
    {"pInputParameters", {(void*)&orig_pInputParameters, (void*)&pInputParameters}},
    {"cInputParameters", {(void*)&orig_cInputParameters, (void*)&cInputParameters}},
    {"ppInputNode", {(void*)&orig_ppInputNode, (void*)&ppInputNode}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::SetOutputSignature(
  const D3D11_PARAMETER_DESC * pOutputParameters, 
  UINT cOutputParameters, 
  struct ID3D11LinkingNode ** ppOutputNode
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pOutputParameters = pOutputParameters;
  auto orig_cOutputParameters = cOutputParameters;
  auto orig_ppOutputNode = ppOutputNode;
  auto unwrapped_pOutputParameters = unwrap(pOutputParameters);
  auto ret = m_pID3D11FunctionLinkingGraph->SetOutputSignature(
    unwrapped_pOutputParameters, 
    cOutputParameters, 
    ppOutputNode
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppOutputNode && *ppOutputNode ) *ppOutputNode = getWrapper<ID3D11LinkingNode, WrappedID3D11LinkingNode>(*ppOutputNode);
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "SetOutputSignature", &ret, {
    {"pOutputParameters", {(void*)&orig_pOutputParameters, (void*)&pOutputParameters}},
    {"cOutputParameters", {(void*)&orig_cOutputParameters, (void*)&cOutputParameters}},
    {"ppOutputNode", {(void*)&orig_ppOutputNode, (void*)&ppOutputNode}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::CallFunction(
  LPCSTR pModuleInstanceNamespace, 
  struct ID3D11Module * pModuleWithFunctionPrototype, 
  LPCSTR pFunctionName, 
  struct ID3D11LinkingNode ** ppCallNode
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pModuleInstanceNamespace = pModuleInstanceNamespace;
  auto orig_pModuleWithFunctionPrototype = pModuleWithFunctionPrototype;
  auto orig_pFunctionName = pFunctionName;
  auto orig_ppCallNode = ppCallNode;
  auto unwrapped_pModuleWithFunctionPrototype = unwrap(pModuleWithFunctionPrototype);
  auto ret = m_pID3D11FunctionLinkingGraph->CallFunction(
    pModuleInstanceNamespace, 
    unwrapped_pModuleWithFunctionPrototype, 
    pFunctionName, 
    ppCallNode
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCallNode && *ppCallNode ) *ppCallNode = getWrapper<ID3D11LinkingNode, WrappedID3D11LinkingNode>(*ppCallNode);
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "CallFunction", &ret, {
    {"pModuleInstanceNamespace", {(void*)&orig_pModuleInstanceNamespace, (void*)&pModuleInstanceNamespace}},
    {"pModuleWithFunctionPrototype", {(void*)&orig_pModuleWithFunctionPrototype, (void*)&pModuleWithFunctionPrototype}},
    {"pFunctionName", {(void*)&orig_pFunctionName, (void*)&pFunctionName}},
    {"ppCallNode", {(void*)&orig_ppCallNode, (void*)&ppCallNode}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::PassValue(
  struct ID3D11LinkingNode * pSrcNode, 
  INT SrcParameterIndex, 
  struct ID3D11LinkingNode * pDstNode, 
  INT DstParameterIndex
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcNode = pSrcNode;
  auto orig_SrcParameterIndex = SrcParameterIndex;
  auto orig_pDstNode = pDstNode;
  auto orig_DstParameterIndex = DstParameterIndex;
  auto unwrapped_pSrcNode = unwrap(pSrcNode);
  auto unwrapped_pDstNode = unwrap(pDstNode);
  auto ret = m_pID3D11FunctionLinkingGraph->PassValue(
    unwrapped_pSrcNode, 
    SrcParameterIndex, 
    unwrapped_pDstNode, 
    DstParameterIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "PassValue", &ret, {
    {"pSrcNode", {(void*)&orig_pSrcNode, (void*)&pSrcNode}},
    {"SrcParameterIndex", {(void*)&orig_SrcParameterIndex, (void*)&SrcParameterIndex}},
    {"pDstNode", {(void*)&orig_pDstNode, (void*)&pDstNode}},
    {"DstParameterIndex", {(void*)&orig_DstParameterIndex, (void*)&DstParameterIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::PassValueWithSwizzle(
  struct ID3D11LinkingNode * pSrcNode, 
  INT SrcParameterIndex, 
  LPCSTR pSrcSwizzle, 
  struct ID3D11LinkingNode * pDstNode, 
  INT DstParameterIndex, 
  LPCSTR pDstSwizzle
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcNode = pSrcNode;
  auto orig_SrcParameterIndex = SrcParameterIndex;
  auto orig_pSrcSwizzle = pSrcSwizzle;
  auto orig_pDstNode = pDstNode;
  auto orig_DstParameterIndex = DstParameterIndex;
  auto orig_pDstSwizzle = pDstSwizzle;
  auto unwrapped_pSrcNode = unwrap(pSrcNode);
  auto unwrapped_pDstNode = unwrap(pDstNode);
  auto ret = m_pID3D11FunctionLinkingGraph->PassValueWithSwizzle(
    unwrapped_pSrcNode, 
    SrcParameterIndex, 
    pSrcSwizzle, 
    unwrapped_pDstNode, 
    DstParameterIndex, 
    pDstSwizzle
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "PassValueWithSwizzle", &ret, {
    {"pSrcNode", {(void*)&orig_pSrcNode, (void*)&pSrcNode}},
    {"SrcParameterIndex", {(void*)&orig_SrcParameterIndex, (void*)&SrcParameterIndex}},
    {"pSrcSwizzle", {(void*)&orig_pSrcSwizzle, (void*)&pSrcSwizzle}},
    {"pDstNode", {(void*)&orig_pDstNode, (void*)&pDstNode}},
    {"DstParameterIndex", {(void*)&orig_DstParameterIndex, (void*)&DstParameterIndex}},
    {"pDstSwizzle", {(void*)&orig_pDstSwizzle, (void*)&pDstSwizzle}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::GetLastError(
  ID3DBlob ** ppErrorBuffer
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppErrorBuffer = ppErrorBuffer;
  auto ret = m_pID3D11FunctionLinkingGraph->GetLastError(
    ppErrorBuffer
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "GetLastError", &ret, {
    {"ppErrorBuffer", {(void*)&orig_ppErrorBuffer, (void*)&ppErrorBuffer}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D11FunctionLinkingGraph::GenerateHlsl(
  UINT uFlags, 
  ID3DBlob ** ppBuffer
) {
  assert(m_pID3D11FunctionLinkingGraph);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uFlags = uFlags;
  auto orig_ppBuffer = ppBuffer;
  auto ret = m_pID3D11FunctionLinkingGraph->GenerateHlsl(
    uFlags, 
    ppBuffer
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D11FunctionLinkingGraph", "GenerateHlsl", &ret, {
    {"uFlags", {(void*)&orig_uFlags, (void*)&uFlags}},
    {"ppBuffer", {(void*)&orig_ppBuffer, (void*)&ppBuffer}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflectionType::GetDesc(
  D3D12_SHADER_TYPE_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflectionType->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
struct ID3D12ShaderReflectionType * __stdcall WrappedID3D12ShaderReflectionType::GetMemberTypeByIndex(
  UINT Index
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D12ShaderReflectionType->GetMemberTypeByIndex(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetMemberTypeByIndex", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
struct ID3D12ShaderReflectionType * __stdcall WrappedID3D12ShaderReflectionType::GetMemberTypeByName(
  LPCSTR Name
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D12ShaderReflectionType->GetMemberTypeByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetMemberTypeByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
LPCSTR __stdcall WrappedID3D12ShaderReflectionType::GetMemberTypeName(
  UINT Index
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D12ShaderReflectionType->GetMemberTypeName(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetMemberTypeName", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflectionType::IsEqual(
  struct ID3D12ShaderReflectionType * pType
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pType = pType;
  auto unwrapped_pType = unwrap(pType);
  auto ret = m_pID3D12ShaderReflectionType->IsEqual(
    unwrapped_pType
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "IsEqual", &ret, {
    {"pType", {(void*)&orig_pType, (void*)&pType}},
  });
  return ret;
}
struct ID3D12ShaderReflectionType * __stdcall WrappedID3D12ShaderReflectionType::GetSubType() {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflectionType->GetSubType();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetSubType", &ret, {
  });
  return ret;
}
struct ID3D12ShaderReflectionType * __stdcall WrappedID3D12ShaderReflectionType::GetBaseClass() {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflectionType->GetBaseClass();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetBaseClass", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflectionType::GetNumInterfaces() {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflectionType->GetNumInterfaces();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetNumInterfaces", &ret, {
  });
  return ret;
}
struct ID3D12ShaderReflectionType * __stdcall WrappedID3D12ShaderReflectionType::GetInterfaceByIndex(
  UINT uIndex
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uIndex = uIndex;
  auto ret = m_pID3D12ShaderReflectionType->GetInterfaceByIndex(
    uIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "GetInterfaceByIndex", &ret, {
    {"uIndex", {(void*)&orig_uIndex, (void*)&uIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflectionType::IsOfType(
  struct ID3D12ShaderReflectionType * pType
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pType = pType;
  auto unwrapped_pType = unwrap(pType);
  auto ret = m_pID3D12ShaderReflectionType->IsOfType(
    unwrapped_pType
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "IsOfType", &ret, {
    {"pType", {(void*)&orig_pType, (void*)&pType}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflectionType::ImplementsInterface(
  struct ID3D12ShaderReflectionType * pBase
) {
  assert(m_pID3D12ShaderReflectionType);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBase = pBase;
  auto unwrapped_pBase = unwrap(pBase);
  auto ret = m_pID3D12ShaderReflectionType->ImplementsInterface(
    unwrapped_pBase
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionType", "ImplementsInterface", &ret, {
    {"pBase", {(void*)&orig_pBase, (void*)&pBase}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflectionVariable::GetDesc(
  D3D12_SHADER_VARIABLE_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflectionVariable->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionVariable", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12ShaderReflectionType * __stdcall WrappedID3D12ShaderReflectionVariable::GetType() {
  assert(m_pID3D12ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflectionVariable->GetType();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionVariable", "GetType", &ret, {
  });
  return ret;
}
ID3D12ShaderReflectionConstantBuffer * __stdcall WrappedID3D12ShaderReflectionVariable::GetBuffer() {
  assert(m_pID3D12ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflectionVariable->GetBuffer();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionVariable", "GetBuffer", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflectionVariable::GetInterfaceSlot(
  UINT uArrayIndex
) {
  assert(m_pID3D12ShaderReflectionVariable);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uArrayIndex = uArrayIndex;
  auto ret = m_pID3D12ShaderReflectionVariable->GetInterfaceSlot(
    uArrayIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionVariable", "GetInterfaceSlot", &ret, {
    {"uArrayIndex", {(void*)&orig_uArrayIndex, (void*)&uArrayIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflectionConstantBuffer::GetDesc(
  D3D12_SHADER_BUFFER_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflectionConstantBuffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto unwrapped_pDesc = unwrap(pDesc);
  auto ret = m_pID3D12ShaderReflectionConstantBuffer->GetDesc(
    unwrapped_pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionConstantBuffer", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12ShaderReflectionVariable * __stdcall WrappedID3D12ShaderReflectionConstantBuffer::GetVariableByIndex(
  UINT Index
) {
  assert(m_pID3D12ShaderReflectionConstantBuffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D12ShaderReflectionConstantBuffer->GetVariableByIndex(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionConstantBuffer", "GetVariableByIndex", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
ID3D12ShaderReflectionVariable * __stdcall WrappedID3D12ShaderReflectionConstantBuffer::GetVariableByName(
  LPCSTR Name
) {
  assert(m_pID3D12ShaderReflectionConstantBuffer);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D12ShaderReflectionConstantBuffer->GetVariableByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflectionConstantBuffer", "GetVariableByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D12ShaderReflection)) {
      *ppvObject = (ID3D12ShaderReflection*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D12ShaderReflection::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D12ShaderReflection::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetDesc(
  D3D12_SHADER_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12ShaderReflectionConstantBuffer * __stdcall WrappedID3D12ShaderReflection::GetConstantBufferByIndex(
  UINT Index
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Index = Index;
  auto ret = m_pID3D12ShaderReflection->GetConstantBufferByIndex(
    Index
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetConstantBufferByIndex", &ret, {
    {"Index", {(void*)&orig_Index, (void*)&Index}},
  });
  return ret;
}
ID3D12ShaderReflectionConstantBuffer * __stdcall WrappedID3D12ShaderReflection::GetConstantBufferByName(
  LPCSTR Name
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D12ShaderReflection->GetConstantBufferByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetConstantBufferByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetResourceBindingDesc(
  UINT ResourceIndex, 
  D3D12_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ResourceIndex = ResourceIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflection->GetResourceBindingDesc(
    ResourceIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetResourceBindingDesc", &ret, {
    {"ResourceIndex", {(void*)&orig_ResourceIndex, (void*)&ResourceIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetInputParameterDesc(
  UINT ParameterIndex, 
  D3D12_SIGNATURE_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflection->GetInputParameterDesc(
    ParameterIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetInputParameterDesc", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetOutputParameterDesc(
  UINT ParameterIndex, 
  D3D12_SIGNATURE_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflection->GetOutputParameterDesc(
    ParameterIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetOutputParameterDesc", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetPatchConstantParameterDesc(
  UINT ParameterIndex, 
  D3D12_SIGNATURE_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflection->GetPatchConstantParameterDesc(
    ParameterIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetPatchConstantParameterDesc", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12ShaderReflectionVariable * __stdcall WrappedID3D12ShaderReflection::GetVariableByName(
  LPCSTR Name
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D12ShaderReflection->GetVariableByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetVariableByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetResourceBindingDescByName(
  LPCSTR Name, 
  D3D12_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12ShaderReflection->GetResourceBindingDescByName(
    Name, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetResourceBindingDescByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflection::GetMovInstructionCount() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetMovInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetMovInstructionCount", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflection::GetMovcInstructionCount() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetMovcInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetMovcInstructionCount", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflection::GetConversionInstructionCount() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetConversionInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetConversionInstructionCount", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflection::GetBitwiseInstructionCount() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetBitwiseInstructionCount();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetBitwiseInstructionCount", &ret, {
  });
  return ret;
}
D3D_PRIMITIVE __stdcall WrappedID3D12ShaderReflection::GetGSInputPrimitive() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetGSInputPrimitive();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetGSInputPrimitive", &ret, {
  });
  return ret;
}
BOOL __stdcall WrappedID3D12ShaderReflection::IsSampleFrequencyShader() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->IsSampleFrequencyShader();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "IsSampleFrequencyShader", &ret, {
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflection::GetNumInterfaceSlots() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetNumInterfaceSlots();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetNumInterfaceSlots", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12ShaderReflection::GetMinFeatureLevel(
  enum D3D_FEATURE_LEVEL * pLevel
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pLevel = pLevel;
  auto ret = m_pID3D12ShaderReflection->GetMinFeatureLevel(
    pLevel
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetMinFeatureLevel", &ret, {
    {"pLevel", {(void*)&orig_pLevel, (void*)&pLevel}},
  });
  return ret;
}
UINT __stdcall WrappedID3D12ShaderReflection::GetThreadGroupSize(
  UINT * pSizeX, 
  UINT * pSizeY, 
  UINT * pSizeZ
) {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSizeX = pSizeX;
  auto orig_pSizeY = pSizeY;
  auto orig_pSizeZ = pSizeZ;
  auto ret = m_pID3D12ShaderReflection->GetThreadGroupSize(
    pSizeX, 
    pSizeY, 
    pSizeZ
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetThreadGroupSize", &ret, {
    {"pSizeX", {(void*)&orig_pSizeX, (void*)&pSizeX}},
    {"pSizeY", {(void*)&orig_pSizeY, (void*)&pSizeY}},
    {"pSizeZ", {(void*)&orig_pSizeZ, (void*)&pSizeZ}},
  });
  return ret;
}
UINT64 __stdcall WrappedID3D12ShaderReflection::GetRequiresFlags() {
  assert(m_pID3D12ShaderReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto ret = m_pID3D12ShaderReflection->GetRequiresFlags();
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12ShaderReflection", "GetRequiresFlags", &ret, {
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12LibraryReflection::QueryInterface(
  const IID & riid, 
  void ** ppvObject
) {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppvObject = ppvObject;
  auto ret = m_pIUnknown->QueryInterface(
    riid, 
    ppvObject
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret) {
    if(riid == __uuidof(ID3D12LibraryReflection)) {
      *ppvObject = (ID3D12LibraryReflection*)this;
      return ret;
    }
    if(riid == __uuidof(IUnknown)) {
      *ppvObject = (IUnknown*)this;
      return ret;
    }
  }
  {
    if(!ret) {
      HandleWrap(riid, ppvObject);
    }
  }
  dumpMethodEvent((void*)this, "IUnknown", "QueryInterface", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppvObject", {(void*)&orig_ppvObject, (void*)&ppvObject}},
  });
  return ret;
}
ULONG __stdcall WrappedID3D12LibraryReflection::AddRef() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->AddRef() - 1;
  if (recursionFlag) {
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "AddRef", &ret, {
  });
  return ret;
}
ULONG __stdcall WrappedID3D12LibraryReflection::Release() {
  assert(m_pIUnknown);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  assert(m_pMain);
  auto ret = m_pMain->Release() - 1;
  if (recursionFlag) {
    if (!ret) { m_pMain->Release(); delete this;}
    return ret;
  }
  getRecursionFlag() = false;
  out() << "// orig=" << ret << "\n";
  dumpMethodEvent((void*)this, "IUnknown", "Release", &ret, {
  });
  if (!ret) { m_pMain->Release(); delete this;}
  return ret;
}
HRESULT __stdcall WrappedID3D12LibraryReflection::GetDesc(
  D3D12_LIBRARY_DESC * pDesc
) {
  assert(m_pID3D12LibraryReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12LibraryReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12LibraryReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12FunctionReflection * __stdcall WrappedID3D12LibraryReflection::GetFunctionByIndex(
  INT FunctionIndex
) {
  assert(m_pID3D12LibraryReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_FunctionIndex = FunctionIndex;
  auto ret = m_pID3D12LibraryReflection->GetFunctionByIndex(
    FunctionIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12LibraryReflection", "GetFunctionByIndex", &ret, {
    {"FunctionIndex", {(void*)&orig_FunctionIndex, (void*)&FunctionIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12FunctionReflection::GetDesc(
  D3D12_FUNCTION_DESC * pDesc
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12FunctionReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12ShaderReflectionConstantBuffer * __stdcall WrappedID3D12FunctionReflection::GetConstantBufferByIndex(
  UINT BufferIndex
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_BufferIndex = BufferIndex;
  auto ret = m_pID3D12FunctionReflection->GetConstantBufferByIndex(
    BufferIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetConstantBufferByIndex", &ret, {
    {"BufferIndex", {(void*)&orig_BufferIndex, (void*)&BufferIndex}},
  });
  return ret;
}
ID3D12ShaderReflectionConstantBuffer * __stdcall WrappedID3D12FunctionReflection::GetConstantBufferByName(
  LPCSTR Name
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D12FunctionReflection->GetConstantBufferByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetConstantBufferByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12FunctionReflection::GetResourceBindingDesc(
  UINT ResourceIndex, 
  D3D12_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ResourceIndex = ResourceIndex;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12FunctionReflection->GetResourceBindingDesc(
    ResourceIndex, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetResourceBindingDesc", &ret, {
    {"ResourceIndex", {(void*)&orig_ResourceIndex, (void*)&ResourceIndex}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12ShaderReflectionVariable * __stdcall WrappedID3D12FunctionReflection::GetVariableByName(
  LPCSTR Name
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto ret = m_pID3D12FunctionReflection->GetVariableByName(
    Name
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetVariableByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12FunctionReflection::GetResourceBindingDescByName(
  LPCSTR Name, 
  D3D12_SHADER_INPUT_BIND_DESC * pDesc
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Name = Name;
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12FunctionReflection->GetResourceBindingDescByName(
    Name, 
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetResourceBindingDescByName", &ret, {
    {"Name", {(void*)&orig_Name, (void*)&Name}},
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
ID3D12FunctionParameterReflection * __stdcall WrappedID3D12FunctionReflection::GetFunctionParameter(
  INT ParameterIndex
) {
  assert(m_pID3D12FunctionReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ParameterIndex = ParameterIndex;
  auto ret = m_pID3D12FunctionReflection->GetFunctionParameter(
    ParameterIndex
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionReflection", "GetFunctionParameter", &ret, {
    {"ParameterIndex", {(void*)&orig_ParameterIndex, (void*)&ParameterIndex}},
  });
  return ret;
}
HRESULT __stdcall WrappedID3D12FunctionParameterReflection::GetDesc(
  D3D12_PARAMETER_DESC * pDesc
) {
  assert(m_pID3D12FunctionParameterReflection);
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pDesc = pDesc;
  auto ret = m_pID3D12FunctionParameterReflection->GetDesc(
    pDesc
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpMethodEvent((void*)this, "ID3D12FunctionParameterReflection", "GetDesc", &ret, {
    {"pDesc", {(void*)&orig_pDesc, (void*)&pDesc}},
  });
  return ret;
}
HRESULT WrappedCreateDXGIFactory(
  const IID & riid, 
  void ** ppFactory
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppFactory = ppFactory;
  auto ret = CreateDXGIFactory(
    riid, 
    ppFactory
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret)
    HandleWrap(riid, (void**)ppFactory);
  dumpFunctionEvent("CreateDXGIFactory", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppFactory", {(void*)&orig_ppFactory, (void*)&ppFactory}},
  });
  return ret;
}
HRESULT WrappedCreateDXGIFactory1(
  const IID & riid, 
  void ** ppFactory
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_riid = riid;
  auto orig_ppFactory = ppFactory;
  auto ret = CreateDXGIFactory1(
    riid, 
    ppFactory
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret)
    HandleWrap(riid, (void**)ppFactory);
  dumpFunctionEvent("CreateDXGIFactory1", &ret, {
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppFactory", {(void*)&orig_ppFactory, (void*)&ppFactory}},
  });
  return ret;
}
UINT WrappedD3D11CalcSubresource(
  UINT MipSlice, 
  UINT ArraySlice, 
  UINT MipLevels
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_MipSlice = MipSlice;
  auto orig_ArraySlice = ArraySlice;
  auto orig_MipLevels = MipLevels;
  auto ret = D3D11CalcSubresource(
    MipSlice, 
    ArraySlice, 
    MipLevels
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpFunctionEvent("D3D11CalcSubresource", &ret, {
    {"MipSlice", {(void*)&orig_MipSlice, (void*)&MipSlice}},
    {"ArraySlice", {(void*)&orig_ArraySlice, (void*)&ArraySlice}},
    {"MipLevels", {(void*)&orig_MipLevels, (void*)&MipLevels}},
  });
  return ret;
}
HRESULT WrappedD3D11CreateDevice(
  IDXGIAdapter * pAdapter, 
  D3D_DRIVER_TYPE DriverType, 
  HMODULE Software, 
  UINT Flags, 
  const D3D_FEATURE_LEVEL * pFeatureLevels, 
  UINT FeatureLevels, 
  UINT SDKVersion, 
  ID3D11Device ** ppDevice, 
  D3D_FEATURE_LEVEL * pFeatureLevel, 
  ID3D11DeviceContext ** ppImmediateContext
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAdapter = pAdapter;
  auto orig_DriverType = DriverType;
  auto orig_Software = Software;
  auto orig_Flags = Flags;
  auto orig_pFeatureLevels = pFeatureLevels;
  auto orig_FeatureLevels = FeatureLevels;
  auto orig_SDKVersion = SDKVersion;
  auto orig_ppDevice = ppDevice;
  auto orig_pFeatureLevel = pFeatureLevel;
  auto orig_ppImmediateContext = ppImmediateContext;
  auto ret = D3D11CreateDevice(
    unwrap(pAdapter), 
    DriverType, 
    Software, 
    Flags, 
    pFeatureLevels, 
    FeatureLevels, 
    SDKVersion, 
    ppDevice, 
    pFeatureLevel, 
    ppImmediateContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDevice && *ppDevice)
    *ppDevice = getWrapper<ID3D11Device, WrappedID3D11Device5>(*ppDevice);
  if (!ret && ppImmediateContext && *ppImmediateContext)
    *ppImmediateContext = getWrapper<ID3D11DeviceContext, WrappedID3D11DeviceContext4>(*ppImmediateContext);
  dumpFunctionEvent("D3D11CreateDevice", &ret, {
    {"pAdapter", {(void*)&orig_pAdapter, (void*)&pAdapter}},
    {"DriverType", {(void*)&orig_DriverType, (void*)&DriverType}},
    {"Software", {(void*)&orig_Software, (void*)&Software}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pFeatureLevels", {(void*)&orig_pFeatureLevels, (void*)&pFeatureLevels}},
    {"FeatureLevels", {(void*)&orig_FeatureLevels, (void*)&FeatureLevels}},
    {"SDKVersion", {(void*)&orig_SDKVersion, (void*)&SDKVersion}},
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
    {"pFeatureLevel", {(void*)&orig_pFeatureLevel, (void*)&pFeatureLevel}},
    {"ppImmediateContext", {(void*)&orig_ppImmediateContext, (void*)&ppImmediateContext}},
  });
  return ret;
}
HRESULT WrappedD3D11CreateDeviceAndSwapChain(
  IDXGIAdapter * pAdapter, 
  D3D_DRIVER_TYPE DriverType, 
  HMODULE Software, 
  UINT Flags, 
  const D3D_FEATURE_LEVEL * pFeatureLevels, 
  UINT FeatureLevels, 
  UINT SDKVersion, 
  const DXGI_SWAP_CHAIN_DESC * pSwapChainDesc, 
  IDXGISwapChain ** ppSwapChain, 
  ID3D11Device ** ppDevice, 
  D3D_FEATURE_LEVEL * pFeatureLevel, 
  ID3D11DeviceContext ** ppImmediateContext
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pAdapter = pAdapter;
  auto orig_DriverType = DriverType;
  auto orig_Software = Software;
  auto orig_Flags = Flags;
  auto orig_pFeatureLevels = pFeatureLevels;
  auto orig_FeatureLevels = FeatureLevels;
  auto orig_SDKVersion = SDKVersion;
  auto orig_pSwapChainDesc = pSwapChainDesc;
  auto orig_ppSwapChain = ppSwapChain;
  auto orig_ppDevice = ppDevice;
  auto orig_pFeatureLevel = pFeatureLevel;
  auto orig_ppImmediateContext = ppImmediateContext;
  auto ret = D3D11CreateDeviceAndSwapChain(
    unwrap(pAdapter), 
    DriverType, 
    Software, 
    Flags, 
    pFeatureLevels, 
    FeatureLevels, 
    SDKVersion, 
    unwrap(pSwapChainDesc), 
    ppSwapChain, 
    ppDevice, 
    pFeatureLevel, 
    ppImmediateContext
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSwapChain && *ppSwapChain)
    *ppSwapChain = getWrapper<IDXGISwapChain, WrappedIDXGISwapChain4>(*ppSwapChain);
  if (!ret && ppDevice && *ppDevice)
    *ppDevice = getWrapper<ID3D11Device, WrappedID3D11Device5>(*ppDevice);
  if (!ret && ppImmediateContext && *ppImmediateContext)
    *ppImmediateContext = getWrapper<ID3D11DeviceContext, WrappedID3D11DeviceContext4>(*ppImmediateContext);
  dumpFunctionEvent("D3D11CreateDeviceAndSwapChain", &ret, {
    {"pAdapter", {(void*)&orig_pAdapter, (void*)&pAdapter}},
    {"DriverType", {(void*)&orig_DriverType, (void*)&DriverType}},
    {"Software", {(void*)&orig_Software, (void*)&Software}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pFeatureLevels", {(void*)&orig_pFeatureLevels, (void*)&pFeatureLevels}},
    {"FeatureLevels", {(void*)&orig_FeatureLevels, (void*)&FeatureLevels}},
    {"SDKVersion", {(void*)&orig_SDKVersion, (void*)&SDKVersion}},
    {"pSwapChainDesc", {(void*)&orig_pSwapChainDesc, (void*)&pSwapChainDesc}},
    {"ppSwapChain", {(void*)&orig_ppSwapChain, (void*)&ppSwapChain}},
    {"ppDevice", {(void*)&orig_ppDevice, (void*)&ppDevice}},
    {"pFeatureLevel", {(void*)&orig_pFeatureLevel, (void*)&pFeatureLevel}},
    {"ppImmediateContext", {(void*)&orig_ppImmediateContext, (void*)&ppImmediateContext}},
  });
  return ret;
}
HRESULT WrappedCreateDXGIFactory2(
  UINT Flags, 
  const IID & riid, 
  void ** ppFactory
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Flags = Flags;
  auto orig_riid = riid;
  auto orig_ppFactory = ppFactory;
  auto ret = CreateDXGIFactory2(
    Flags, 
    riid, 
    ppFactory
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret)
    HandleWrap(riid, (void**)ppFactory);
  dumpFunctionEvent("CreateDXGIFactory2", &ret, {
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppFactory", {(void*)&orig_ppFactory, (void*)&ppFactory}},
  });
  return ret;
}
HRESULT WrappedDXGIGetDebugInterface1(
  UINT Flags, 
  const IID & riid, 
  void ** pDebug
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Flags = Flags;
  auto orig_riid = riid;
  auto orig_pDebug = pDebug;
  auto ret = DXGIGetDebugInterface1(
    Flags, 
    riid, 
    pDebug
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if(!ret)
    HandleWrap(riid, (void**)pDebug);
  dumpFunctionEvent("DXGIGetDebugInterface1", &ret, {
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"pDebug", {(void*)&orig_pDebug, (void*)&pDebug}},
  });
  return ret;
}
HRESULT WrappedD3DReadFileToBlob(
  LPCWSTR pFileName, 
  ID3DBlob ** ppContents
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFileName = pFileName;
  auto orig_ppContents = ppContents;
  auto ret = D3DReadFileToBlob(
    pFileName, 
    ppContents
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppContents && *ppContents)
    *ppContents = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppContents);
  dumpFunctionEvent("D3DReadFileToBlob", &ret, {
    {"pFileName", {(void*)&orig_pFileName, (void*)&pFileName}},
    {"ppContents", {(void*)&orig_ppContents, (void*)&ppContents}},
  });
  return ret;
}
HRESULT WrappedD3DWriteBlobToFile(
  ID3DBlob * pBlob, 
  LPCWSTR pFileName, 
  BOOL bOverwrite
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pBlob = pBlob;
  auto orig_pFileName = pFileName;
  auto orig_bOverwrite = bOverwrite;
  auto ret = D3DWriteBlobToFile(
    unwrap(pBlob), 
    pFileName, 
    bOverwrite
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpFunctionEvent("D3DWriteBlobToFile", &ret, {
    {"pBlob", {(void*)&orig_pBlob, (void*)&pBlob}},
    {"pFileName", {(void*)&orig_pFileName, (void*)&pFileName}},
    {"bOverwrite", {(void*)&orig_bOverwrite, (void*)&bOverwrite}},
  });
  return ret;
}
HRESULT WrappedD3DCompile(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  LPCSTR pSourceName, 
  const D3D_SHADER_MACRO * pDefines, 
  ID3DInclude * pInclude, 
  LPCSTR pEntrypoint, 
  LPCSTR pTarget, 
  UINT Flags1, 
  UINT Flags2, 
  ID3DBlob ** ppCode, 
  ID3DBlob ** ppErrorMsgs
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_pSourceName = pSourceName;
  auto orig_pDefines = pDefines;
  auto orig_pInclude = pInclude;
  auto orig_pEntrypoint = pEntrypoint;
  auto orig_pTarget = pTarget;
  auto orig_Flags1 = Flags1;
  auto orig_Flags2 = Flags2;
  auto orig_ppCode = ppCode;
  auto orig_ppErrorMsgs = ppErrorMsgs;
  auto ret = D3DCompile(
    pSrcData, 
    SrcDataSize, 
    pSourceName, 
    pDefines, 
    unwrap(pInclude), 
    pEntrypoint, 
    pTarget, 
    Flags1, 
    Flags2, 
    ppCode, 
    ppErrorMsgs
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCode && *ppCode)
    *ppCode = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppCode);
  if (!ret && ppErrorMsgs && *ppErrorMsgs)
    *ppErrorMsgs = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppErrorMsgs);
  dumpFunctionEvent("D3DCompile", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"pSourceName", {(void*)&orig_pSourceName, (void*)&pSourceName}},
    {"pDefines", {(void*)&orig_pDefines, (void*)&pDefines}},
    {"pInclude", {(void*)&orig_pInclude, (void*)&pInclude}},
    {"pEntrypoint", {(void*)&orig_pEntrypoint, (void*)&pEntrypoint}},
    {"pTarget", {(void*)&orig_pTarget, (void*)&pTarget}},
    {"Flags1", {(void*)&orig_Flags1, (void*)&Flags1}},
    {"Flags2", {(void*)&orig_Flags2, (void*)&Flags2}},
    {"ppCode", {(void*)&orig_ppCode, (void*)&ppCode}},
    {"ppErrorMsgs", {(void*)&orig_ppErrorMsgs, (void*)&ppErrorMsgs}},
  });
  return ret;
}
HRESULT WrappedD3DCompile2(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  LPCSTR pSourceName, 
  const D3D_SHADER_MACRO * pDefines, 
  ID3DInclude * pInclude, 
  LPCSTR pEntrypoint, 
  LPCSTR pTarget, 
  UINT Flags1, 
  UINT Flags2, 
  UINT SecondaryDataFlags, 
  LPCVOID pSecondaryData, 
  SIZE_T SecondaryDataSize, 
  ID3DBlob ** ppCode, 
  ID3DBlob ** ppErrorMsgs
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_pSourceName = pSourceName;
  auto orig_pDefines = pDefines;
  auto orig_pInclude = pInclude;
  auto orig_pEntrypoint = pEntrypoint;
  auto orig_pTarget = pTarget;
  auto orig_Flags1 = Flags1;
  auto orig_Flags2 = Flags2;
  auto orig_SecondaryDataFlags = SecondaryDataFlags;
  auto orig_pSecondaryData = pSecondaryData;
  auto orig_SecondaryDataSize = SecondaryDataSize;
  auto orig_ppCode = ppCode;
  auto orig_ppErrorMsgs = ppErrorMsgs;
  auto ret = D3DCompile2(
    pSrcData, 
    SrcDataSize, 
    pSourceName, 
    pDefines, 
    unwrap(pInclude), 
    pEntrypoint, 
    pTarget, 
    Flags1, 
    Flags2, 
    SecondaryDataFlags, 
    pSecondaryData, 
    SecondaryDataSize, 
    ppCode, 
    ppErrorMsgs
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCode && *ppCode)
    *ppCode = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppCode);
  if (!ret && ppErrorMsgs && *ppErrorMsgs)
    *ppErrorMsgs = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppErrorMsgs);
  dumpFunctionEvent("D3DCompile2", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"pSourceName", {(void*)&orig_pSourceName, (void*)&pSourceName}},
    {"pDefines", {(void*)&orig_pDefines, (void*)&pDefines}},
    {"pInclude", {(void*)&orig_pInclude, (void*)&pInclude}},
    {"pEntrypoint", {(void*)&orig_pEntrypoint, (void*)&pEntrypoint}},
    {"pTarget", {(void*)&orig_pTarget, (void*)&pTarget}},
    {"Flags1", {(void*)&orig_Flags1, (void*)&Flags1}},
    {"Flags2", {(void*)&orig_Flags2, (void*)&Flags2}},
    {"SecondaryDataFlags", {(void*)&orig_SecondaryDataFlags, (void*)&SecondaryDataFlags}},
    {"pSecondaryData", {(void*)&orig_pSecondaryData, (void*)&pSecondaryData}},
    {"SecondaryDataSize", {(void*)&orig_SecondaryDataSize, (void*)&SecondaryDataSize}},
    {"ppCode", {(void*)&orig_ppCode, (void*)&ppCode}},
    {"ppErrorMsgs", {(void*)&orig_ppErrorMsgs, (void*)&ppErrorMsgs}},
  });
  return ret;
}
HRESULT WrappedD3DCompileFromFile(
  LPCWSTR pFileName, 
  const D3D_SHADER_MACRO * pDefines, 
  ID3DInclude * pInclude, 
  LPCSTR pEntrypoint, 
  LPCSTR pTarget, 
  UINT Flags1, 
  UINT Flags2, 
  ID3DBlob ** ppCode, 
  ID3DBlob ** ppErrorMsgs
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pFileName = pFileName;
  auto orig_pDefines = pDefines;
  auto orig_pInclude = pInclude;
  auto orig_pEntrypoint = pEntrypoint;
  auto orig_pTarget = pTarget;
  auto orig_Flags1 = Flags1;
  auto orig_Flags2 = Flags2;
  auto orig_ppCode = ppCode;
  auto orig_ppErrorMsgs = ppErrorMsgs;
  auto ret = D3DCompileFromFile(
    pFileName, 
    pDefines, 
    unwrap(pInclude), 
    pEntrypoint, 
    pTarget, 
    Flags1, 
    Flags2, 
    ppCode, 
    ppErrorMsgs
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCode && *ppCode)
    *ppCode = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppCode);
  if (!ret && ppErrorMsgs && *ppErrorMsgs)
    *ppErrorMsgs = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppErrorMsgs);
  dumpFunctionEvent("D3DCompileFromFile", &ret, {
    {"pFileName", {(void*)&orig_pFileName, (void*)&pFileName}},
    {"pDefines", {(void*)&orig_pDefines, (void*)&pDefines}},
    {"pInclude", {(void*)&orig_pInclude, (void*)&pInclude}},
    {"pEntrypoint", {(void*)&orig_pEntrypoint, (void*)&pEntrypoint}},
    {"pTarget", {(void*)&orig_pTarget, (void*)&pTarget}},
    {"Flags1", {(void*)&orig_Flags1, (void*)&Flags1}},
    {"Flags2", {(void*)&orig_Flags2, (void*)&Flags2}},
    {"ppCode", {(void*)&orig_ppCode, (void*)&ppCode}},
    {"ppErrorMsgs", {(void*)&orig_ppErrorMsgs, (void*)&ppErrorMsgs}},
  });
  return ret;
}
HRESULT WrappedD3DPreprocess(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  LPCSTR pSourceName, 
  const D3D_SHADER_MACRO * pDefines, 
  ID3DInclude * pInclude, 
  ID3DBlob ** ppCodeText, 
  ID3DBlob ** ppErrorMsgs
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_pSourceName = pSourceName;
  auto orig_pDefines = pDefines;
  auto orig_pInclude = pInclude;
  auto orig_ppCodeText = ppCodeText;
  auto orig_ppErrorMsgs = ppErrorMsgs;
  auto ret = D3DPreprocess(
    pSrcData, 
    SrcDataSize, 
    pSourceName, 
    unwrap(pDefines), 
    unwrap(pInclude), 
    ppCodeText, 
    ppErrorMsgs
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCodeText && *ppCodeText)
    *ppCodeText = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppCodeText);
  if (!ret && ppErrorMsgs && *ppErrorMsgs)
    *ppErrorMsgs = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppErrorMsgs);
  dumpFunctionEvent("D3DPreprocess", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"pSourceName", {(void*)&orig_pSourceName, (void*)&pSourceName}},
    {"pDefines", {(void*)&orig_pDefines, (void*)&pDefines}},
    {"pInclude", {(void*)&orig_pInclude, (void*)&pInclude}},
    {"ppCodeText", {(void*)&orig_ppCodeText, (void*)&ppCodeText}},
    {"ppErrorMsgs", {(void*)&orig_ppErrorMsgs, (void*)&ppErrorMsgs}},
  });
  return ret;
}
HRESULT WrappedD3DGetDebugInfo(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  ID3DBlob ** ppDebugInfo
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_ppDebugInfo = ppDebugInfo;
  auto ret = D3DGetDebugInfo(
    pSrcData, 
    SrcDataSize, 
    ppDebugInfo
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDebugInfo && *ppDebugInfo)
    *ppDebugInfo = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppDebugInfo);
  dumpFunctionEvent("D3DGetDebugInfo", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"ppDebugInfo", {(void*)&orig_ppDebugInfo, (void*)&ppDebugInfo}},
  });
  return ret;
}
HRESULT WrappedD3DReflect(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  const IID & pInterface, 
  void ** ppReflector
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_pInterface = pInterface;
  auto orig_ppReflector = ppReflector;
  auto ret = D3DReflect(
    pSrcData, 
    SrcDataSize, 
    pInterface, 
    ppReflector
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  assert(false && "Wrap not implemented; Emit Seg Fault");
  dumpFunctionEvent("D3DReflect", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"pInterface", {(void*)&orig_pInterface, (void*)&pInterface}},
    {"ppReflector", {(void*)&orig_ppReflector, (void*)&ppReflector}},
  });
  return ret;
}
HRESULT WrappedD3DReflectLibrary(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  const IID & riid, 
  LPVOID * ppReflector
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_riid = riid;
  auto orig_ppReflector = ppReflector;
  auto ret = D3DReflectLibrary(
    pSrcData, 
    SrcDataSize, 
    riid, 
    unwrap(ppReflector)
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpFunctionEvent("D3DReflectLibrary", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"riid", {(void*)&orig_riid, (void*)&riid}},
    {"ppReflector", {(void*)&orig_ppReflector, (void*)&ppReflector}},
  });
  return ret;
}
HRESULT WrappedD3DDisassemble(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  UINT Flags, 
  LPCSTR szComments, 
  ID3DBlob ** ppDisassembly
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_Flags = Flags;
  auto orig_szComments = szComments;
  auto orig_ppDisassembly = ppDisassembly;
  auto ret = D3DDisassemble(
    pSrcData, 
    SrcDataSize, 
    Flags, 
    szComments, 
    ppDisassembly
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDisassembly && *ppDisassembly)
    *ppDisassembly = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppDisassembly);
  dumpFunctionEvent("D3DDisassemble", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"szComments", {(void*)&orig_szComments, (void*)&szComments}},
    {"ppDisassembly", {(void*)&orig_ppDisassembly, (void*)&ppDisassembly}},
  });
  return ret;
}
HRESULT WrappedD3DDisassembleRegion(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  UINT Flags, 
  LPCSTR szComments, 
  SIZE_T StartByteOffset, 
  SIZE_T NumInsts, 
  SIZE_T * pFinishByteOffset, 
  ID3DBlob ** ppDisassembly
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_Flags = Flags;
  auto orig_szComments = szComments;
  auto orig_StartByteOffset = StartByteOffset;
  auto orig_NumInsts = NumInsts;
  auto orig_pFinishByteOffset = pFinishByteOffset;
  auto orig_ppDisassembly = ppDisassembly;
  auto ret = D3DDisassembleRegion(
    pSrcData, 
    SrcDataSize, 
    Flags, 
    szComments, 
    StartByteOffset, 
    NumInsts, 
    pFinishByteOffset, 
    ppDisassembly
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDisassembly && *ppDisassembly)
    *ppDisassembly = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppDisassembly);
  dumpFunctionEvent("D3DDisassembleRegion", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"szComments", {(void*)&orig_szComments, (void*)&szComments}},
    {"StartByteOffset", {(void*)&orig_StartByteOffset, (void*)&StartByteOffset}},
    {"NumInsts", {(void*)&orig_NumInsts, (void*)&NumInsts}},
    {"pFinishByteOffset", {(void*)&orig_pFinishByteOffset, (void*)&pFinishByteOffset}},
    {"ppDisassembly", {(void*)&orig_ppDisassembly, (void*)&ppDisassembly}},
  });
  return ret;
}
HRESULT WrappedD3DCreateLinker(
  struct ID3D11Linker ** ppLinker
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_ppLinker = ppLinker;
  auto ret = D3DCreateLinker(
    ppLinker
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppLinker && *ppLinker)
    *ppLinker = getWrapper<ID3D11Linker, WrappedID3D11Linker>(*ppLinker);
  dumpFunctionEvent("D3DCreateLinker", &ret, {
    {"ppLinker", {(void*)&orig_ppLinker, (void*)&ppLinker}},
  });
  return ret;
}
HRESULT WrappedD3DLoadModule(
  LPCVOID pSrcData, 
  SIZE_T cbSrcDataSize, 
  struct ID3D11Module ** ppModule
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_cbSrcDataSize = cbSrcDataSize;
  auto orig_ppModule = ppModule;
  auto ret = D3DLoadModule(
    pSrcData, 
    cbSrcDataSize, 
    ppModule
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppModule && *ppModule)
    *ppModule = getWrapper<ID3D11Module, WrappedID3D11Module>(*ppModule);
  dumpFunctionEvent("D3DLoadModule", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"cbSrcDataSize", {(void*)&orig_cbSrcDataSize, (void*)&cbSrcDataSize}},
    {"ppModule", {(void*)&orig_ppModule, (void*)&ppModule}},
  });
  return ret;
}
HRESULT WrappedD3DCreateFunctionLinkingGraph(
  UINT uFlags, 
  struct ID3D11FunctionLinkingGraph ** ppFunctionLinkingGraph
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uFlags = uFlags;
  auto orig_ppFunctionLinkingGraph = ppFunctionLinkingGraph;
  auto ret = D3DCreateFunctionLinkingGraph(
    uFlags, 
    ppFunctionLinkingGraph
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppFunctionLinkingGraph && *ppFunctionLinkingGraph)
    *ppFunctionLinkingGraph = getWrapper<ID3D11FunctionLinkingGraph, WrappedID3D11FunctionLinkingGraph>(*ppFunctionLinkingGraph);
  dumpFunctionEvent("D3DCreateFunctionLinkingGraph", &ret, {
    {"uFlags", {(void*)&orig_uFlags, (void*)&uFlags}},
    {"ppFunctionLinkingGraph", {(void*)&orig_ppFunctionLinkingGraph, (void*)&ppFunctionLinkingGraph}},
  });
  return ret;
}
HRESULT WrappedD3DGetTraceInstructionOffsets(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  UINT Flags, 
  SIZE_T StartInstIndex, 
  SIZE_T NumInsts, 
  SIZE_T * pOffsets, 
  SIZE_T * pTotalInsts
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_Flags = Flags;
  auto orig_StartInstIndex = StartInstIndex;
  auto orig_NumInsts = NumInsts;
  auto orig_pOffsets = pOffsets;
  auto orig_pTotalInsts = pTotalInsts;
  auto ret = D3DGetTraceInstructionOffsets(
    pSrcData, 
    SrcDataSize, 
    Flags, 
    StartInstIndex, 
    NumInsts, 
    unwrap(pOffsets), 
    pTotalInsts
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  dumpFunctionEvent("D3DGetTraceInstructionOffsets", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"StartInstIndex", {(void*)&orig_StartInstIndex, (void*)&StartInstIndex}},
    {"NumInsts", {(void*)&orig_NumInsts, (void*)&NumInsts}},
    {"pOffsets", {(void*)&orig_pOffsets, (void*)&pOffsets}},
    {"pTotalInsts", {(void*)&orig_pTotalInsts, (void*)&pTotalInsts}},
  });
  return ret;
}
HRESULT WrappedD3DGetInputSignatureBlob(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  ID3DBlob ** ppSignatureBlob
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_ppSignatureBlob = ppSignatureBlob;
  auto ret = D3DGetInputSignatureBlob(
    pSrcData, 
    SrcDataSize, 
    ppSignatureBlob
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSignatureBlob && *ppSignatureBlob)
    *ppSignatureBlob = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppSignatureBlob);
  dumpFunctionEvent("D3DGetInputSignatureBlob", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"ppSignatureBlob", {(void*)&orig_ppSignatureBlob, (void*)&ppSignatureBlob}},
  });
  return ret;
}
HRESULT WrappedD3DGetOutputSignatureBlob(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  ID3DBlob ** ppSignatureBlob
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_ppSignatureBlob = ppSignatureBlob;
  auto ret = D3DGetOutputSignatureBlob(
    pSrcData, 
    SrcDataSize, 
    ppSignatureBlob
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSignatureBlob && *ppSignatureBlob)
    *ppSignatureBlob = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppSignatureBlob);
  dumpFunctionEvent("D3DGetOutputSignatureBlob", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"ppSignatureBlob", {(void*)&orig_ppSignatureBlob, (void*)&ppSignatureBlob}},
  });
  return ret;
}
HRESULT WrappedD3DGetInputAndOutputSignatureBlob(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  ID3DBlob ** ppSignatureBlob
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_ppSignatureBlob = ppSignatureBlob;
  auto ret = D3DGetInputAndOutputSignatureBlob(
    pSrcData, 
    SrcDataSize, 
    ppSignatureBlob
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppSignatureBlob && *ppSignatureBlob)
    *ppSignatureBlob = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppSignatureBlob);
  dumpFunctionEvent("D3DGetInputAndOutputSignatureBlob", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"ppSignatureBlob", {(void*)&orig_ppSignatureBlob, (void*)&ppSignatureBlob}},
  });
  return ret;
}
HRESULT WrappedD3DStripShader(
  LPCVOID pShaderBytecode, 
  SIZE_T BytecodeLength, 
  UINT uStripFlags, 
  ID3DBlob ** ppStrippedBlob
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pShaderBytecode = pShaderBytecode;
  auto orig_BytecodeLength = BytecodeLength;
  auto orig_uStripFlags = uStripFlags;
  auto orig_ppStrippedBlob = ppStrippedBlob;
  auto ret = D3DStripShader(
    pShaderBytecode, 
    BytecodeLength, 
    uStripFlags, 
    ppStrippedBlob
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppStrippedBlob && *ppStrippedBlob)
    *ppStrippedBlob = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppStrippedBlob);
  dumpFunctionEvent("D3DStripShader", &ret, {
    {"pShaderBytecode", {(void*)&orig_pShaderBytecode, (void*)&pShaderBytecode}},
    {"BytecodeLength", {(void*)&orig_BytecodeLength, (void*)&BytecodeLength}},
    {"uStripFlags", {(void*)&orig_uStripFlags, (void*)&uStripFlags}},
    {"ppStrippedBlob", {(void*)&orig_ppStrippedBlob, (void*)&ppStrippedBlob}},
  });
  return ret;
}
HRESULT WrappedD3DGetBlobPart(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  D3D_BLOB_PART Part, 
  UINT Flags, 
  ID3DBlob ** ppPart
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_Part = Part;
  auto orig_Flags = Flags;
  auto orig_ppPart = ppPart;
  auto ret = D3DGetBlobPart(
    pSrcData, 
    SrcDataSize, 
    Part, 
    Flags, 
    ppPart
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppPart && *ppPart)
    *ppPart = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppPart);
  dumpFunctionEvent("D3DGetBlobPart", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"Part", {(void*)&orig_Part, (void*)&Part}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"ppPart", {(void*)&orig_ppPart, (void*)&ppPart}},
  });
  return ret;
}
HRESULT WrappedD3DSetBlobPart(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  D3D_BLOB_PART Part, 
  UINT Flags, 
  LPCVOID pPart, 
  SIZE_T PartSize, 
  ID3DBlob ** ppNewShader
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_Part = Part;
  auto orig_Flags = Flags;
  auto orig_pPart = pPart;
  auto orig_PartSize = PartSize;
  auto orig_ppNewShader = ppNewShader;
  auto ret = D3DSetBlobPart(
    pSrcData, 
    SrcDataSize, 
    Part, 
    Flags, 
    pPart, 
    PartSize, 
    ppNewShader
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppNewShader && *ppNewShader)
    *ppNewShader = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppNewShader);
  dumpFunctionEvent("D3DSetBlobPart", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"Part", {(void*)&orig_Part, (void*)&Part}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"pPart", {(void*)&orig_pPart, (void*)&pPart}},
    {"PartSize", {(void*)&orig_PartSize, (void*)&PartSize}},
    {"ppNewShader", {(void*)&orig_ppNewShader, (void*)&ppNewShader}},
  });
  return ret;
}
HRESULT WrappedD3DCreateBlob(
  SIZE_T Size, 
  ID3DBlob ** ppBlob
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_Size = Size;
  auto orig_ppBlob = ppBlob;
  auto ret = D3DCreateBlob(
    Size, 
    ppBlob
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppBlob && *ppBlob)
    *ppBlob = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppBlob);
  dumpFunctionEvent("D3DCreateBlob", &ret, {
    {"Size", {(void*)&orig_Size, (void*)&Size}},
    {"ppBlob", {(void*)&orig_ppBlob, (void*)&ppBlob}},
  });
  return ret;
}
HRESULT WrappedD3DCompressShaders(
  UINT uNumShaders, 
  D3D_SHADER_DATA * pShaderData, 
  UINT uFlags, 
  ID3DBlob ** ppCompressedData
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_uNumShaders = uNumShaders;
  auto orig_pShaderData = pShaderData;
  auto orig_uFlags = uFlags;
  auto orig_ppCompressedData = ppCompressedData;
  auto ret = D3DCompressShaders(
    uNumShaders, 
    pShaderData, 
    uFlags, 
    ppCompressedData
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppCompressedData && *ppCompressedData)
    *ppCompressedData = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppCompressedData);
  dumpFunctionEvent("D3DCompressShaders", &ret, {
    {"uNumShaders", {(void*)&orig_uNumShaders, (void*)&uNumShaders}},
    {"pShaderData", {(void*)&orig_pShaderData, (void*)&pShaderData}},
    {"uFlags", {(void*)&orig_uFlags, (void*)&uFlags}},
    {"ppCompressedData", {(void*)&orig_ppCompressedData, (void*)&ppCompressedData}},
  });
  return ret;
}
HRESULT WrappedD3DDecompressShaders(
  LPCVOID pSrcData, 
  SIZE_T SrcDataSize, 
  UINT uNumShaders, 
  UINT uStartIndex, 
  UINT * pIndices, 
  UINT uFlags, 
  ID3DBlob ** ppShaders, 
  UINT * pTotalShaders
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pSrcData = pSrcData;
  auto orig_SrcDataSize = SrcDataSize;
  auto orig_uNumShaders = uNumShaders;
  auto orig_uStartIndex = uStartIndex;
  auto orig_pIndices = pIndices;
  auto orig_uFlags = uFlags;
  auto orig_ppShaders = ppShaders;
  auto orig_pTotalShaders = pTotalShaders;
  auto ret = D3DDecompressShaders(
    pSrcData, 
    SrcDataSize, 
    uNumShaders, 
    uStartIndex, 
    pIndices, 
    uFlags, 
    ppShaders, 
    pTotalShaders
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppShaders && *ppShaders)
    *ppShaders = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppShaders);
  dumpFunctionEvent("D3DDecompressShaders", &ret, {
    {"pSrcData", {(void*)&orig_pSrcData, (void*)&pSrcData}},
    {"SrcDataSize", {(void*)&orig_SrcDataSize, (void*)&SrcDataSize}},
    {"uNumShaders", {(void*)&orig_uNumShaders, (void*)&uNumShaders}},
    {"uStartIndex", {(void*)&orig_uStartIndex, (void*)&uStartIndex}},
    {"pIndices", {(void*)&orig_pIndices, (void*)&pIndices}},
    {"uFlags", {(void*)&orig_uFlags, (void*)&uFlags}},
    {"ppShaders", {(void*)&orig_ppShaders, (void*)&ppShaders}},
    {"pTotalShaders", {(void*)&orig_pTotalShaders, (void*)&pTotalShaders}},
  });
  return ret;
}
HRESULT WrappedD3DDisassemble10Effect(
  struct ID3D10Effect * pEffect, 
  UINT Flags, 
  ID3DBlob ** ppDisassembly
) {
  bool recursionFlag = false;
  getRecursionFlag().compare_exchange_strong(recursionFlag, true);
  auto orig_pEffect = pEffect;
  auto orig_Flags = Flags;
  auto orig_ppDisassembly = ppDisassembly;
  auto ret = D3DDisassemble10Effect(
    unwrap(pEffect), 
    Flags, 
    ppDisassembly
  );
  if (recursionFlag)
    return ret;
  getRecursionFlag() = false;
  if (!ret && ppDisassembly && *ppDisassembly)
    *ppDisassembly = getWrapper<ID3DBlob, WrappedID3D10Blob>(*ppDisassembly);
  dumpFunctionEvent("D3DDisassemble10Effect", &ret, {
    {"pEffect", {(void*)&orig_pEffect, (void*)&pEffect}},
    {"Flags", {(void*)&orig_Flags, (void*)&Flags}},
    {"ppDisassembly", {(void*)&orig_ppDisassembly, (void*)&ppDisassembly}},
  });
  return ret;
}
